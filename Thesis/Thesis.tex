%---------------------------------
% Preamble
%---------------------------------
\input{preamble.tex}

%---------------------------------
% Document start
%---------------------------------
\begin{document}

\listoftodos

%---------------------------------
% Titlepage
%---------------------------------
\input{titlepage.tex}

%---------------------------------
% table of contents
%---------------------------------
\tableofcontents
\newpage

%---------------------------------
% Allgemeines
%---------------------------------
\addsec{Allgemeines}
\label{sec:Allgemeines}
  %---------------------------------
  % Eidesstattliche Erklärung
  %---------------------------------
  \subsection*{Eidesstattliche Erklärung}
  \addcontentsline{toc}{subsection}{Eidesstattliche Erklärung}
  \label{ssec:Eidesstattliche Erklärung}
    Ich, \MetaAuthor, Matrikel-Nr. \MetaStudentNumber, versichere hiermit, dass ich meine Bachelorarbeit mit dem Thema
    \begin{center}
      \vspace*{-1em}
      \textit{\MetaTitle}
      \vspace*{-1em}
    \end{center}
    selbständig verfasst und keine anderen als die angegebenen Quellen und Hilfsmittel benutzt habe, wobei ich alle wörtlichen und sinngemäßen Zitate als solche gekennzeichnet habe. Die Arbeit wurde bisher keiner anderen Prüfungsbehörde vorgelegt und auch nicht veröffentlicht.

    \vspace*{3em}
    \begin{tabular}{@{}rc}
      \raisebox{.2em}{Bremen, den \today}
        &\makebox[4cm]{\hrulefill}\\
      {}
        &\MetaAuthor
    \end{tabular}

\pagebreak

  %---------------------------------
  % Danksagung
  %---------------------------------
  \subsection*{Danksagung}
  \addcontentsline{toc}{subsection}{Danksagung}
  \label{ssec:Danksagung}
\myTodo{Danke an Mutter, Vater und alle Profs} % TODO

    \begin{figure}[H]
      \centering
      \begin{tikzpicture}[%
        spy using outlines={%
          circle,%
          Cornsilk,%
          magnification=2,%
          size=3.5cm,%
          connect spies%
        }%
      ]
        \node{
          \pgfimage[%
            interpolate=true,%
            width=.8\linewidth%
          ]{%
            img/bb%
          }
        };
        \spy on (.1,-.3) in node [left] at (-2,1.9);
      \end{tikzpicture}

      \caption{\textit{``Das soll meine Zukunft sein?''}}
    \end{figure}

\pagebreak

%---------------------------------
% Einleitung
%---------------------------------
\section{Einleitung}
\label{sec:Einleitung}
\myQuestion{Text Größe, Zeilenabstand?} %TODO
  Die Einführung von Automatisierung in ein Softwaresystem ist vergleichbar mit den Maschinen, die in der industrielle Revolution auftauchten. Anstelle, dass Menschen arbeiten müssen, um ein gewünschtes Ergebnis zu bekommen, drücken sie auf einen Knopf, und ein anderes System nimmt ihnen die aufwändige Arbeit ab. Dies führt dazu, dass Produkte schneller, mit weniger Arbeitsaufwand erstellt werden können. Zudem ist die entstehende Qualität immer auf einem gleichbleibenden Level und hängt nicht von dem Befinden der Arbeiter ab.

  Die P3-group arbeitet mit Airbus, um Lösungen für den Flugzeugbau zu entwickeln. Dieser Markt ist hart umkämpft, wodurch minimale Gewinne einen großen Unterschied machen können. Ein Feld, welches seit Jahren immer weiter durch wissenschaftliche und technische Durchbrüche optimiert wird, sind die menschlichen Ressourcen. Automatisierung sorgt dafür, dass sich wiederholende Arbeitsabläufe -- aus der Sicht des Nutzers -- zu einem einzigen Schritt werden und so Zeit sparen.

  Makros sind die Fließbänder der digitalen Welt, und diese Arbeit beschäftigt sich mit der Entwicklung eines Makro Systems bzw. Sprache.

  Makros werden durch die Verbindung kleinerer Bausteine (Anweisungen) erstellt. Diese können andere Makros oder Anweisungen, die die Anwendungsumgebung bereitstellt, sein. Dies ist mit einem Fließband in der Autoindustrie zu vergleichen. Jede Station ist genau für eine Aufgabe zuständig und kümmert sich um nichts anderes.

  Die Makrosprache ist ein Baukasten, mit dem Makros erstellt -- ``Fließbänder'' für spezielle Aufgaben erzeugt -- werden können.

  %---------------------------------
  % Problemfeld
  %---------------------------------
  \subsection{Problemfeld}
  \label{ssec:Problemfeld}
    Softwaresysteme haben oft das Problem, dass sie mit einigen zentralen Features anfangen, die fest definiert werden (sollten), bevor ein Vertrag geschlossen wird. Für weitere Funktionalität, die über die Vereinbarungen im Vertrag hinausgehen, muss der Vertrag erweitert werden. Wenn der Vertrag erfüllt ist, und im Anschluss weitere Wünsche aufkommen, muss ein weiterer Vertrag aufgesetzt werden und die vorher gelieferte Software muss angepasst, gegebenenfalls erweitert werden. Dies kann zur Folge haben, dass große Teile der Software umgeschrieben werden müssen, oder sogar, dass die Architektur der gesamten Anwendung verändert werden muss.

    Wenn frühzeitig ein Makrosystem/-sprache und ein entsprechendes Erweiterungskonzept für Module bzw. Plugins eingeführt wird, ist die Wahrscheinlichkeit, dass der Kern der Applikation für Erweiterungen angefasst werden muss, wesentlich geringer. Durch diese Kombination kann einfach ein weiteres Modul geladen werden, welches die neuen Grundbausteine der Applikation hinzufügt. Diese können dann in einem neuen, oder angepassten Makro genutzt werden, um den Wunsch der Kunden zu erfüllen. Im Falle, dass es keiner neuen Grundbausteine bedarf, reicht es sogar, nur ein Makro zu liefern. Die Vorteile dieser Methode sind, dass -- wenn man davon ausgeht, dass die benutzen Makros und Grundbausteine fehlerfrei durch ausreichendes Testen der Software sind -- keine neuen Bugs in den Kern der Software eingeführt werden können und somit immens zu der Stabilität der Software beigetragen wird. Ein weiterer Vorteil ist, dass die Makros mit wesentlich weniger Aufwand entwickelt werden können, weil sie sich auf einem höheren Level befinden. Für Kunden ist eine nutzbare Makrosprache auch interessant, weil sie zum Teil, durch das hausinterne Personal Anforderungen an die Software realisieren können, ohne den langen Weg über eine Firma zu gehen. Dies bedeutet auch, dass die Software eine bessere Chance hat, die Zeit zu überdauern.

  %---------------------------------
  % Ziele der Arbeit
  %---------------------------------
  \subsection{Ziele der Arbeit}
  \label{ssec:Ziele der Arbeit}
    Die Ziele der Arbeit sind es ein Makrosystem zu entwickeln, welches \ldots
    \begin{itemize}
      \item auf keinem festen \emph{Application Programming Interface (API)} aufbaut.

        Ein Feature der bestehenden Software ist es, dass sie durch \emph{Module}\footnote{
          Bibliotheken, die zur Laufzeit -- nach den dynamischen Bibliotheken --  nachgeladen werden können, um die Funktionalität der Applikation zu erweitern.
        } erweitert werden kann. Eines dieser Module wird das Makrosystem sein, welchen in dieser Arbeit entwickelt wird. Durch diese Modularität, gibt es kein festest Interface.

      \item nicht nur Anweisungen abarbeitet.

        Um eine große Bandbreite an Automatisierungsmöglichkeiten anbieten zu können, bedarf es logischer Ausdrücke, die bedingte Anweisungen erlauben. Ebenso ist es wichtig, dass man entscheiden kann, wie oft etwas ausgeführt werden soll, sprich Schleifen. Und die Makros sollen sowohl von dem Programm, als auch von anderen Makros Parameter übergeben bekommen können.

      \item nicht mehr kann als es können muss.

        Je mächtiger ein System ist, desto komplexer ist es. Zudem sind Features nur etwas wert, wenn sie gewinnbringend verkauft werden können.

      \item wartbar ist.

        Die Implementierung sollte keine komplexen Bestandteile besitzen, über die nicht geschlussfolgert werden kann.

      \item benutzerfreundlich ist.

        Die Lösung soll benutzerfreundlich sein, das heißt, dass Fehlermeldungen dem Nutzer schnell zu seinem Fehler führen und keine false positives enthalte.
    \end{itemize}

  %---------------------------------
  % Hintergründe und Entstehung des Themas
  %---------------------------------
  \subsection{Hintergründe und Entstehung des Themas}
  \label{ssec:Hintergründe und Entstehung des Themas}
    Die P3-group ist daran interessiert, dass sie ihren Kunden Lösungen schnell und in hoher Qualität anbieten kann. Um dies zu erreichen arbeiten sie daran, dass alle Softwaresysteme, die von ihnen angeboten werden, Automatisierung über Makros unterstützen. Wirtschaftlich rentieren sich die Makros dadurch, dass sie von den Firmen gemietet und nicht nur einmal verkauft werden. Zum Beispiel, werden alle Flugzeugteile ausgewählt und dann deren Gewicht ermittelt. Ein anderes Mal sollen nur spezielle Teile aus einem bestimmten Werkstoff zusammen gezählt und deren Preis ermittelt werden. Anstelle, dass hier eine sehr komplexe Suchfunktion entwickelt wurde, können hier zwei Makros zum Einsatz kommen, die jeweils eine Aufgabe erfüllen und somit für den Benutzer sicher zu handhaben sind. Die Komplexität der Software wurde durch das zweite Makro nicht sonderlich beeinflusst, da dieses intern auf Funktionalität zurückgreifen kann, die schon vom ersten genutzt wird.

  %---------------------------------
  % Struktur der Arbeit, wesentliche Inhalte der Kapitel
  %---------------------------------
  \subsection{Struktur der Arbeit, wesentliche Inhalte der Kapitel}
  \label{ssec:Struktur der Arbeit, wesentliche Inhalte der Kapitel}
    Die Arbeit ist in drei wesentliche Kapitel aufgeteilt, \myNamedRef{sec:Anforderungsanalyse}, \myNamedRef{sec:Konzeption} und \myNamedRef{sec:Exemplarische Realisierung}. Der Fokus dieser Kapitel geht vom Theoretischen zum Praktischen. Innerlich folgen die Kapitel den Arbeitsabläufen, die zur Entwicklung des Makrosystems genutzt wurden. Zudem gibt es dies \hyperref[sec:Einleitung]{Einleitungs} Kapitel, eine \nameref{sec:Evaluation} und einen \nameref{sec:Ausblick}.

    In dem Kapitel \nameref{sec:Anforderungsanalyse} werden die Anforderungen, sowie deren Probleme analysiert. Das Kapitel \nameref{sec:Konzeption} beschäftigt sich mit den Lösungen für die Anforderungen sowie der Probleme, die im vorherigen Kapitel gefunden wurden. Unter anderem beinhaltet das Kapitel die Software Architektur, sowie den Syntax für die Makrosprache. In dem Kapitel \nameref{sec:Exemplarische Realisierung} wird auf entscheidende Punkte der exemplarischen Realisierung eingegangen.

%---------------------------------
% Anforderungsanalyse
%---------------------------------
\section{An\-for\-de\-rungs\-ana\-ly\-se}
\label{sec:Anforderungsanalyse}
  Dieses Kapitel beschäftigt sich mit dem Problemfeld und den Anforderungen an die entstehende Lösung. In der \nameref{ssec:Diskussion des Problemfeldes} geht es vor allem darum, das Problemfeld zu analysieren und die Unterprobleme ausfindig zu machen, um abstrakte Lösungsansätze für diese zu entwickeln. Bei den \nameref{ssec:Anforderungen an die angestrebte Lösung} ist das Ziel die Anforderungen, die die Problemlösung erfüllen sollte zu definieren.

  %---------------------------------
  % Diskussion des Problemfeldes
  %---------------------------------
  \subsection{Diskussion des Problemfeldes}
  \label{ssec:Diskussion des Problemfeldes}
    Ein Makrosystem ist eine Komponente eines Softwaresystems, welche es erlaubt, die Software über eine Reihenfolge von Zeichen so zu steuern, als ob ein Mensch die Applikation bedient hätte.

    Die Funktionalität eines Makrosystems ist vergleichbar mit Programmiersprachen -- dort wird, durch eine Ansammlung von Zeichen, der Computer veranlasst, eine bestimmte Abfolge von Hardwareanweisungen auszuführen. Der Unterschied von einem Makrosystem zu zum Beispiel C ist, dass bei einem Makrosystem der Befehlssatz durch die Anwendung vorgegeben wird, wohingegen der Befehlssatz von C durch die Hardware vorgegeben ist. Somit ist ein Makrosystem eher mit einer Sprache zu vergleichen, die sich einer virtuellen Maschine bedient -- wie Java -- als mit C.\\
    Der Befehlssatz dieses Makrosystems kommt aus dem vorhandenen System, da dort das \emph{Command-Pattern}\autocite[S.263]{Gamma:1995:DPE:186897} eingesetzt wird und somit ein ideales Interface für Automatisierung bietet.

\myQuestion{Das folgende ist ziemlich komprimiert -- muss das noch ausführlicher durchgekaut werden (Kapitel Grundlagen?), oder ist das `Allgemeinwissen'?}  % TODO
    Für alle Programmiersprachen ist es von Nöten, die Reihenfolge von Zeichen (String), in sinnvolle Stücke zu zerteilen -- dies übernimmt ein Tokenizer. Meist wird dieser in den Parser\autocite[S.46]{eirund2013formale}
\myQuestion{Hierfür gib's doch sicherlich Bonuspunkte ;)} % TODO
    integriert, welcher die Stücken des Strings in ein Format bringt, welches der \emph{Interpreter}\autocite[S.274]{Gamma:1995:DPE:186897} verstehen kann. Das Format ist meist ein \emph{abstrakter Syntaxbaum}\footnote{%
      \textit{Abstract syntax tree} ist eine digitale Darstellung einer Programmiersprache.
    } (AST), welcher den String eindeutig repräsentiert. Der Interpreter arbeitet dann nur noch mit dem AST, welcher vorgibt welche Befehle der Interpreter ausführen muss, um das als String angegebene Programm auszuführen.

    Das vorhandene System ist in C++ geschrieben, weswegen es sich größten Teils erübrigt über andere Programmiersprachen nachzudenken. Durch das \emph{name mangling}\footnote{
      Beim `name mangling' fügt der Compiler den Funktionsnamen weite Informationen hinzu, um eine eindeutige Funktionssignatur zu erhalten.
    } ist es schwierig eine API von C++ zu anderen Programmiersprachen anzubieten -- meistens geschieht dies über eine C API. Bei dieser verliert man den Vorteil der Objektorientierung und muss meistens auch die Daten zwischen C++$\longleftrightarrow$C und C$\longleftrightarrow$XYZ (z.B Python oder Lua) konvertieren, was langsam ist. Die Makros müssen aber auf Daten arbeiten, welche als Objekte von C++ vorliegen, deswegen müsste der Stack, mit dem der Interpreter arbeitet, in der C++ Ebene bleiben. Damit würde eine Implementierung von Tokenizer, Parser, AST und Interpreter die Wartbarkeit, durch die Teilung und die weitere Programmiersprache deutlich verschlechtern. Zusätzlich ist das Ziel eine Applikation zu automatisieren, und nicht mit komplett neuen Funktionalitäten zu erweitern, was die Vorteile von z.B Python größtenteils zunichte macht.

    Die vorhandene Software ist Corss-Plattform (Windows und Linux) entwickelt. Im Rahmen dieser Bachelorarbeit wird die Software nur auf Linux entwickelt, da die \emph{Standard} Implementation von Microsoft unberechenbar ist und bei der Fehlersuche meist viel Zeit in Anspruch nimmt. Bei der Entwicklung wird daher darauf geachtet, dass keine Linux spezifischen Bibliotheken in Anspruch genommen werden. Das schließt leider nicht aus, dass die entstehende Software, ohne Anpassungen, auf Windows ausgeführt werden kann.

  %---------------------------------
  % Anforderungen an die angestrebte Lösung
  %---------------------------------
  \subsection{Anforderungen an die angestrebte Lösung}
  \label{ssec:Anforderungen an die angestrebte Lösung}
    Die Probleme, ein Makrosystem/-sprache in C++ zu implementieren, fangen dann an, wenn man von den Makros will, dass diese nicht nur hintereinander abgearbeitet werden, ohne dass sie wissen, dass andere Makros vor ihnen bzw. nach ihnen ausgeführt werden -- wie in \autoref{fig:sequential} zu sehen ist.

    \begin{figure}[H]
      \centering
      \myInput{img/sequential.tikz}
      \caption{Sequenzielles Abarbeiten von Prozessschritten.}
      \label{fig:sequential}
    \end{figure}

    \autoref{fig:logic} zeigt den ersten Schritt zu einer nützlichen Implementation -- Logik. Hierbei bietet man an, dass der Makro-Entwickler durch Rückgabewerte aus Makros entscheiden kann, welche weiteren Makros er ausführen möchte.

    \begin{figure}[H]
      \centering
      \myInput{img/logic.tikz}
      \caption{Logische Ausdrücke um bedingte Anweisungen zuzulassen.}
      \label{fig:logic}
    \end{figure}

    Obwohl man mit solchen Makros schon einige Probleme lösen kann, ist es nicht das, was man zur Verfügung haben will, wenn man mit objektorientierten Sprachen arbeitet bzw. mehr als ein \textit{`ja'} oder nein \textit{`nein'} braucht.

    Was ein Makrosystem/-sprache anbieten muss ist, dass Instanzen von verschiedenen Klassen/Typen zurückgegeben und beliebig viele Parameter (unterschiedlicher Klassen/Typen) dem Makro mitgegeben werden können. Leider sind gerade diese Punkte ein Problem in C++, weil C++ keine Reflexion\autocites{vinoski2005time}{ferber1989computational} unterstützt. Dies ist durch eine Implementation\footnote{%
      Das Command-Pattern wurde mit Hilfe des \texttt{any}\tablefootnote{%
        \url{http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3804.html}
      }
      sowie \texttt{optional}\tablefootnote{%
        \url{http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3793.html}
      }
      Types implementiert.
    }\spewnotes{}
    des Command-Patterns gelöst worden. Somit kommt in diesem Schritt `nur' noch hinzu, dass es Schleifen, sowie komplexe Parameter und Rückgabewerte geben kann, siehe \autoref{fig:loop}.

    \begin{figure}[H]
      \centering
      \myInput{img/loop.tikz}
      \caption{Schleife, die Anweisungen für ein Element aus der Liste aufrufen.}
      \label{fig:loop}
    \end{figure}

    Letztendlich kann man sagen, dass ein solches Makrosystem/-sprache eine Programmiersprache mit Interpreter sein sollte, deren Laufzeitumgebung eine anderes Softwaresystem ist.

    Die Fehlermeldungen, die bei Syntaxfehlern auftreten, sollten den Nutzer möglichst viele sinnvolle Informationen liefern -- als Vorbild dient hier definitiv Clang (siehe Abbildung \autoref{fig:clang_error}).

    \begin{myCodeEnv}
      \centering
      \begin{minipage}{.9\textwidth}
        \begin{lstlisting}[keepspaces,escapechar=°,numbers=none]
°\textbf{ main.cpp:4:42: \textcolor{red}{error}: expected ';' after expression}°
   std::cout << "Hallo Welt!" << std::endl
                                          °\textcolor{Green}{\textasciicircum}°
                                          °\textcolor{Green}{;}
        °\end{lstlisting}
      \end{minipage}
      \caption{Clang Fehlermeldung.}
      \label{fig:clang_error}
    \end{myCodeEnv}

%---------------------------------
% Konzeption
%---------------------------------
\section{Konzeption}
\label{sec:Konzeption}
  Dieses Kapitel beschäftigt sich mit der theoretischen Problemlösung.

  \autoref{ssec:Syntax} beschreibt die Syntax, welcher von dem Tokenizer und Parser umgewandelt werden soll. Im \autoref{ssec:Grundarchitektur} wird hauptsächlich die Architektur des Makrosystems beschrieben. Diese Grundarchitektur umfasst die grobe Architektur des gesamten Makrosystems. In den Kapiteln \nameref{ssec:Level 2 -- Logik / primitive Rückgabewerte} und
\myQuestion{Andere Kapitelnamen wären vielleicht sinnvoll?} % TODO
  \nameref{ssec:Level 3 -- Komplexe Rückgabewerte} wird genauer auf den Aufbau des Interpreters eingegangen.

  %---------------------------------
  % Syntax
  %---------------------------------
  \subsection{Syntax}
  \label{ssec:Syntax}
    Die Syntax ist an C, Python, JavaScript und Swift angelegt. C liefert den größten Anteil der Syntax, von Python wurde \lstinline[style=MyMacroStyle]$def$ übernommen, von JavaScript \lstinline[style=MyMacroStyle]$var$ und der named parameter Syntax \lstinline[style=MyMacroStyle]$fun(foo:gun());$ von Swift. Die Unterscheidung zwischen \lstinline[style=MyMacroStyle]$def$ und \lstinline[style=MyMacroStyle]$var$ sorgt dafür, dass der Programmierer nach den ersten drei Zeichen weiß, was der Folgende Code machen wird. Das die Makrosprache \emph{named parameter}\footnote{
      Named Parameter sind Parameter, die über einen Namen ihren Wert beim Funktionsaufruf zugewiesen bekommen. Die Normale Wertzuweisungsstrategie ist nach der Reihenfolge der Deklaration vor zu gehen.
    } unterstützt liegt daran, dass das Command-Pattern so implementiert wurde, dass Parameter alias Bezeichnungen benutzen können, um eine hohe Kompatibilität zwischen unabhängig entwickelten Modulen zu gewährleisten. Dies ist in der Makrosprache nicht so einfach möglich, somit sind sie named parameter der bestmögliche Kompromiss, da diese erlauben, die Parameter in beliebiger Reihenfolge anzugeben.

    Die folgenden Unterkapitel beschreiben die Syntax, die der Parser parsen muss. Hauptbestandteile sind Definitionen, Kontrollstrukturen, Variablen und Befehlen.

    %---------------------------------
    % Grundlagen
    %---------------------------------
    \subsubsection{Grundlagen}
    \label{sssec:Grundlagen}
      Bezeichner müssen dem Regex aus \autoref{fig:id_syntax} entsprechen. Das heißt, dass Bezeichner nur aus kleinen Buchstaben, Nummern und Unterstrichen bestehen können und am Anfang einen Buchstaben haben müssen. Grund für diese drastische Einschränkung ist, dass der Code einheitlich aussehen soll (die erste Regel was Bezeichnungen/Formatierung angeht ist, dass man sich an dem orientiert was schon existiert). Um dies besser garantieren zu können, wurde die CamelCase Schreibweise von vorn herein ausgeschlossen. Außerdem sind Bezeichner, die einem keyword entsprechen
  \myTodo{Update der keywords} % TODO
      (\lstinline[style=MyMacroStyle]$def$, \lstinline[style=MyMacroStyle]$var$, \lstinline[style=MyMacroStyle]$if$, \lstinline[style=MyMacroStyle]$else$, \lstinline[style=MyMacroStyle]$for$, \lstinline[style=MyMacroStyle]$do$, \lstinline[style=MyMacroStyle]$while$, \lstinline[style=MyMacroStyle]$break$, \lstinline[style=MyMacroStyle]$return$), einen Booleanwert entsprechen (\lstinline[style=MyMacroStyle]$true$, \lstinline[style=MyMacroStyle]$false$), oder \lstinline[style=MyMacroStyle]$main$ gleichen, verboten.

      \begin{figure}[H]
        \centering
        \myInput{img/id_syntax.tikz}
        \caption{Bezeichner}
        \label{fig:id_syntax}
      \end{figure}

      \autoref{fig:vpr_syntax} zeigt alle Werterzeuger, dass sind Konstrukte, die einen Wert für eine andere Operation bereitstellen.
      \begin{figure}[H]
        \centering
        \myInput{img/vpr_syntax.tikz}
        \caption{Werterzeuger}
        \label{fig:vpr_syntax}
      \end{figure}

      In \autoref{fig:return_syntax} ist die Syntax von \lstinline[style=MyMacroStyle]$return$ zu sehen.
      \begin{figure}[H]
        \centering
        \myInput{img/ret_syntax.tikz}
        \caption{Syntax von return.}
        \label{fig:return_syntax}
      \end{figure}

      Literals sind entweder Doubles, Integer, Strings oder Boolean Werte, wie \autoref{fig:lit_syntax} zeigt. In Strings ist es möglich besondere Zeichen zu escapen, zum Beispiel kann ein Zeilenumbruch, wie in anderen Programmiersprachen, mit \lstinline[style=MyMacroStyle]$"\n"$ oder ein Tab mit \lstinline[style=MyMacroStyle]$"\t"$, erzeugt werden.
      \begin{figure}[H]
        \centering
        \myInput{img/lit_syntax.tikz}
        \caption{Syntax von Literals.}
        \label{fig:lit_syntax}
      \end{figure}

      Abbildungen \ref{fig:scope_syntax}, \ref{fig:loop_scope_syntax} und \ref{fig:common_syntax} zeigen den Syntax von einem Scope. Scopes sind Bestandteile von Funktionen und Loops, wobei sich Loop Scopes von normalen Scopes nur darin unterscheiden, dass sie das \lstinline[style=MyMacroStyle]$break$ Keyword unterstützen. Alle Scopes -- abgesehen von Funktion Deklarationsscopes -- die auf ein Loop Scope folgen, sind automatisch Loop Scopes. Scopes verhalten sich wie C Scopes, was bedeutet, dass der Syntax \lstinline[style=MyMacroStyle]$var foo; {var foo;}$ richtig ist -- das erste \lstinline[style=MyMacroStyle]$foo$, wird von dem zweiten verdeckt.
      \begin{figure}[H]
        \centering
        \begin{minipage}{.45\textwidth}
          \vspace*{2.45em}
          \begin{figure}[H]
            \centering
            \myInputUnlimited{img/scope_syntax.tikz}
            \caption{Syntax vom Scope.}
            \label{fig:scope_syntax}
          \end{figure}
        \end{minipage}%
        \begin{minipage}{.45\textwidth}
          \begin{figure}[H]
            \centering
            \myInputUnlimited{img/loop_scope_syntax.tikz}
            \caption{Syntax vom Loop Scope.}
            \label{fig:loop_scope_syntax}
          \end{figure}
        \end{minipage}
      \end{figure}

      \begin{figure}[H]
        \centering
        \myInput{img/common_syntax.tikz}
        \caption{Syntax allgemeiner Strukturen.}
        \label{fig:common_syntax}
      \end{figure}


    %---------------------------------
    % Definitionen
    %---------------------------------
    \subsubsection{Definitionen}
    \label{sssec:Definitionen}
      Variablen können, wie in \autoref{fig:var_syntax} zu sehen ist, definiert werden: \lstinline[style=MyMacroStyle]$var foo;$. Um anschließend der Variablen einen Wert zuzuweisen, ist es unter anderem erlaubt, dies zu tun: \lstinline[style=MyMacroStyle]$var foo = fun();$ oder \lstinline[style=MyMacroStyle]$var foo = true == false;$.
      \begin{figure}[H]
        \centering
        \myInput{img/var_syntax.tikz}
        \caption{Syntax der Variablendeklaration.}
        \label{fig:var_syntax}
      \end{figure}

      Funktionen können über \lstinline[style=MyMacroStyle]$def fun(){...}$ definiert werden, was \autoref{fig:fun_syntax} zeigt. Um eine parametrisierte Funktion zu definieren, gibt man die Parameternamen, Komma getrennt, nach dem Funktionsnamen an: \lstinline[style=MyMacroStyle]$def fun(foo, bar){...}$.
  %TODO kein leerzeichen zwischen funktion und kalmmer
      Der Einstiegspunkt eines jeden Makros ist eine \lstinline[style=MyMacroStyle]$def main(){...}$ Funktion. Der Syntax ist der selbe wie bei den normalen Funktionen und erlaubt es daher auch Parameter anzugeben. Deswegen können die Makros aus anderen Makros, oder aus der C++ Ebene über einen äquivalenten Syntax mit Parametern aufgerufen werden.
      \begin{figure}[H]
        \centering
        \myInput{img/fun_syntax.tikz}
        \caption{Syntax der Funktionsdeklaration.}
        \label{fig:fun_syntax}
      \end{figure}

    %---------------------------------
    % Kontrollstrukturen
    %---------------------------------
    \subsubsection{Kontrollstrukturen}
    \label{sssec:Kontrollstrukturen}
      Die Syntax von \lstinline[style=MyMacroStyle]$if/else$ und \lstinline[style=MyMacroStyle]$do-/while$ aus den Abbildungen \ref{fig:if_syntax}, \ref{fig:while_syntax} und \ref{fig:do_while_syntax} sollten wie erwartet aussehen.
      \begin{figure}[H]
        \centering
        \myInput{img/if_syntax.tikz}
        \caption{Syntax von if.}
        \label{fig:if_syntax}
      \end{figure}

      \begin{figure}[H]
        \centering
        \myInput{img/while_syntax.tikz}
        \caption{Syntax von while.}
        \label{fig:while_syntax}
      \end{figure}

      \begin{figure}[H]
        \centering
        \myInput{img/do_while_syntax.tikz}
        \caption{Syntax von do-while.}
        \label{fig:do_while_syntax}
      \end{figure}


\myTodo{For Schleife wenn implementiert} % TODO
\myTodo{For-each Schleife wenn implementiert} % TODO

    %---------------------------------
    % Befehle
    %---------------------------------
    \subsubsection{Befehle}
    \label{sssec:Befehle}
      \autoref{fig:call_syntax} zeigt die Syntax, um eine definierte Funktion aufzurufen. \lstinline[style=MyMacroStyle]$fun(foo:gun(), bar:foo);$ weißt dem \lstinline[style=MyMacroStyle]$foo$ Parameter den Wert von \lstinline[style=MyMacroStyle]$gun()$ zu und dem Parameter \lstinline[style=MyMacroStyle]$bar$ wird der Wert von \lstinline[style=MyMacroStyle]$foo$ aus dem Scope zugewiesen.
      \begin{figure}[H]
        \centering
        \myInput{img/cal_syntax.tikz}
        \caption{Syntax von Funktionsaufrufen.}
        \label{fig:call_syntax}
      \end{figure}

      Die Operator Syntax aus \autoref{fig:op_syntax} sollte, ähnlich wie die \lstinline[style=MyMacroStyle]$return$ Syntax, nicht allzu überraschend sein. Geklammerte Ausdrücke werden zuerst vollständig ausgewertet, bevor der Operator angewendet wird. Das heißt, dass \lstinline[style=MyMacroStyle]$(a || b) && c$ folgender Weise interpretiert wird. \lstinline[style=MyMacroStyle]$a$ oder \lstinline[style=MyMacroStyle]$b$ wird zuerst ausgewertet und deren Ergebnis wird mit \lstinline[style=MyMacroStyle]$c$ genutzt. Entgegen dessen wird bei \lstinline[style=MyMacroStyle]$a || b && c$ zuerst \lstinline[style=MyMacroStyle]$a$, und dann \lstinline[style=MyMacroStyle]$b$ und \lstinline[style=MyMacroStyle]$c$ ausgewertet.
      \begin{figure}[H]
        \centering
        \myInput{img/op_syntax.tikz}
        \caption{Syntax von Operatoren.}
        \label{fig:op_syntax}
      \end{figure}
  \myTodo{Wenn implementiert ===, !== und NoneType} % TODO
  %---------------------------------
  % Grundarchitektur
  %---------------------------------
  \subsection{Grundarchitektur}
  \label{ssec:Grundarchitektur}
    Das Ziel der folgenden Architektur ist,die Funktionalität, die in \autoref{fig:abstract_goal_uml} zu sehen ist, zu ermöglichen.

    \begin{figure}[H]
      \centering
      \myInput{img/abstract_goal_uml.tikz}
      \caption{Abstraktes Ziel der resultierenden Architektur.}
      \label{fig:abstract_goal_uml}
    \end{figure}
    \myMinin{Executable} ist das Interface, welches alle \myMinin{Command}s aus dem Command-Pattern implementieren. Eine weitere Implementation dieses Interfaces ist -- nicht zu verwechseln mit Ma\emph{k}ros -- die \myMinin{Macro} Klasse. Diese erlaubt es Entwicklern ein Makro auszuführen. Im weiteren Verlauf dieser Arbeit geht es hauptsächlich um die Ma\emph{k}ros, da sich die Implementation der \myMinin{Macro} Klasse am Ende aus den Teillösungen ergibt.
\myTodo{Am Ende erwähnen /\& referenzieren.} % TODO


    Da das komplette UML Diagramm sehr unübersichtlich ist und nicht auf ein A2 Blatt passt, sind die folgenden Diagramme Ausschnitte aus dem Kompletten und spiegeln es zusammen wieder.

    \autoref{fig:top_pack_uml} zeigt die Abhängigkeiten der Pakete (namespaces) in dem Modul, welches die Makro Funktionalität anbieten soll. Das \myMinin{ast} Paket beinhaltet alle Klassen, die den abstrakten Syntaxbaum ausmachen und von dem Parser und dem Interpreter verwendet werden. In dem \myMinin{parser} Paket befinden sich der Tokenizer und Parser. In dem \myMinin{token} Paket befindet sich die \myMinin{Token} Klasse, da diese in kein anderes Paket gehört.
    \begin{figure}[H]
      \centering
      \myInput{img/top_pack_uml.tikz}
      \caption{Abhängigkeiten von dem Makro Modul.}
      \label{fig:top_pack_uml}
    \end{figure}

    \subsubsection{Token, Tokenizer und Parser}
    \label{sssec:Token, Tokenizer und Parser}
      Der \myMinin{Parser} aus \autoref{fig:parser_pack_uml} bedient sich dem \myMinin{Tokenizer}, um eine \myMinin{TokenList} von \myMinin{Token}s zu bekommen. Diese \myMinin{TokenList} kann er dann parsen, bzw. in einen abstrakten Syntaxbaum umwandeln.
      \begin{figure}[H]
        \centering
        \myInput{img/parser_pack_uml.tikz}
        \caption{Parser Paket UML}
        \label{fig:parser_pack_uml}
      \end{figure}

      Der \myMinin{Tokenizer} wandelt den String, der das Makro beschreibt, in eine Reihenfolge von \myMinin{Token}s um. Tokens sind alle Zeichen, die von whitespace (\lstinline[language=MyRegex]$\s*$) getrennt sind, die nicht den Anforderungen als Bezeichner genügen (\lstinline[language=MyRegex]$[^a-zA-Z0-9_]$, siehe \autoref{fig:id_syntax}), die durch einen Punkt eine
\myQuestion{Fachwort?} % TODO
      Kommazahl bilden (\lstinline[language=MyRegex]$\d*\.\d+$) oder einen String darstellen (\lstinline[language=MyRegex]$".*?"$\footnote{
        Dieser Regex funktioniert nur für einfache Varianten (kein escapen) von Strings und dient deswegen nur der Veranschaulichung.
      }). Der \myMinin{Tokenizer} ist nicht für das Lexen verantwortlich -- dies wird von dem Parser übernommen.

      \myMinin{Token}s beinhalten die Zeile sowie Spalte als Zahl, und den gesamten Quelltext aus der Zeile, aus der das Token entstanden ist. Dies ist von Nöten, um später gute Fehlermeldungen zu erzeugen, mit denen ein Benutzer schnell weiß, wo er nach dem Fehler suchen muss. Des weiteren enthält die Klasse einen String, der den Teil des Makros enthält, den die Instanz darstellen soll.

      Der \myMinin{Parser} ist dafür verantwortlich, dass die Liste von Tokens in einen AST umgewandelt wird. Es gibt drei Hauptarten von Parsern\autocite[S.77\,f.]{eirund2013formale} \emph{LL}\footnote{
        LL Parser arbeiten `vorwärts', links nach rechts und probieren auf der linken Seite, des gelesenen bzw. teils geparsten Quelltextes zu reduzieren. Man gelangt am Ende, am Ende des Baumes an.
      }, \emph{LR}\footnote{
        LR Parser arbeiten `rückwärts', links nach rechts und probieren auf der rechten Seite, des ungelesenen Quelltextes zu reduzieren um Terminals auf der linken Seite zu sammeln. Man gelangt am Ende zu dem Anfang des Baumes.\autocite{cs143-stanford}
      } und \emph{recursive descent}\footnote{
        Recursive descent Parser bauen durch Funktionsaufrufe einen Stack auf, der den Zweigen des Baumes gleicht.
      }.
\myQuestion{Ist es ok, dass ich die Parser nur kurz in den Fußnoten erklärt habe (Grundlagen Kapitel?)} % TODO
      LL und LR Parser sind meistens schneller als recursive descent, da sie mit Hilfe von Zustandstabellen arbeiten, die meist aus der Backus-Naur-Form heraus entstehen. Der Nachteil bei den beiden ist, dass LL, und umso mehr LR Parser, schwer zu warten sind, weswegen meist Parser-Generatoren genutzt werden, um den Quelltext für den Parser zu generieren. Außerdem sind die Fehlermeldungen, die LL und LR Parser erzeugen meistens schlechter als die, die recursive descent Parser von Natur aus mit sich bringen\autocite{scott2010gll}. Da die Wartbarkeit und Fehlermeldungen wichtige Punkte auf der Anforderungsliste sind, wurde sich für einen recursive descent Parser entschieden. Zudem sind die gelungenen Parser von \myFnurl{Clang}{http://clang.llvm.org/features.html} und \myFnurl{GCC}{https://gcc.gnu.org/wiki/New_C_Parser} ein gutes Beispiel und Vorbild, was mit recursive descent Parsern erreicht werden kann.

      Beim Parsen müssen die Literals umgewandelt werden -- aus dem Token \myMinin{"1.01"} muss der Double \myMinin{1.01} werden, escapete Symbole in einm String müssen umgewandelt werden (z.B.: \myMinin{"t\tt"}$\rightarrow$\myMinin{"t  t"}). Die Operatoren müssen in der richtigen Reihenfolge zusammengestellt werden (bei \myMinin{a || b && c} muss \myMinin{a} zuerst ausgewertet werden und dann \myMinin{b && c}). Und Variablen Deklarationen mit Wertzuweisung müssen in zwei Schritte aufgeteilt werden (erst deklarieren und dann der Variablen den Wert zuweisen\footnote{
        Dies ist valider C Code: \myMinin{const int foo = foo + 1;}
      }).


    \subsubsection{Abstrakter Syntaxbaum}
    \label{sssec:Abstrakter Syntaxbaum}
      Wie \autoref{fig:AST_uml} zeigt, sind für alle Keywords\footnote{
        Es wurden einigele Klassen hinter allgemeinen Begriffen -- wie \myMinin{Loop} -- versteckt, um etwas Übersicht zu bewahren.
      } Klassen von Nöten. Alle Klassen erben von der \myMinin{AST} Klasse, welche ein \myMinin{Token} besitzt, welches die spezielle Klasse beschreibt. Da die Token alle Informationen  über den Makro Quelltext haben und es sich bei der resultierenden Datenstruktur um einen Baum handelt, ist auch der Interpreter in der Lage informative Fehlermeldungen zu generieren.
      \begin{figure}[H]
        \centering
        \myInput{img/AST_uml.tikz}
        \caption{Stammbaum der AST Klassen.}
        \label{fig:AST_uml}
      \end{figure}

      \autoref{fig:Scope_uml} zeigt die \myMinin{Scope} Klasse, diese Klasse kann beliebig viele andere \myMinin{AST} Instanzen aufnehmen.  Da das \myMinin{Scope} Instanzen von allen \myMinin{AST} Klassen aufnehmen kann, und einige Klassen wiederum ein \myMinin{Scope} besitzen, kommt es hier zu einem dependency circle. Da das \myMinin{Scope} eine der meist benutzten Klassen ist, liegt die Auflösung des dependency circles bei den anderen Klassen.
      \begin{figure}[H]
        \centering
        \myInput{img/Scope_uml.tikz}
        \caption{Verbindungen vom Scope.}
        \label{fig:Scope_uml}
      \end{figure}

      \myMinin{Loop}, \myMinin{Function} und \myMinin{If} müssen den dependency circle mit \myMinin{Scope} auflösen. In \autoref{fig:Condition_uml} sind die restlichen Abhängigkeiten zwischen den \myMinin{AST} Klassen zu sehen.
      \begin{figure}[H]
        \centering
        \myInput{img/Condition_uml.tikz}
        \caption{Abhängigkeiten der AST Klassen}
        \label{fig:Condition_uml}
      \end{figure}

    \subsubsection{Interpreter}
    \label{sssec:Interpreter}
      Der \myMinin{Interpreter} nutzt den \myMinin{parser::Parser}, um einen \myMinin{ast::Scope} zu erzeugen. Diesen Baum interpretiert der \myMinin{Interpreter} in mehreren Schritten. Als erstes werden alle Funktionsdefinitionen interpretiert -- dies sorgt dafür, dass keine Definitionsreihenfolge eingehalten werden muss. Im zweiten Schritt werden die globalen Variablen definiert und initialisiert. Der Letzte Schritt ist die Abarbeitung der Einstiegsfunktion mit allen Deklarationen und Funktionsaufrufen. Das `root' \myMinin{ast::Scope} wird normal behandelt -- das heißt, dass Funktionsaufrufe vor der \myMinin{main()} Methode erlaubt sind.
      \begin{figure}[H]
        \centering
        \myInput{img/interpreter_pack_uml.tikz}
        \caption{Interpreter Beziehungen.}
        \label{fig:interpreter_pack_uml}
      \end{figure}

      Wenn der \myMinin{Interpreter} einen Funktionsaufruf nicht einer definierten Funktion zuweisen kann, wird der \myMinin{ExecutableProvider} nach einer passenden \myMinin{Executable} gefragt -- siehe \autoref{fig:interpreter_pack_uml}. Bei Operatoraufrufen wird der \myMinin{OperatorProvider} nach einem passenden \myMinin{Operator} gefragt. Durch den \myMinin{OperatorProvider} als Mittelmann, ist es möglich Operatoren auf spezielle Objekte anzuwenden, die über die Datentypen der Literals hinausgehen. Da die Parameternamen zu der Funktionssignatur gehören, ist es möglich mehrere Funktionen mit dem selben Namen anzulegen -- \myMinin{fun()} und \myMinin{fun(foo)} stehen also nicht in Konflikt. Das zuweisen von Parametern verhält sich ähnlich wie bei JavaScript -- die Parameter werden als Referenz übergeben und nicht kopiert. Wenn dem Parameter ein neuer Wert zugewiesen wird, verändert sich der Wert aus dem aufrufendem Scope nicht. Wenn dei aufzurufende Funktion allerdings von dem \myMinin{ExecutableProvider} kommt, werden die Parameter kopiert -- dies ist durch die C++ Ebene vorgegeben und wird normalerweise durch Pointer beschleunigt.

      Während der Ausführung übernimmt der \myMinin{Stack} die Verwaltung der definierten Funktionen und Variablen sowie deren Werte. Bei jedem \myMinin{Scope}, wird der \myMinin{Stack} um eine Instanz von sich selber erweitert.

  %---------------------------------
  % Level 2 -- Logik / primitive Rückgabewerte
  %---------------------------------
  \subsection{Level 2 -- Logik / primitive Rückgabewerte}
  \label{ssec:Level 2 -- Logik / primitive Rückgabewerte}
\myQuestion{Bei diesen beiden Kapiteln weiß ich nicht so ganz worauf ich eingehen soll -- abgesehen davon das die Namen nicht zur Realisierung passen.} % TODO
                                                                                             %
  %---------------------------------
  % Level 3 -- Komplexe Rückgabewerte
  %---------------------------------
  \subsection{Level 3 -- Komplexe Rückgabewerte}
  \label{ssec:Level 3 -- Komplexe Rückgabewerte}

%---------------------------------
% Exemplarische Realisierung
%---------------------------------
\section{Exemplarische Realisierung}
\label{sec:Exemplarische Realisierung}
  % TODO explain via example, split page in two right data (string ->tokenlist->ast->interpreter) left explanation
  % TODO mention test driven
\myQuestion{Ich hätte hier vor an Hand eines Beispieles die ``Knackpunkte'' der einzelnen Klassen zu erklären, bzw. den Ablauf wieder zu spiegeln (String->Tokens->Parser/AST->Interpreter). Hört sich das gut an? (Code wäre getrimmt oder Pseudo-Code)}% TODO

  \begin{myCodeEnv}
    \centering
    \begin{minipage}{.9\textwidth}
      \lstinputlisting[style=MyMacroStyle]{code/ex_macro.txt}
    \end{minipage}
    \caption{Interpreter Beziehungen.}
    \label{fig:ex_macro}
  \end{myCodeEnv}


  \columnratio{0.6}
  \columnsep25pt
  \begin{paracol}{2}[\subsection{Tokenizer}]
    %---------------------------------
    % Tokenizer
    %---------------------------------
    \label{ssec:Tokenizer}

      \textcolor{red}{Erklärung}

      Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum
    \switchcolumn
      \textcolor{red}{Beispiel}

      \begin{myCodeEnv}
        \lstinputlisting[lastline=20]{code/ex_tok.txt}
        \caption{Tokenized Makro}
        \label{fig:ex_tok}
      \end{myCodeEnv}


    %---------------------------------
    % Parser
    %---------------------------------
    \switchcolumn*[\subsection{Parser}]
    \label{ssec:Parser}

    \switchcolumn

      \begin{myCodeEnv}
        \lstinputlisting[lastline=20]{code/ex_ast.txt}
        \caption{Geparsed Makro}
        \label{fig:ex_ast}
      \end{myCodeEnv}


    %---------------------------------
    % Interpreterex_tok
    %---------------------------------
    \switchcolumn*[\subsection{Interpreter}]
    \label{ssec:Interpreter}
    \switchcolumn

  \end{paracol}

  %---------------------------------
  % Makro
  %---------------------------------
  \subsection{Makro}
  \label{ssec:Makro}

%---------------------------------
% Evaluation
%---------------------------------
\section{Evaluation}
\label{sec:Evaluation}
  % TODO compiler bugs
  % TODO ChaiScript http://chaiscript.com/ --- May 25, 2009 23fc75c  --- schlechte Fehlermeldungen
%---------------------------------
% Zusammenfassung und Ausblick
%---------------------------------
\section{Zusammenfassung und Ausblick}
\label{sec:Zusammenfassung und Ausblick}

  %---------------------------------
  % Literatur
  %---------------------------------
  \subsection{Ausblick}
  \label{sec:Ausblick}
    \begin{itemize}
      \item Ausnutzung des ASTs\\
        Sofern alle Funktionen die ausgeführt werden sollen als thread-safe gekennzeichnet sind, kann das gesamte Macro parallel ausgeführt werden.
      \item Debugger / Stepping\\
        Es könnte ein Interface angeboten werde, mit dem man durch die Ausführung eines Macros Schritt für Schritt gehen kann.
      \item C++17 std::string\_view\\
        for better parsing performance and less memory consumption.
    \end{itemize}


%---------------------------------
% Literatur
%---------------------------------
\section{Literatur}
\label{sec:Literatur}
  \nocite{*} % TODO remove
  \printbibliography[heading=none]

%---------------------------------
% Anhänge
%---------------------------------
\section{Anhänge}
\label{sec:Anhänge}

\end{document}
