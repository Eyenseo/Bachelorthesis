%---------------------------------
% Preamble
%---------------------------------
\input{preamble.tex}

%---------------------------------
% Document start
%---------------------------------
\begin{document}

\listoftodos

%---------------------------------
% Titlepage
%---------------------------------
\input{titlepage.tex}

%---------------------------------
% table of contents
%---------------------------------
\microtypesetup{protrusion=false} % disables protrusion locally in the document
\tableofcontents
\microtypesetup{protrusion=true} % disables protrusion locally in the document
\newpage

%---------------------------------
% Allgemeines
%---------------------------------
\addsec{Allgemeines}
\label{sec:Allgemeines}
  %---------------------------------
  % Eidesstattliche Erklärung
  %---------------------------------
  \subsection*{Eidesstattliche Erklärung}
  \addcontentsline{toc}{subsection}{Eidesstattliche Erklärung}
  \label{ssec:Eidesstattliche Erklärung}
    Ich, \MetaAuthor, Matrikel-Nr. \MetaStudentNumber, versichere hiermit, dass ich meine Bachelorarbeit mit dem Thema
    \begin{center}
      \vspace*{-1em}
      \textit{\MetaTitle}
      \vspace*{-1em}
    \end{center}
    selbständig verfasst und keine anderen als die angegebenen Quellen und Hilfsmittel benutzt habe, wobei ich alle wörtlichen und sinngemäßen Zitate als solche gekennzeichnet habe. Die Arbeit wurde bisher keiner anderen Prüfungsbehörde vorgelegt und auch nicht veröffentlicht.

    \vspace*{3em}
    \begin{tabular}{@{}rc}
      \raisebox{.2em}{Bremen, den \today}
        &\makebox[4cm]{\hrulefill}\\
      {}
        &\MetaAuthor
    \end{tabular}

\pagebreak

  %---------------------------------
  % Danksagung
  %---------------------------------
  \subsection*{Danksagung}
  \addcontentsline{toc}{subsection}{Danksagung}
  \label{ssec:Danksagung}
\myTodo{Danke an Mutter, Vater und alle Profs} % TODO

    % \begin{figure}[H]
    %   \centering
    %   \begin{tikzpicture}[%
    %     spy using outlines={%
    %       circle,%
    %       Cornsilk,%
    %       magnification=2,%
    %       size=3.5cm,%
    %       connect spies%
    %     }%
    %   ]
    %     \node{
    %       \pgfimage[%
    %         interpolate=true,%
    %         width=.8\linewidth%
    %       ]{%
    %         img/bb%
    %       }
    %     };
    %     \spy on (.1,-.3) in node [left] at (-2,1.9);
    %   \end{tikzpicture}

    %   \caption{\textit{``Das soll meine Zukunft sein?''}}
    % \end{figure}

%---------------------------------
% Einleitung
%---------------------------------
\section{Einleitung}
\label{sec:Einleitung}
  Die Einführung von Automatisierung in ein Softwaresystem ist vergleichbar mit den Maschinen, die in der industrielle Revolution auftauchten. Anstelle, dass Menschen arbeiten müssen, um ein gewünschtes Ergebnis zu bekommen, drücken sie auf einen Knopf, und ein anderes System nimmt ihnen die aufwändige Arbeit ab. Dies führt dazu, dass Produkte schneller, mit weniger Arbeitsaufwand erstellt werden können. Zudem ist die entstehende Qualität immer auf einem gleichbleibenden Level und hängt nicht von dem Befinden der Arbeiter ab.

  Die P3-group arbeitet mit Airbus, um Lösungen für den Flugzeugbau zu entwickeln. Dieser Markt ist hart umkämpft, wodurch minimale Gewinne einen großen Unterschied machen können. Ein Feld, welches seit Jahren immer weiter durch wissenschaftliche und technische Durchbrüche optimiert wird, sind die menschlichen Ressourcen. Automatisierung sorgt dafür, dass sich wiederholende Arbeitsabläufe -- aus der Sicht des Nutzers -- zu einem einzigen Schritt werden und so Zeit sparen.

  Makros sind die Fließbänder der digitalen Welt, und diese Arbeit beschäftigt sich mit der Entwicklung eines Makro Systems bzw. Sprache.

  Makros werden durch die Verbindung kleinerer Bausteine (Anweisungen) erstellt. Diese können andere Makros oder Anweisungen, die die Anwendungsumgebung bereitstellt, sein. Dies ist mit einem Fließband in der Autoindustrie zu vergleichen. Jede Station ist genau für eine Aufgabe zuständig und kümmert sich um nichts anderes.

  Die Makrosprache ist ein Baukasten, mit dem Makros erstellt -- ``Fließbänder'' für spezielle Aufgaben erzeugt -- werden können.

  %---------------------------------
  % Problemfeld
  %---------------------------------
  \subsection{Problemfeld}
  \label{ssec:Problemfeld}
    Softwaresysteme haben oft das Problem, dass sie mit einigen zentralen Features anfangen, die fest definiert werden (sollten), bevor ein Vertrag geschlossen wird. Für weitere Funktionalität, die über die Vereinbarungen im Vertrag hinausgehen, muss der Vertrag erweitert werden. Wenn der Vertrag erfüllt ist, und im Anschluss weitere Wünsche aufkommen, muss ein weiterer Vertrag aufgesetzt werden und die vorher gelieferte Software muss angepasst, gegebenenfalls erweitert werden. Dies kann zur Folge haben, dass große Teile der Software umgeschrieben werden müssen, oder sogar, dass die Architektur der gesamten Anwendung verändert werden muss.

    Wenn frühzeitig ein Makrosystem/-sprache und ein entsprechendes Erweiterungskonzept für Module bzw. Plugins eingeführt wird, ist die Wahrscheinlichkeit, dass der Kern der Applikation für Erweiterungen angefasst werden muss, wesentlich geringer. Durch diese Kombination kann einfach ein weiteres Modul geladen werden, welches die neuen Grundbausteine der Applikation hinzufügt. Diese können dann in einem neuen, oder angepassten Makro genutzt werden, um den Wunsch der Kunden zu erfüllen. Im Falle, dass es keiner neuen Grundbausteine bedarf, reicht es sogar, nur ein Makro zu liefern. Die Vorteile dieser Methode sind, dass -- wenn man davon ausgeht, dass die benutzen Makros und Grundbausteine fehlerfrei durch ausreichendes Testen der Software sind -- keine neuen Bugs in den Kern der Software eingeführt werden können und somit immens zu der Stabilität der Software beigetragen wird. Ein weiterer Vorteil ist, dass die Makros mit wesentlich weniger Aufwand entwickelt werden können, weil sie sich auf einem höheren Level befinden. Für Kunden ist eine nutzbare Makrosprache auch interessant, weil sie zum Teil, durch das hausinterne Personal Anforderungen an die Software realisieren können, ohne den langen Weg über eine Firma zu gehen. Dies bedeutet auch, dass die Software eine bessere Chance hat, die Zeit zu überdauern.

  %---------------------------------
  % Ziele der Arbeit
  %---------------------------------
  \subsection{Ziele der Arbeit}
  \label{ssec:Ziele der Arbeit}
    Die Ziele der Arbeit sind es ein Makrosystem zu entwickeln, welches \ldots
    \begin{itemize}
      \item auf keinem festen \emph{Application Programming Interface (API)} aufbaut.

        Ein Feature der bestehenden Software ist es, dass sie durch \emph{Module}\footnote{
          Bibliotheken, die zur Laufzeit -- nach den dynamischen Bibliotheken --  nachgeladen werden können, um die Funktionalität der Applikation zu erweitern.
        } erweitert werden kann. Eines dieser Module wird das Makrosystem sein, welchen in dieser Arbeit entwickelt wird. Durch diese Modularität, gibt es kein festest Interface.

      \item nicht nur Anweisungen abarbeitet.

        Um eine große Bandbreite an Automatisierungsmöglichkeiten anbieten zu können, bedarf es logischer Ausdrücke, die bedingte Anweisungen erlauben. Ebenso ist es wichtig, dass man entscheiden kann, wie oft etwas ausgeführt werden soll, sprich Schleifen. Und die Makros sollen sowohl von dem Programm, als auch von anderen Makros Parameter übergeben bekommen können.

      \item nicht mehr kann als es können muss.

        Je mächtiger ein System ist, desto komplexer ist es. Zudem sind Features nur etwas wert, wenn sie gewinnbringend verkauft werden können.

      \item wartbar ist.

        Die Implementierung sollte keine komplexen Bestandteile besitzen, über die nicht geschlussfolgert werden kann.

      \item benutzerfreundlich ist.

        Die Lösung soll benutzerfreundlich sein, das heißt, dass Fehlermeldungen dem Nutzer schnell zu seinem Fehler führen und keine false positives enthalte.
    \end{itemize}

  %---------------------------------
  % Hintergründe und Entstehung des Themas
  %---------------------------------
  \subsection{Hintergründe und Entstehung des Themas}
  \label{ssec:Hintergründe und Entstehung des Themas}
    Die P3-group ist daran interessiert, dass sie ihren Kunden Lösungen schnell und in hoher Qualität anbieten kann. Um dies zu erreichen arbeiten sie daran, dass alle Softwaresysteme, die von ihnen angeboten werden, Automatisierung über Makros unterstützen. Wirtschaftlich rentieren sich die Makros dadurch, dass sie von den Firmen gemietet und nicht nur einmal verkauft werden. Zum Beispiel, werden alle Flugzeugteile ausgewählt und dann deren Gewicht ermittelt. Ein anderes Mal sollen nur spezielle Teile aus einem bestimmten Werkstoff zusammen gezählt und deren Preis ermittelt werden. Anstelle, dass hier eine sehr komplexe Suchfunktion entwickelt wurde, können hier zwei Makros zum Einsatz kommen, die jeweils eine Aufgabe erfüllen und somit für den Benutzer sicher zu handhaben sind. Die Komplexität der Software wurde durch das zweite Makro nicht sonderlich beeinflusst, da dieses intern auf Funktionalität zurückgreifen kann, die schon vom ersten genutzt wird.

  %---------------------------------
  % Struktur der Arbeit, wesentliche Inhalte der Kapitel
  %---------------------------------
  \subsection{Struktur der Arbeit, wesentliche Inhalte der Kapitel}
  \label{ssec:Struktur der Arbeit, wesentliche Inhalte der Kapitel}
    Die Arbeit ist in drei wesentliche Kapitel aufgeteilt, \myNamedRef{sec:Anforderungsanalyse}, \myNamedRef{sec:Konzeption} und \myNamedRef{sec:Exemplarische Realisierung}. Der Fokus dieser Kapitel geht vom Theoretischen zum Praktischen. Innerlich folgen die Kapitel den Arbeitsabläufen, die zur Entwicklung des Makrosystems genutzt wurden. Zudem gibt es dies \hyperref[sec:Einleitung]{Einleitungskapitel}, eine \nameref{sec:Evaluation} und einen \nameref{ssec:Ausblick}.

    In dem Kapitel \nameref{sec:Anforderungsanalyse} werden die Anforderungen, sowie deren Probleme analysiert. Das Kapitel \nameref{sec:Konzeption} beschäftigt sich mit den Lösungen für die Anforderungen sowie der Probleme, die im vorherigen Kapitel gefunden wurden. Unter anderem beinhaltet das Kapitel die Software Architektur, sowie den Syntax für die Makrosprache. In dem Kapitel \nameref{sec:Exemplarische Realisierung} wird auf entscheidende Punkte der exemplarischen Realisierung eingegangen.

%---------------------------------
% Anforderungsanalyse
%---------------------------------
\section{An\-for\-de\-rungs\-ana\-ly\-se}
\label{sec:Anforderungsanalyse}
  Dieses Kapitel beschäftigt sich mit dem Problemfeld und den Anforderungen an die entstehende Lösung. In der \nameref{ssec:Diskussion des Problemfeldes} geht es vor allem darum, das Problemfeld zu analysieren und die Unterprobleme ausfindig zu machen, um abstrakte Lösungsansätze für diese zu entwickeln. Bei den \nameref{ssec:Anforderungen an die angestrebte Lösung} ist das Ziel die Anforderungen, die die Problemlösung erfüllen sollte, zu definieren.

  %---------------------------------
  % Diskussion des Problemfeldes
  %---------------------------------
  \subsection{Diskussion des Problemfeldes}
  \label{ssec:Diskussion des Problemfeldes}
    Ein Makrosystem ist eine Komponente eines Softwaresystems, welche es erlaubt, die Software über eine Reihenfolge von Zeichen so zu steuern, als ob ein Mensch die Applikation bedient hätte.

    %---------------------------------
    % Was ist ein Makrosystem?
    %---------------------------------
    \subsubsection{Was ist ein Makrosystem?}
    \label{sssec:Was ist ein Makrosystem?}
      Die Funktionalität eines Makrosystems ist vergleichbar mit Programmiersprachen -- dort wird, durch eine Ansammlung von Zeichen, der Computer veranlasst, eine bestimmte Abfolge von Hardwareanweisungen auszuführen. Der Unterschied von einem Makrosystem zu zum Beispiel C ist, dass bei einem Makrosystem der Befehlssatz durch die Anwendung vorgegeben wird, wohingegen der Befehlssatz von C durch die Hardware vorgegeben wird und nicht durch eine weitere Ebene übersetzt werden muss (C ist eine native Programmiersprache). Somit ist ein Makrosystem eher mit einer Sprache zu vergleichen, die sich einer \emph{virtuellen Maschine} (VM) bedient -- wie Java -- als mit C.

      Bei Java gibt die VM den Befehlssatz vor und muss bei der Ausführung des Programms diese Befehle, in die entsprechenden Hardwarebefehle, übersetzen (write once, run anywhere). Ähnlich verhält es sich mit dem Makrosystem, das Makro nutzt die vorhandenen Befehle der Applikation, um einen Arbeitsvorgang zu automatisieren. Da die Befehle jedoch nur als Zeichenketten vorliegen, müssen diese zu den richtigen Funktionen übersetzt werden. Der Befehlssatz dieses Makrosystems kommt aus dem vorhandenen System, da dort das Command-Pattern \autocite[S.263]{Gamma:1995:DPE:186897} eingesetzt wird und somit ein ideales Interface für Automatisierung bietet. \autoref{sssec:Das vorhandene System} geht auf die Architektur des vorhandenen Systems ein, die für diese Arbeit wichtig ist.

      Für alle Programmiersprachen ist es von Nöten, die Reihenfolge von Zeichen, in sinnvolle Stücke zu zerteilen -- dies übernimmt ein Tokenizer, siehe \autoref{fig:abstractarch}. Meist wird dieser in den Parser \autocite[S.46]{eirund2013formale} integriert, um die Stücke der Zeichenkette (String) in ein Format zu überführen, die vom Interpreter unterstützt werden. Das Format ist meist ein \emph{abstrakter Syntaxbaum}\footnote{
        \myMinin{Abstract syntax tree} ist eine digitale Darstellung einer Programmiersprache.
      } (AST), welcher den String eindeutig repräsentiert. Einer Typen aus dem AST nennt sich Literal. Literals sind Daten, die der Programmierer durch Quelltext erstellen kann (zum Beispiel ist \myMinin{"foo"} ein String und \myMinin{1.1} ist eine Dezimalzahl). Literals müssen aus dem Format des Quelltextes in die echte Datenstruktur verwandelt werden, was ein Lexer übernimmt. Lexer sind, wie Tokenizer, meist ein Teil des Parsers. Der Interpreter arbeitet dann nur noch mit dem AST, welcher vorgibt, welche Befehle der Interpreter ausführen muss, um das, als String angegebene, Programm auszuführen. Ein Interpreter arbeitet die AST Elemente sequentiell ab, das heißt, dass ein Interpreter \myMinin{a} ausführt ohne zu `wissen', dass er im Anschluss \myMinin{b} ausführen wird.
      \begin{figure}[H]
        \centering
        \myInput{img/abstraktarch.tikz}
        \caption{Abstraktes Ziel der resultierenden Architektur}
        \label{fig:abstractarch}
      \end{figure}
      Anstelle eines Interpreters, wird bei C ein Compiler genutzt, der, vor der Ausführung, das gesamte Programm in Maschinencode verwandelt. Dies hat den Vorteil, dass während der Ausführung nur das Programm ausgeführt wird und nicht noch eine weitere Komponente (Interpreter) die CPU in Anspruch nimmt. Ein Kompromiss zwischen beiden Welten ist ein \emph{just in time compiler} (JIT), dieser probiert das Beste aus beiden Welten, die Dynamik vom Interpretieren und die Geschwindigkeit von kompilierten Programmen, zu vereinen.

    %---------------------------------
    % Parser
    %---------------------------------
    \subsubsection{Parser}
    \label{sssec:Parser}
      Einer der zeitaufwändigsten Schritte ist es, die Quelltext Zeichenkette in einen AST umzuwandeln. Dieser Schritt wird vom Parser übernommen, von dem es drei Hauptgruppen gibt.
      \begin{itemize}
        \item Links nach rechts, links Auflösung (LL) \autocite[S.77\,f.]{eirund2013formale}\\
          LL Parser arbeiten `vorwärts', links nach rechts und probieren auf der linken Seite, des gelesenen (teils geparsten Quelltextes) zu reduzieren. Man gelangt zum Schluss, am Ende des Baumes an.
        \item Links nach rechts, rechts Auflösung (LR) \autocite[S.77\,f.]{eirund2013formale}\\
          LR Parser arbeiten `rückwärts', links nach rechts und probieren auf der rechten Seite, des ungelesenen Quelltextes zu reduzieren um Terminals auf der linken Seite zu sammeln. Man gelangt zum Schluss am Anfang des Baumes an. \autocite{cs143-stanford}
        \item Rekursiv Absteigend (recursive descent)\\
          Recursive descent Parser arbeiten wie LR Parser `rückwärts' und gelangen am Ende auch am Anfang des Baumes an. Im Gegensatz zu LL und LR Parsern arbeiten sie nicht mit Zustandstabellen sondern mit Rekursion. Für jedes Konstrukt, welches geparst werden soll, gibt es eine Methode. In dieser werden all die Methoden aufgerufen, die ein Element produzieren, welches sich in dem der äußeren Methode befinden darf.
      \end{itemize}

    %---------------------------------
    % Das vorhandene System
    %---------------------------------
    \subsubsection{Das vorhandene System}
    \label{sssec:Das vorhandene System}
      Das vorhandene Softwaresystem ist eine C++ Anwendung, die mit Hilfe von Modulen ihre Funktionalität erweitern kann. Ein Teil des zentralen Herzstückes ist eine Implementierung des Command-Patterns, siehe \autoref{fig:commanduml}.

      Der \myMinin{Receiver} stellt alle Objekte dar, die das \myMinin{ConcreteCommand} braucht, um seine Aufgabe zu erfüllen und ist -- so wie der \myMinin{Client}, der die Objekte darstellt, die ein \myMinin{Command} ausführen -- nicht Teil der Architektur. \myMinin{Client}s sind über den \myMinin{CommandProvider} in der Lage einen \myMinin{Invoker} zu bekommen, der ein konkretes \myMinin{Command} wrapped. Der \myMinin{Invoker} bekommt bei der Erzeugung über den Konstruktor den momentanen \myMinin{HistoryStack}. Wenn der \myMinin{Invoker} durch einen Aufruf aus einem \myMinin{Command} (auf den \myMinin{CommandProvider}) entstanden ist, ist es der \myMinin{HistoryStack} des \myMinin{Command}s. Ansonsten ist es der \myMinin{HistoryStack} des \myMinin{CommandProvider}s. Durch den \myMinin{HistoryStack} ist es möglich die Veränderungen von ausgeführten \myMinin{Command}s rückgängig zu machen oder wiederherzustellen. Dies wird zum Beispiel von dem \myMinin{Invoker} genutzt, wenn das aufgerufene \myMinin{Command} einen Fehler verursacht. An dem \myMinin{CommandProvider} können sich alle \myMinin{Command}s registrieren, die in anderen Teilen der Anwendung genutzt werden können.

      \begin{figure}[H]
        \centering
        \myInput{img/commanduml.tikz}
        \caption{Abstrakte Command-PatterImplementation}
        \label{fig:commanduml}
      \end{figure}

      Da C++ keine Reflexion \autocites{vinoski2005time}{ferber1989computational} unterstützt, ist die Signatur, der \myMinin{any execute(map<string, any> arguments)} Methode, ein wichtiger Punkt der Architektur. Durch den \myTIn$any$ \autocite{cpp-fundamentals} Typ, in der Implementation des Command-Patterns, wurde die fehlende Reflektion umgangen\footnote{
         Diese Veränderung ist als Vorbereitung auf die Bachelorarbeit entstanden, da diese Anpassung den Zeitrahmen der Bachelorarbeit überschritten hätte.
      }. \myMinin{any} ist in der Lage, jeglichen Typ aufzunehmen und typsicher\footnote{
        Typsicher bedeutet das ein \myMinin{int} nicht zu einem \myMinin{char} gecastet werden kann -- es bedeutet nicht, dass \myMinin{any} implizit zu \myMinin{int} gecastet wird -- es ist also mit einem \myMinin{void *} zu vergleichen.
      } aufzubewahren bzw. weiterzugeben. Diese Funktionalität, kombiniert mit der \myMinin{map<T1, T2>}, erlaubt es, beliebig viele Parameter, mit beliebigen Typsignaturen als Parameter für das \myMinin{Command} zu nutzen, ohne dass die Funktionssignatur angepasst werden muss.

      Der Wert von einer \myMinin{any} Variable kann entweder invalid (keine Daten) oder valid (Daten) sein -- dies ist zu vergleichen mit den Variablen von Python. Dies provoziert Fehler, wenn die \myMinin{ConcreteCommand}s aufgerufen werden und der erwartete Typ nicht übereinstimmt. Allerdings ist dieses Problem durch eine Prüfung, ob die richtigen Typen in den \myMinin{any} Parametern stecken minimiert. Die Prüfung findet in dem \myMinin{Invoker} statt, bevor das \myMinin{ConcreteCommand} mit den parametern aufgerufen wird.

  %---------------------------------
  % Anforderungen an die angestrebte Lösung
  %---------------------------------
  \subsection{Anforderungen an die angestrebte Lösung}
  \label{ssec:Anforderungen an die angestrebte Lösung}
    Die Probleme, ein Makrosystem/-sprache zu implementieren, fangen dann an, wenn man von den Makros will, dass die \myMinin{Command}s nicht nur hintereinander abgearbeitet werden. Also ohne dass sie wissen, dass andere \myMinin{Command}s vor bzw. nach ihnen ausgeführt werden -- dieser Ablauf ist in \autoref{fig:sequential} zu sehen.

    \begin{figure}[H]
      \centering
      \myInput{img/sequential.tikz}
      \caption{Sequenzielles Abarbeiten von Prozessschritten}
      \label{fig:sequential}
    \end{figure}

    \autoref{fig:logic} zeigt den ersten Schritt zu einer nützlichen Implementierung -- Logik. Hierbei bietet man an, dass der Makro-Entwickler durch Rückgabewerte aus \myMinin{Command}s entscheiden kann, welche weiteren \myMinin{Command}s er ausführen möchte.

    \begin{figure}[H]
      \centering
      \myInput{img/logic.tikz}
      \caption{Logische Ausdrücke um bedingte Anweisungen zuzulassen}
      \label{fig:logic}
    \end{figure}

    Obwohl man mit solchen Makros schon einige Probleme lösen kann, ist es nicht das, was man zur Verfügung haben will, wenn man mit Datenstrukturen arbeitet, die normalerweise an Funktionen und Objekte geben werden, um sie zu modifizieren. Somit kommt in diesem Schritt hinzu, dass es Schleifen, sowie komplexe Parameter und Rückgabewerte geben kann, siehe \autoref{fig:loop}.

    \begin{figure}[H]
      \centering
      \myInput{img/loop.tikz}
      \caption{Schleife, die Anweisungen für ein Element aus der Liste aufrufen}
      \label{fig:loop}
    \end{figure}

    Letztendlich kann man sagen, dass ein solches Makrosystem/-sprache eine Programmiersprache mit Interpreter \autocite[S.274]{Gamma:1995:DPE:186897} sein sollte, deren Laufzeitumgebung eine anderes Softwaresystem ist.

    \paragraph{Fehlermeldungen}
      Die Fehlermeldungen, die bei Syntaxfehlern auftreten, sollten dem Nutzer möglichst viele sinnvolle Informationen liefern -- als Vorbild dient hier Clang (siehe \autoref{fig:clangerror}).

      \begin{myCodeEnv}
        \centering
        \begin{myInvBox}[width=.9\linewidth]
          \begin{lstlisting}[keepspaces,escapechar=°,numbers=none]
°\textbf{ main.cpp:4:42: \textcolor{red}{error}: expected ';' after expression}°
   std::cout << "Hallo Welt!" << std::endl
                                          °\textcolor{Green}{\textasciicircum}°
                                          °\textcolor{Green}{;}
          °\end{lstlisting}
        \end{myInvBox}
        \caption{Clang Fehlermeldung}
        \label{fig:clangerror}
      \end{myCodeEnv}
\myFixme{Ref Section in implementation / architekture} % FIXME

%---------------------------------
% Konzeption
%---------------------------------
\section{Konzeption}
\label{sec:Konzeption}
\myFixme{Durchgängiges Beispiel?!?!!?}
  Dieses Kapitel beschäftigt sich mit der theoretischen Problemlösung.

  \myNamedRef{ssec:Syntax} beschreibt die Syntax, welche von dem Tokenizer und Parser umgewandelt werden soll. Im \myNamedRef{ssec:Grundarchitektur} wird die Grundarchitektur des Makrosystems beschrieben. Diese Grundarchitektur umfasst nur die grobe Architektur des Makrosystems, da in dem \myNamedRef{ssec:Detaillierte Teilarchitekturen} auf die komplexeren Teile der Architektur eingegangen wird.

  %---------------------------------
  % Syntax
  %---------------------------------
  \subsection{Syntax}
  \label{ssec:Syntax}
    Die Syntax ist an C \autocite{C-std}, Python \autocite{Python-std}, JavaScript \autocite{Ecma-std} und Swift \autocite{Swift-std} angelegt. C liefert den größten Anteil der Syntax, von Python wurde \myMIn$def$ übernommen, von JavaScript \myMIn$var$ und die \emph{named parameter}\footnote{
      Named Parameter sind Parameter, die über einen Namen ihren Wert beim Funktionsaufruf zugewiesen bekommen. Die normale Wertzuweisungsstrategie ist, nach der Reihenfolge der Deklaration vorzugehen.
    }
    Syntax \myMIn$fun(foo:gun());$ von Swift. Die Unterscheidung zwischen \myMIn$def$ und \myMIn$var$ sorgt dafür, dass die Programmierer nach den ersten drei Zeichen wissen, was der folgende Code machen wird. Das die Makrosprache named parameter unterstützt, liegt daran, dass das Command-Pattern so implementiert wurde, dass Parameter alias Bezeichnungen benutzen können, um eine hohe Kompatibilität zwischen unabhängig entwickelten Modulen zu gewährleisten. Dies ist in der Makrosprache nicht so einfach möglich, somit sind die named parameter der bestmögliche Kompromiss, da diese erlauben, die Parameter in beliebiger Reihenfolge anzugeben, was durch die Nutzung von \myMinin{map<T1, T2>} von Nöten ist.

    %---------------------------------
    % Syntax Grundlagen
    %---------------------------------
    \subsubsection{Syntax Grundlagen}
    \label{sssec:Syntax Grundlagen}
      Bezeichner müssen dem regulären Ausdruck (Regex) aus \autoref{fig:idsyntax} entsprechen. \myTIn$*$ bedeutet null, \myTIn$+$ bedeutet ein, oder mehr vom vorausgehenden Zeichen. \myTIn$?$ bedeutet null oder ein Mal, in Verbindung mit \myTIn$*?$ wird beim ersten validen Regex abgebrochen. \myTIn$[]$ ist eine Sammlung von Zeichen, bei dem alle Zeichen einzeln verglichen werden -- \myTIn$[^]$ enthält alle Zeichen, die nicht genannt sind. In einer Sammlung kann \myTIn$-$ genutzt werden, um eine Reihe von Zeichen zu bestimmen. \myTIn$.$ kann jedes Zeichen sein, \myTIn$\s$ sind Whitespaces und \myTIn$\d$ sind Zahlen. \myTIn$|$ bedeutet oder und letztlich escaped \myMin{\} das folgende Zeichen.

      Das heißt, dass Bezeichner nur aus kleinen Buchstaben, Nummern und Unterstrichen bestehen können und am Anfang einen Buchstaben haben müssen. Grund für diese drastische Einschränkung ist, dass der Code einheitlich aussehen soll (die erste Regel was Bezeichnungen/Formatierung angeht ist, dass man sich an dem orientiert, was schon existiert). Um dies besser garantieren zu können, wurde die CamelCase Schreibweise von vorn herein ausgeschlossen. Außerdem sind Bezeichner, die einem keyword
      (%
        \myMIn$break$,
        \myMIn$def$,
        \myMIn$do$,
        \myMIn$else$,
        \myMIn$for$,
        \myMIn$if$,
        \myMIn$print$,
        \myMIn$return$,
        \myMIn$typeof$,
        \myMIn$var$,
        \myMIn$while$%
      ), einen Booleanwert (\myMIn$true$, \myMIn$false$), oder \myMIn$main$ entsprechen -- abgesehen von der einen \myMIn$main$ Methode -- verboten.

      \begin{figure}[H]
        \centering
        \myInput{img/idsyntax.tikz}
        \caption{Bezeichner}
        \label{fig:idsyntax}
      \end{figure}

      Literals sind entweder Doubles, Integer, Strings oder Boolean Werte, wie \autoref{fig:litsyntax} zeigt. In Strings ist es möglich besondere Zeichen zu escapen, zum Beispiel kann ein Zeilenumbruch, wie in anderen Programmiersprachen, mit \myMIn$"\n"$ oder ein Tab mit \myMIn$"\t"$, erzeugt werden.
      \begin{figure}[H]
        \centering
        \myInput{img/litsyntax.tikz}
        \caption{Syntax von Literals}
        \label{fig:litsyntax}
      \end{figure}

      \autoref{fig:vprsyntax} zeigt alle Werterzeuger, dass sind Konstrukte, die einen Wert für eine andere Operation bereitstellen.
      \begin{figure}[H]
        \centering
        \myInput{img/vprsyntax.tikz}
        \caption{Werterzeuger}
        \label{fig:vprsyntax}
      \end{figure}

      In \autoref{fig:returnsyntax} ist die Syntax von \myMIn$return$ zu sehen.
      \begin{figure}[H]
        \centering
        \myInput{img/retsyntax.tikz}
        \caption{Syntax von return}
        \label{fig:returnsyntax}
      \end{figure}

      Abbildungen \ref{fig:scopesyntax}, \ref{fig:loopscopesyntax} und \ref{fig:commonsyntax} zeigen den Syntax von einem Scope. Scopes sind Bestandteile von Funktionen und Kontrollstrukturen, wobei sich Loop Scopes von normalen Scopes nur darin unterscheiden, dass sie das \myMIn$break$ Keyword unterstützen. Alle Scopes -- abgesehen von Funktionsdeklarationsscopes -- die sich in einem Loop Scope befinden, sind automatisch Loop Scopes. Scopes verhalten sich wie C Scopes, was bedeutet, dass der Syntax \myMIn$var foo; {var foo;}$ richtig ist -- das erste \myMIn$foo$, wird von dem zweiten verdeckt.
      \begin{figure}[H]
        \centering
        \begin{minipage}{.45\linewidth}
          \vspace*{2.45em}
          \begin{figure}[H]
            \centering
            \myInputUnlimited{img/scopesyntax.tikz}
            \caption{Syntax vom Scope}
            \label{fig:scopesyntax}
          \end{figure}
        \end{minipage}%
        \begin{minipage}{.45\linewidth}
          \begin{figure}[H]
            \centering
            \myInputUnlimited{img/loopscopesyntax.tikz}
            \caption{Syntax vom Loop Scope}
            \label{fig:loopscopesyntax}
          \end{figure}
        \end{minipage}
      \end{figure}

      \begin{figure}[H]
        \centering
        \myInput{img/commonsyntax.tikz}
        \caption{Syntax allgemeiner Strukturen}
        \label{fig:commonsyntax}
      \end{figure}

    %---------------------------------
    % Definitionen
    %---------------------------------
    \subsubsection{Definitionen}
    \label{sssec:Definitionen}
      Variablen können, wie in \autoref{fig:varsyntax} zu sehen ist, definiert werden: \myMIn$var foo;$. Um anschließend der Variablen einen Wert zuzuweisen, ist es unter anderem erlaubt, dies zu tun: \myMIn$var foo = fun();$ oder \myMIn$var foo = true == false;$. Dieser Syntax erlaubt es nicht den Variablen einen Typ zuzuweisen -- dieser Teil der Sprache ähnelt deswegen Python und JavaScript sehr.
      \begin{figure}[H]
        \centering
        \myInput{img/varsyntax.tikz}
        \caption{Syntax der Variablendeklaration}
        \label{fig:varsyntax}
      \end{figure}

      Funktionen können über \myMIn$def fun(){...}$ definiert werden, was \autoref{fig:funsyntax} zeigt. Um eine parametrisierte Funktion zu definieren, gibt man die Parameternamen, Komma getrennt, nach dem Funktionsnamen an: \myMIn$def fun(foo, bar){...}$ (\myMIn$def fun(bar, foo){...}$ definiert die gleiche Funktion und würde zu einem Fehler führen, wenn beide Funktionen in dem selben Scope definiert werden). Zudem ist es nicht erlaubt, ein Whitespace zwischen dem Bezeichner und der Klammer zu haben.
      \begin{figure}[H]
        \centering
        \myInput{img/funsyntax.tikz}
        \caption{Syntax der Funktionsdeklaration}
        \label{fig:funsyntax}
      \end{figure}
      Der Einstiegspunkt eines jeden Makros ist eine \myMIn$def main(){...}$ Funktion. Der Syntax ist der selbe wie bei den normalen Funktionen und erlaubt es daher auch Parameter anzugeben. Deswegen können die Makros aus anderen Makros, oder aus der C++ Ebene über einen äquivalenten Syntax mit Parametern aufgerufen werden.

    %---------------------------------
    % Kontrollstrukturen
    %---------------------------------
    \subsubsection{Kontrollstrukturen}
    \label{sssec:Kontrollstrukturen}
      Die Syntax von \myMIn$if/else$, \myMIn$do-/while$ und \myMIn$for$ aus den Abbildungen \ref{fig:ifsyntax}, \ref{fig:whilesyntax}, \ref{fig:dowhilesyntax} und \ref{fig:forsyntax} sollten wie erwartet aussehen.
      \begin{figure}[H]
        \centering
        \myInput{img/ifsyntax.tikz}
        \caption{Syntax von if}
        \label{fig:ifsyntax}
      \end{figure}

      \begin{figure}[H]
        \centering
        \myInput{img/whilesyntax.tikz}
        \caption{Syntax von while}
        \label{fig:whilesyntax}
      \end{figure}

      \begin{figure}[H]
        \centering
        \myInput{img/dowhilesyntax.tikz}
        \caption{Syntax von do-while}
        \label{fig:dowhilesyntax}
      \end{figure}

      \begin{figure}[H]
        \centering
        \myInput{img/forsyntax.tikz}
        \caption{Syntax von for}
        \label{fig:forsyntax}
      \end{figure}

    %---------------------------------
    % Befehle
    %---------------------------------
    \subsubsection{Befehle}
    \label{sssec:Befehle}
      \autoref{fig:callsyntax} zeigt die Syntax, um eine definierte Funktion aufzurufen. \myMIn$fun(foo:gun(), bar:foo);$ weist dem \myMIn$foo$ Parameter den Wert von \myMIn$gun()$ zu und dem Parameter \myMIn$bar$ wird der Wert von \myMIn$foo$ aus dem Scope zugewiesen. Wie auch bei der Definition der Funktion, ist es nicht erlaubt einen Whitespace zwischen dem Bezeichner und er Klammer zu haben.
      \begin{figure}[H]
        \centering
        \myInput{img/calsyntax.tikz}
        \caption{Syntax von Funktionsaufrufen}
        \label{fig:callsyntax}
      \end{figure}

      Die Operator Syntax aus \autoref{fig:opsyntax} folgt, wie die \myMIn$return$ Syntax, den Vorbildern dieser Syntax (C, Python, Javascript, Swift).

      \begin{figure}[H]
        \centering
        \myInput{img/opsyntax.tikz}
        \caption{Syntax von Operatoren}
        \label{fig:opsyntax}
      \end{figure}

      Geklammerte Ausdrücke werden zuerst vollständig ausgewertet, bevor der Operator angewendet wird. Das heißt, dass \myMIn$(a || b) && c$ folgender Weise interpretiert wird. Als erstes wird \myMIn$a$ ausgewertet. Wenn a \myMIn$false$ war, wird \myMIn$b$ ausgewertet, wenn eins der beiden \myMIn$true$ ergibt, wird \myMIn$c$ ausgewertet. Entgegen dessen wird bei \myMIn$a || b && c$ zuerst \myMIn$a$, und wenn \myMIn$a$ \myMIn$false$ war, \myMIn$b$ und \myMIn$c$ ausgewertet. Es wird also von links nach rechts ausgewertet und es gibt eine Kurzschlusssemantik. Die Präzedenz der Operatoren ist -- abgesehen von \myMIn$print$ (der vor \myMIn$=$ kommt) die Reihenfolge aus der Grafik (siehe Nummerierung).

      Zu den `normalen' Operatoren aus C, gibt es zudem noch den \myMIn$typeof$ Operator aus JavaScript. Dieser Operator wandelt den Typ der variable in einen \myMIn$string$ um (\myMinin{1}$\rightarrow$\myMinin{"int"}). Zudem gibt es den \myMIn$print$ Operator, der den Wert einer Variable ausgibt (zB. auf die Konsole) und als \myMIn$string$ zurückgibt.

  %---------------------------------
  % Grundarchitektur
  %---------------------------------
  \subsection{Grundarchitektur}
  \label{ssec:Grundarchitektur}
\myFixme{Durchgängiges Beispiel?!?!!?}
    Da das komplette UML Diagramm sehr unübersichtlich ist und nicht auf ein A2 Blatt passt, sind die folgenden Diagramme Ausschnitte aus dem Kompletten und spiegeln es zusammen wieder.

    \autoref{fig:toppackuml} zeigt die Abhängigkeiten der Pakete (namespaces) in dem Modul, welches die Makrofunktionalität anbieten soll. \myMinin{core} ist das Paket, indem das Command-Pattern aus dem \autoref{ssec:Diskussion des Problemfeldes} implementiert ist. Das \myMinin{pod} Paket enthält alle Klassen, die die nur zur Verwaltung von Daten dienen (separation of concerns) und deswegen \emph{plain old data} (POD), oder auch \emph{passive data structure} (PDS) genannt werden. In dem \myMinin{pod} Paket befindet sich die \myMinin{Token} Klasse und das \myMinin{ast} Paket, welches alle Klassen, die den abstrakten Syntaxbaum ausmachen, beinhaltet. In dem \myMinin{parser} Paket befinden sich der Tokenizer und Parser.
    \begin{figure}[H]
      \centering
      \myInput{img/toppackuml.tikz}
      \caption{Abhängigkeiten von dem Makro Modul}
      \label{fig:toppackuml}
    \end{figure}

    %---------------------------------
    % Token und Parser Paket
    %---------------------------------
    \subsubsection{Token und Parser Paket}
    \label{sssec:Token und Parser Paket}
      Der \myMinin{Parser} aus \autoref{fig:parserpackuml} bedient sich des \myMinin{Tokenizer}, um eine \myMinin{TokenList} von \myMinin{Token}s zu bekommen. Diese \myMinin{TokenList} kann der \myMinin{Parser} dann parsen, bzw. in einen abstrakten Syntaxbaum umwandeln. Die \myMinin{TokenList} Klasse dient nur der Erklärung und wird sich nicht in der Implementation wiederfinden, da sie nur ein Array beschreibt.
      \begin{figure}[H]
        \centering
        \myInput{img/parserpackuml.tikz}
        \caption{Parser Paket UML}
        \label{fig:parserpackuml}
      \end{figure}

      \paragraph{Tokenizer}
        Der \myMinin{Tokenizer} wandelt den String, der das Makro beschreibt, in eine Reihenfolge von \myMinin{Token}s um. Tokens sind alle Zeichen, die von whitespace (\myRIn$\s*$) getrennt sind, die nicht den Anforderungen als Bezeichner genügen (\myRIn$[^a-zA-Z0-9_]$, siehe \autoref{fig:idsyntax}), die durch einen Punkt eine Dezimalzahl bilden (\myRIn$\d*\.\d+$) oder einen String darstellen\penalty-1000000(\myRIn$".*?"$\footnote{
          Dieser Regex funktioniert nur für einfache Varianten (kein escapen) von Strings und dient deswegen nur der Veranschaulichung.
        }). Der \myMinin{Tokenizer} ist nicht für das Lexen verantwortlich -- dies wird von dem Parser übernommen.

      \paragraph{Token}
        \myMinin{Token}s beinhalten die Zeile sowie Spalte als Zahl, und den gesamten Quelltext aus der Zeile, aus der das \myMinin{Token} entstanden ist. Dies ist von Nöten, um später gute Fehlermeldungen zu erzeugen, mit denen ein Benutzer schnell weiß, wo er nach dem Fehler suchen muss. Des weiteren enthält die Klasse einen String, der den Teil des Makros enthält, den die Instanz darstellen soll (zB. \myMIn$if$).

      \paragraph{Parser}
        Der \myMinin{Parser} ist dafür verantwortlich, dass die \myMinin{TokenList} in einen AST umgewandelt wird. Wie in \autoref{sssec:Parser} beschrieben, gibt es drei Hauptarten von Parsern \emph{LL}, \emph{LR} und \emph{recursive descent}. LL und LR Parser sind meistens schneller als recursive descent, da sie mit Hilfe von Zustandstabellen arbeiten, die meist aus der Backus-Naur-Form heraus entstehen. Der Nachteil bei den beiden ist, dass LL und umso mehr LR Parser, schwer zu warten sind, weswegen meist Parser-Generatoren genutzt werden, um den Quelltext für den Parser zu generieren. Außerdem sind die Fehlermeldungen, die LL und LR Parser erzeugen meistens schlechter als die, die recursive descent Parser von Natur aus mit sich bringen\autocite{scott2010gll}. Da die Wartbarkeit und Fehlermeldungen wichtige Punkte auf der Anforderungsliste sind, wurde sich für einen recursive descent Parser entschieden. Zudem sind die gelungenen Parser von Clang\autocite{clang-feat} und GCC\autocite{gcc-new-parser} ein gutes Beispiel und Vorbild, was mit recursive descent Parsern erreicht werden kann.

        Beim Parsen müssen die Literals umgewandelt werden (Lexen) -- aus dem Token \myMinin{"1.01"} muss der Double \myMinin{1.01} und escapete Symbole in einem String müssen umgewandelt werden (z.B.: \myMinin{"t\tt"}$\rightarrow$\myMinin{"t  t"}).

        Die Operatoren müssen in der richtigen Reihenfolge zusammengestellt werden. Das heißt, dass bei \myMinin{!a || b} zuerst \myMinin{!a} ausgewertet werden muss und im Anschluss daran \myMinin{x || c} (\myMinin{x} sei das Ergebnis von \myMinin{!a}). Der Baum muss so aufgebaut sein, das diese Reihenfolge eindeutig und korrekt ist.

        Variablendeklarationen mit anschließender Wertzuweisung müssen in zwei Schritte aufgeteilt werden (erst deklarieren und dann der Variablen den Wert zuweisen\footnote{
          Dies ist valider C Code: \myMinin{const int foo = foo + 1;}
        }).

      \paragraph{Analyser}
        Nachdem der \myMinin{Parser} die \myMinin{TokenList} in einen AST umgewandelt hat, wird der \myMinin{Analyser} genutzt, um den AST zu validieren. Dies muss geschehen, da die gewisse Fehler nicht aus der Syntax hervorgehen -- zum Beispiel, dass die \myMinin{main()} Methode nicht explizit aufgerufen werden darf. Zwar ist es möglich den \myMinin{Parser} erweitern, so dass er auch solche Fehler finden kann, allerdings ist es nicht die Aufgabe eines Parsers etwas zu Validieren.

        Der \myMinin{Analyser} wird den AST ablaufen und vor und nach jedem AST Element, ein Signal abschicken. Signals sind mit dem Visitor-Pattern \autocite[S.366]{Gamma:1995:DPE:186897} sehr eng verwand. Ein Visitor wird bei dem entsprechenden Signal registriert und durch das absenden des Signals aufgerufen -- es können pro Signal mehrere Visitoren verbunden werden. Wenn der \myMinin{Analyser} dann zum Beispiel einen Funktionsaufruf, auf die \myMinin{main()} Methode findet, kann er dies als Fehler melden. Im Gegensatz zu dem Visitor-Pattern werden bei Signalen alle Visitoren gesammelt und in einem Durchlauf abgearbeitet. Der Vorteil hierbei ist, das der AST nur einmal durchlaufen werden muss, was schneller ist und keine Nachteile mit sich bringt.

    %---------------------------------
    % Abstrakter Syntaxbaum Paket
    %---------------------------------
    \subsubsection{Abstrakter Syntaxbaum Paket}
    \label{sssec:Abstrakter Syntaxbaum Paket}
      Wie \autoref{fig:ASTuml} zeigt\footnote{
        Es wurden einigele Klassen hinter allgemeinen Begriffen -- wie \myMinin{Loop} -- versteckt, um etwas Übersicht zu bewahren.
      }, sind für alle Konstrukte, die das Scope (siehe \autoref{fig:commonsyntax}) aufnehmen kann, Klassen von Nöten. Alle Klassen erben von der \myMinin{AST} Klasse, welche ein \myMinin{Token} als Attribut besitzt. Da die \myMinin{Token} alle Informationen über den Makro Quelltext haben, und es sich bei der resultierenden Datenstruktur um einen Baum handelt (der Baum ist rekursiv -- siehe \autoref{fig:Scopeuml}), ist auch der Interpreter in der Lage informative Fehlermeldungen zu generieren.
      \begin{figure}[H]
        \centering
        \myInput{img/ASTuml.tikz}
        \caption{Stammbaum der AST Klassen}
        \label{fig:ASTuml}
      \end{figure}

      \autoref{fig:Scopeuml} zeigt die \myMinin{Scope} Klasse, diese kann beliebig viele andere \myMinin{AST} Instanzen aufnehmen.
      \begin{figure}[H]
        \centering
        \myInput{img/Scopeuml.tikz}
        \caption{Verbindungen vom Scope}
        \label{fig:Scopeuml}
      \end{figure}

      In \autoref{fig:Conditionuml} sind die restlichen Abhängigkeiten zwischen den \myMinin{AST} Klassen zu sehen.
      \begin{figure}[H]
        \centering
        \myInput{img/Conditionuml.tikz}
        \caption{Abhängigkeiten der AST Klassen}
        \label{fig:Conditionuml}
      \end{figure}

    %---------------------------------
    % Interpreter Paket
    %---------------------------------
    \subsubsection{Interpreter Paket}
    \label{sssec:Interpreter Paket}
      Der \myMinin{Interpreter} nutzt den \myMinin{parser::Parser}, um einen \myMinin{ast::Scope} zu erzeugen, wie in \autoref{fig:interpreterpackuml} zu sehen ist.

      \begin{figure}[H]
        \centering
        \myInput{img/interpreterpackuml.tikz}
        \caption{Interpreter Beziehungen}
        \label{fig:interpreterpackuml}
      \end{figure}

      \paragraph{OperatorProvider}
        Durch den \myMinin{OperatorProvider} als Mittelmann, ist es möglich Operatoren auf spezielle Datentypen anzuwenden, die über die der Literals hinausgehen (siehe \autoref{sssec:OperatorProvider Architektur}). Die Trennung von \myMinin{OperatorProvider} und \myMinin{Interpreter} beruht darauf, dass es nur einen \myMinin{OperatorProvider} geben muss, aber es viele \myMinin{Interpreter} geben kann. Zudem müssen so die Operatoren nur ein einziges mal registriert werden.

      \paragraph{Stack}
        Während der Ausführung des Makros, durch den \myMinin{Interpreter}, übernimmt der \myMinin{Stack} die Verwaltung der definierten Funktionen und Variablen sowie deren Werte. Dadurch repräsentiert der \myMinin{Stack} die \myMinin{ast::Scope}s. Wenn ein neues \myMinin{Scope} in dem \myMinin{AST} geöffnet wird, wird ein neuer \myMinin{Stack} erzeugt, der als vorherigen \myMinin{Stack} den aktiven \myMinin{Stack} bekommt. Durch diese Verkettung wird eine Verketteteliste aufgebaut, bei der man nur den Kopf entfernen muss, um ein \myMinin{ast::Scope} zu beenden, siehe \autoref{fig:stackex}.In \autoref{sssec:Stack Architektur} wird die Architektur weiter ausgeführt.
        \begin{figure}[H]
          \centering
          \myInput{code/stackex.tikz}
          \caption{Stack Beispiel}
          \label{fig:stackex}
        \end{figure}

        Sollte der \myMinin{Stack} keine passende Funktion haben, wird der \myMinin{CommandProvider} nach einem passendem \myMinin{core::Command} gefragt, wonach dieses in der C++ Ebene ausgeführt wird. Damit realisieren \myMinin{core::Command}s die \myMinin{ast::Callable} Funktionen. Funktionen, die in der Makrosprache definiert sind, realisieren ebenso die \myMinin{ast::Callable}.

      \paragraph{Interpreter}
        Der Interpreter selber läuft den AST ab, erweitert den \myMinin{Stack} bei \myMinin{ast::Scope}s, fügt dem \myMinin{Stack} Variablen und Funktionen bei deren Definition (durch \myMinin{ast::Define}) zu und poped den \myMinin{Stack} wenn er fertig ist, ein \myMinin{ast::Scope} zu interpretieren. \myMinin{ast::Condition}s werden mit Hilfe das \myMinin{OperatorProvider}s ausgewertet und der Rest der \myMinin{ast} Klassen, lässt sich durch eine Verknüpfung der vorherigen Vorgehensweisen lösen.

  %---------------------------------
  % Detaillierte Teilarchitekturen
  %---------------------------------
  \subsection{Detaillierte Teilarchitekturen}
  \label{ssec:Detaillierte Teilarchitekturen}
\myFixme{Durchgängiges Beispiel?!?!!?}
    Dieser Abschnitt bildet den Übergang vom theoretischen zum praktischen Teil, in dem hier die komplexeren Bestandteile der Architektur beschrieben werden. Um diese Teilarchitekturen beschreiben zu können, wird in \autoref{sssec:Die Programmiersprache} die Programmiersprache gewählt, in welcher das Makrosystem entwickelt wird. In den darauffolgenden Kapiteln wird die Architektur des \myMinin{Parser}s, \myMinin{OperatorProvider}s, \myMinin{Stack} und des \myMinin{Interpreter}s genauer betrachtet.

    %---------------------------------
    % Die Programmiersprache
    %---------------------------------
    \subsubsection{Die Programmiersprache}
    \label{sssec:Die Programmiersprache}
      Da das vorhandene System in C++ geschrieben ist, ist es größten Teils überflüssig über andere Programmiersprachen nachzudenken.

      Durch das \emph{name mangling}\footnote{
        Beim `name mangling' fügt der Compiler den Funktionsnamen weite Informationen hinzu, um eine eindeutige Funktionssignatur zu erhalten.
      } ist es schwierig, eine API von C++ zu anderen Programmiersprachen anzubieten. Meistens wird eine C API aus der C++ Welt von den Entwicklern angeboten, um mit anderen Programmiersprachen zu kommunizieren. Bei dieser verliert man den Vorteil der Objektorientierung und muss meistens auch die Daten zwischen C++$\longleftrightarrow$C und C$\longleftrightarrow$XYZ (z.B Python oder Lua) konvertieren, was langsam ist. Die Makros müssen aber auf Daten arbeiten, welche als Objekte von C++ vorliegen. Deswegen müsste der \myMinin{Stack}, mit dem der \myMinin{Interpreter} arbeitet, in der C++ Ebene bleiben. Damit würde eine Implementierung von \myMinin{Tokenizer}, \myMinin{Parser}, \myMinin{ast} und \myMinin{Interpreter} die Wartbarkeit, durch die Teilung und die weitere Programmiersprache deutlich verschlechtern. Zusätzlich ist das Ziel eine Applikation zu automatisieren, und nicht mit komplett neuen Funktionalitäten zu erweitern, was die Vorteile von z.B Python größtenteils zunichte macht. Aufgrund dessen wurde C++ als Programmiersprache gewählt.

      Die vorhandene Software ist Cross-Plattform (Windows und Linux) entwickelt. Im Rahmen dieser Bachelorarbeit wird die Software nur auf Linux entwickelt, da die Implementation des C++ Standards von Microsoft zum Teil unvollständig oder auch falsch ist und bei der Fehlersuche meist viel Zeit in Anspruch nimmt \autocite{new-ms-compiler}. Bei der Entwicklung wird daher darauf geachtet, dass keine Linux spezifischen Bibliotheken in Anspruch genommen werden. Das schließt leider nicht aus, dass die entstehende Software, ohne Anpassungen, auf Windows ausgeführt werden kann.

      Dinge die zu berücksichtigen sind:
      \begin{itemize}
        \item dependency circle\\
          Ein dependency circle entsteht, wenn in C oder C++ zwei (oder mehr) Datenstrukturen sich gegenseitig brauchen.\\
          Beispiel: \myMinin{class A} braucht \myMinin{class B} und \myMinin{class B} braucht \myMinin{class A} um sich zu definieren. Eine Lösung besteht darin, eine Klasse so zu definieren, dass sie nur von dem Pointer der anderen Klasse abhängt.

          Da das \myMinin{Scope} Instanzen von allen \myMinin{AST} Klassen aufnehmen kann, und einige Klassen wiederum ein \myMinin{Scope} besitzen, kommt es hier zu einem dependency circle. Weil das \myMinin{Scope} eine der meist benutzten Klassen ist, liegt die Auflösung des dependency circles bei den anderen Klassen.
        \item plain old data\\
          In C++ sind nur Klassen PODs, die trivial sind und standard-layout haben \autocite[9 Classes §10]{C++14-std}. Da die \myMinin{Token}s \myMinin{std::string} benutzen, sind alle Klassen die von \myMinin{Token} ein Attribut haben, genauso wenig POD wie \myMinin{std::string}. Somit ist das \myMinin{pod} Paket nur ein Hinweis darauf, dass die Klassen keine Logik haben, aber nicht POD Klassen nach dem C++Standard sind.
      \end{itemize}

    %---------------------------------
    % Parser Architektur
    %---------------------------------
    \subsubsection{Parser Architektur}
    \label{sssec:Parser Architektur}
      Der \myMinin{Tokenizer} hat keinen Zustand, da er nur einen stream von Zeichen aufteilen muss, und sollte daher nicht weiter beschrieben werden müssen. Dies gilt auch für alle \myMinin{ast} Klassen, da diese POD Klassen sind und somit nur Daten verwalten.

      Da der \myMinin{Parser} recursive decent implementiert wird, kann der \myMinin{Parser} ohne einen Zustand -- sprich Attribute -- auskommen. In diesem Fall kann darauf verzichtet werden, den \myMinin{Parser} als Klasse zu implementieren und anstelle dessen eine \myMinin{static} Funktion anzubieten. Dies hat den Vorteil, dass der \myMinin{Parser} garantiert Thread-Safe ist, da alle Daten von dem nativen Funktionsstack verwaltet werden.

      Für nahezu alle \myMinin{ast} Klassen bzw. keywords sollte der \myMinin{Parser} eine Methode zum parsen haben. Diese Modularität erlaubt es später den \myMinin{Parser} leichter zu erweitern, bzw. Fehler lokalisieren zu können. Da jede Methode genau für einen Teil der Syntax zuständig ist und es keinen Objekt Zustand gibt, können die Methoden für sich betrachtet und überprüft werden.

      Die Einstiegsmethode des \myMinin{Parser}s muss zusätzlich, zu dem zu parsenden String, den Namen des Makros bzw. der Datei übergeben bekommen. Dies sorgt dafür, dass die Fehlermeldungen für den Benutzer eindeutig zuzuordnen sind.

      Die Fehlermeldungen sollten so viel Informationen wie möglich an den Nutzer liefern, ohne dass es sich um nutzlose Informationen handelt. So ist es für den Nutzer nicht nur wichtig, in welcher Zeile und Spalte der Fehler liegt, sondern auch in welchem Kontext. Das bedeutet, dass es einen Stack gibt (siehe \ref{enum:Mehr Fehler}), der dem Nutzer gezeigt werden kann. Sinnvoll ist es zB. alle Scopeanfänge anzugeben (Funktionen/Kontrollstrukturen). Durch diese Informationen ist der Nutzer sofort mit dem Kontext des Fehlers versorgt und kann über den Grund des Fehlers, oder die Lösung  nachdenken, während er zu der Zeile und Spalte navigiert.

    %---------------------------------
    % Analyser Architektur
    %---------------------------------
    \subsubsection{Analyser Architektur}
    \label{sssec:Analyser Architektur}
      Durch die Entscheidung, dass der \myMinin{Analyser} mit Hilfe von Signals implementiert wird, die dem Visitor-Pattern ähneln, ist die Architektur in zwei Teile aufteilbar.

      Der erste Teil beschäftigt sich mit dem ablaufen des AST und dem absenden der Signale (der Ausführung der Visitoren). Dieser Teil ist recht einfach, da es keiner besonderen Logik bedarf. Vor dem Aufruf eines Signals, von einem \myMinin{ast::Scope}, fügt der \myMinin{Analyser} das Token, des \myMinin{ast::Scope}s, als Referenz zu einer Liste hinzu. Diese Liste kann dann genutzt werden um Fehlermeldungen, mit der gleichen Informationsqualität des \myMinin{Parser}s zu erzeugen\footnote{
        Der \myMinin{Analyser} setzt \ref{enum:Mehr Fehler} um.
      }.

      Der zweite Teil sind die Tests, die als Visitoren bei den Signalen angemeldet werden. Die meisten der Visitoren kommen ohne weitere Daten aus, aber Visitoren, die wissen müssen, ob sie sich gerade in einem Loop Scope befinden, brachen auch einen State, der von dem ersten Teil beim durchwandern des AST aktuell gehalten wird. Der State ist Nötig, da der AST nicht als Doppelt verkettete Liste implementiert ist -- also nur die Eltern die Kinder kennen. Dieser State lässt die Grenze der beiden Teile ein wenig verschwimmen, ist aber die simpelste und schnellste Möglichkeit den \myMinin{Analyser} leicht erweiterbar zu halten.

      Unter anderem findet der \myMinin{Analyser} Fehler wie die doppelte Funktionsdeklaration. \myMinin{def fun() {...}} und \myMinin{def fun(foo) {...}} stehen nicht in Konflikt, da sie andere Parameter haben. Da die Reihenfolge der Parameter nicht Bestandteil der Signatur ist, ist \myMinin{def fun(a, b) {...}} und \myMinin{def fun(b, a) {...}} -- im selben \myMinin{ast::Scope} -- nicht zulässig.

    %---------------------------------
    % OperatorProvider Architektur
    %---------------------------------
    \subsubsection{OperatorProvider Architektur}
    \label{sssec:OperatorProvider Architektur}
      Der \myMinin{OperatorProvider} ist eine Klasse, deren Aufgabe es ist, Datentypen Funktionen zuzuordnen und zur Verfügung zu stellen. Da die \myMinin{Operatoren} zustandslos sind\footnote{
        Dies kann nicht garantiert werde, es ist allerdings unwahrscheinlich, dass dies ein Problem ist.
      }, müssen die \myMinin{Operatoren} nur ein einziges mal registriert werden. Die \myMinin{Operatoren} für die \myMinin{ast::Literal} Klassen werden von dem \myMinin{OperatorProvider} automatisch registriert.

      Die Überladung von \myMinin{Operatoren} ist ausgeschlossen, ebenso ist nicht vorgesehen, dass Datentypen implizit konvertiert werden. Das heißt, dass ein \myMinin{char} \emph{nicht} zu einem \myMinin{int} promoted\footnote{
        Promoted bedeutet, dass ein kleinerer, primitiver Datentyp zu einem größeren implizit konvertiert werden kann. Dies ist immer dann möglich, wenn kein Datenverlust auftritt.
      } werden kann, wie es in den meisten typisierten Programmiersprachen der Fall ist. Eine Ausnahme ist der \myMinin{bool} und \myMinin{!} Operator. Wenn eine Variable als Ausdruck für Logik (\myMIn$for$, \myMIn$if$, \myMIn$while$ oder Operatoren) ist, und nicht Bestandteil eines anderen Vergleichsoperators ist, probiert der \myMinin{Interpreter} den \myMinin{bool} Operator für die Variable anzuwenden. Der \myMinin{bool} Operator existiert nur für diese Fälle und kann nicht explizit aufgerufen werde. In dem Kontext \myMIn$i && a == b$ wird für \myMIn$i$ der \myMinin{bool} Operator aufgerufen aber nicht für \myMIn$a$ und \myMIn$b$;

    %---------------------------------
    % Stack Architektur
    %---------------------------------
    \subsubsection{Stack Architektur}
    \label{sssec:Stack Architektur}
      Die \myMinin{Stack} Klasse ist der komplexeste Bestandteil des \myMinin{Interpreter}s. Der \myMinin{Stack} verwaltet alle Variablen und Funktionsdeklarationen, die ein Makro macht.

      Für die Variablen muss der \myMinin{Stack} einem \myMinin{string} eine \myMinin{any} Instanz zuweisen. Da keine überflüssigen Kopien bei der Übergabe von Parametern erzeugt werden sollen, muss der \myMinin{Stack} auch einen \myMinin{string} zu einer Referenz auf eine \myMinin{any} Instanz aus einem anderen \myMinin{Stack} erlauben.

      Die Funktionen brauchen nur als konstante Referenzen auf die Funktionsdefinitionen in dem \myMinin{ast} gespeichert werden. Diese Objekte werden nicht verändert und dienen nur als Vorlage, welche der \myMinin{Interpreter} interpretieren muss.

      Letztlich haben die \myMinin{Stack} Instanzen einen Pointer auf den \myMinin{Stack} über ihnen, siehe \autoref{fig:stackex} und \autoref{fig:interpreterpackuml}. Diese Pointer werden dann genutzt, um nach Variablen und Funktionsdeklarationen zu fragen. Im Fall, dass der \myMinin{Interpreter} nach einer Funktion fragt, kann der \myMinin{Stack} durch die verkettete Liste (siehe \ref{enum:linkedlist}) nicht nur die Funktionsdefinition zurückgeben, sondern auch gleich den Pointer auf den \myMinin{Stack}, in dem die Funktion definiert wurde. Es ist also nicht nötig, die Funktionen zu dem \myMinin{Stack} Pointer zuzuordnen, in dem sie deklariert worden sind, da dies automatisch geschieht.


    %---------------------------------
    % Interpreter Architektur
    %---------------------------------
    \subsubsection{Interpreter Architektur}
    \label{sssec:Interpreter Architektur}
      Die Architektur des \myMinin{Interpreter}s ist durch den AST und \myMinin{Parser} relativ simpel. Außerdem lösen \myMinin{OperatorProvider} und \myMinin{Stack} die komplexesten Teile des \myMinin{Interpreter}s.

      Ähnlich wie der \myMinin{Parser} ist der \myMinin{Interpreter} recursive decent implementiert. Das heißt, dass für jede \myMinin{ast} Klasse eine \myMinin{interpret()} Methode existiert. Durch den Aufbau des ASTs, endet der \myMinin{Interpreter} `immer' an einem Werterzeuger (Funktionsaufruf, Variable, \ldots), der von Kontrollstrukturen (\myMinin{if}, \myMinin{while}, \ldots) konsumiert wird.

      Der \myMinin{Interpreter} interpretiert den AST in mehreren Schritten:
      \begin{enumerate}
        \item Alle Funktionsdefinitionen aus dem aktuellen \myMinin{ast::Scope} werden interpretiert.\\
          Das sorgt dafür, dass keine Definitionsreihenfolge eingehalten werden muss -- \myMIn$fun() def fun() {...}$ ist kein Fehler.
        \item Das das aktuelle \myMinin{ast::Scope} wird abgearbeitet.\\
          Das `root' \myMinin{ast::Scope} wird normal behandelt, was heißt, dass \myMinin{if}, \myMinin{while}, Funktionsaufrufe, \ldots{} erlaubt sind. Eine Ausnahme ist die \myMinin{main()} Methode, diese darf niemals aufgerufen werden.
        \item Die Abarbeitung der Einstiegsfunktion \myMinin{main()}.\\
          Hier werden wieder die ersten zwei Schritte durchgeführt, welche sich in jedem folgenden \myMinin{ast::Scope}, sowie Funktionsaufrufen wiederholen.
      \end{enumerate}

      Wenn eine Funktion interpretiert werden soll, muss der \myMinin{Interpreter} Variablen, die als Parameter übergeben werden, dem neuen \myMinin{Stack} als Referenzen hinzufügen. Und im Anschluss daran, kann er dann das \myMinin{ast::Scope}, der Funktion interpretieren. Das Zuweisen von Parametern verhält sich ähnlich wie bei JavaScript -- die Parameter werden als (konstante) Referenz übergeben und nicht kopiert. Wenn dem Parameter ein neuer Wert zugewiesen wird, verändert sich der Wert aus dem aufrufendem Scope nicht. Stattdessen wird die Referenz aus dem \myMinin{Stack} gelöscht und eine Variable, mit dem neuen Wert, angelegt.

      Die Besonderheiten des Interpreters:
      \begin{itemize}
        \item Wenn der \myMinin{Stack} keine entsprechende Funktion besitzt, wird der \myMinin{CommandProvider} nach einer Funktion gefragt.\\
          Das heißt, dass die nativen Funktionen von Funktionsdefinitionen in dem Makro überschrieben und auch unerreichbar werden können.
        \item Wenn eine Funkion interpretiert werden muss und diese von dem \myMinin{CommandProvider} kommt, werden die Parameter kopiert.\\
          Es ist durch die C++ Ebene vorgegeben und wird normalerweise durch Pointer beschleunigt. In der C++ Ebene ist es auch möglich die move-semantics aus C++11 anstelle von Pointern anzuwenden, das ist allerdings nicht aus der Makro Ebene möglich.
        \item Wenn eine Variable aus einem \myMinin{ast::Scope} returned wird, also ein Funktionsrückgabewert ist, kann dies ohne eine Kopie passieren.\\
          Dies ist dann möglich, wenn die Variable, die returned wird in dem \myMinin{Stack} angelegt wurde und keine Referenz ist.
      \end{itemize}

      Um einen \myMinin{ast::Operator} zu interpretieren geht der \myMinin{Interpreter} durch folgende Schritte:
      \begin{enumerate}
        \item Interpretiert er den  \myMinin{ast::Operator} soweit, dass er einen/zwei Werterzeuger und einen Operatortyp (zB. \myMinin{==}) hat.
        \item Erzeugt der \myMinin{Interpreter} den/die Wert/e des/der Werterzeuger/s.\\
          Im Falle, dass es sich um den Operatorentyp \myMinin{&&} oder \myMinin{||} handelt, kann der Interpreter auch schon durch die Kurzschlusssemantik früher aufhören.
        \item Nutzt er den \myMinin{OperatorProvider} um die beiden Werte mit einem registrierten Opteratoren zu vergleichen.
      \end{enumerate}

      Da die \myMinin{ast} Instanzen das \myMinin{Token} besitzen, durch welches sie entstanden sind, ist der \myMinin{Interpreter} -- im Falle, dass kein passender \myMinin{Operator} oder Funktion gefunden werden können -- in der Lage genau so gute Fehlermeldungen zu produzieren, wie der \myMinin{Parser}.

    %---------------------------------
    % Komplexe Rückgabewerte
    %---------------------------------
    \subsubsection{Komplexe Rückgabewerte}
    \label{sssec:Komplexe Rückgabewerte}
      Die komplexen Rückgabewerte, aus der Makro Ebene in die C++ Ebene sind durch den \myMinin{any} Typ kein Problem, da sich diese durch den Stack schon von Anfang an in der C++ Ebene befinden. An dieser Stelle muss es sich um eine \myMinin{ast::Variable} handeln, die angelegt wurde und kann deswegen ohne eine Kopie anzulegen aus der C++ Funktion des Interpreters returned werden.

      Um die Makros auch aus der C++ Ebene aufzurufen, bedarf es einen Wrapper für den Interpreter, der das \myMinin{core::Command} Interface implementiert. Da die \myMinin{interpret()} Methoden von dem \myMinin{Interpreter} alle einen \myMinin{any} Wert zurückgeben, ist der Rückgabewert kein Problem. Der \myMinin{Interpreter} selber hat keine Ahnung, was sich in dem \myMinin{any} Typ befindet -- das ist nicht gut aber die selbe Situation, mit der die \myMinin{core::ConcreteCommand}s klarkommen müssen, womit es nur ein kleines Problem ist.

      Als Parameter kann der \myMinin{Interpreter} eine Liste von \myMinin{any} Werten -- die einem \myMinin{string} zugewiesen sind -- annehmen, sowie zwei \myMinin{string}s (Makro und Makro Name). \myMinin{core::Command}s können nur eine Liste von \myMinin{any} Werten, die einem \myMinin{string} zugewiesen sind, annehmen. Drei \myMinin{any} Werte mehr in der Liste, als Makro, Makro Name und Datei löst das Problem der verschiedenen Anzahl von Parametern.

      Da Makros \myMinin{core::Command}s aufrufen können, sind sie auch in der Lage andere Makros aufzurufen (siehe \ref{enum:astbuffer}). Dadurch könnten Makros nicht nur zur Automatisierung genutzt werden, sondern auch zur internen Erweiterung der Applikation, dies ist allerdings eine schlechte Nutzung, da Makros langsamer sind, als reine C++ Funktionen oder \myMinin{Command}s. Allerdings ist ein wertvoller Vorteil dieser Kombinierbarkeit, dass Makros durch C++ Test-Frameworks ausgiebig getestet werden können.

%---------------------------------
% Exemplarische Realisierung
%---------------------------------
\section{Exemplarische Realisierung}
\label{sec:Exemplarische Realisierung}
  Um schnell Resultate zu sehen, wird die Implementierung nicht nur inkrementell, sondern auch test-driven \autocite{beck2003test} vorgenommen. Inkrementell bedeutet, dass nicht komplett vollständige Teile der Software genutzt werden, um abhängige Elemente zu entwickeln. Die inkrementelle Entwicklung von Software kommt aus der Agile Softwareentwicklung \autocite{cohen2003agile}. Dabei werden schnell Resultate gesehen. Zum Beispiel fallen Architektur Fehler schneller auf -- wodurch grundlegende Probleme frühzeitig beseitigen werden können.

  Test-driven bedeutet, dass es für `alle' Funktionen einen Test gibt, den sie bestehen müssen. Das hat zur Folge, dass wenn eine neue Softwarekomponente entwickelt wird, diese schon `ausprobiert' werden kann, ohne dass die Teile der Software existieren, die diese Komponente benutzten. Zudem sind Fehler leichter zu lösen, da diese erstens früh gefunden werden und zweitens deren Lösung durch Regressionstests auch auf Korrektheit überprüft werden können. Dadurch werden in den seltensten Fällen weitere Fehler durch Fehlerlösungen eingeführt. Test-driven bedeutet allerdings nicht, dass die Software am Ende komplett ausgetestet ist. Es bedeutet nur, dass Tests früher geschrieben werden, und dass es, im Vergleich zu anderen Entwicklungsmethoden, meistens mehr Tests gibt, die die Software auf Korrektheit überprüfen.

  In den folgenden Unterkapiteln wird der Ablauf für das Makro aus \autoref{fig:exmacro} durchgegangen. Die Reihenfolge ist die, die in \autoref{fig:abstractarch} schon beschrieben wurde.
  \begin{myCodeEnv}
    \centering
    \begin{myInvBox}[width=.9\linewidth]
      \lstinputlisting[style=MyMacroStyle]{code/exmacro.txt}
    \end{myInvBox}
    \caption{Beispiel für die exemplarische Realisierung}
    \label{fig:exmacro}
  \end{myCodeEnv}

  \columnratio{0.7}
  \columnsep25pt
  \footnotelayout{m}
  \begin{paracol}{2}[\subsection{Tokenizer}]
    %---------------------------------
    % Tokenizer
    %---------------------------------
    \label{ssec:Tokenizer}
      Der \myMinin{Tokenizer} verwandelt den Code aus \autoref{fig:exmacro} zu den \myMinin{Token}s, die in \autoref{fig:extok} zu sehen sind (abgesehen von dem Pointer, der auf die Quelltext Zeile zeigt).

      Um die \myMinin{Token}s zu erstellen, geht der \myMinin{Tokenizer} Zeichen für Zeichen vor.

      \paragraph{Whitespace}
        Zum Beginn vom tokenizen eines neuen Tokens, liest der \myMinin{Tokenizer} alle Whitespaces und verwirft diese. Wenn es sich bei dem Whitespace um einen Zeilenumbruch handelt, wird der Zähler für die momentane Zeile hochgezählt und der Spalten Zähler zurückgesetzt. Ansonsten wird nur der Spalten Zähler hochgezählt.

      \paragraph{Dezimalzahl}
        Wenn das Zeichen eine Zahl ist, probiert der \myMinin{Tokenizer} den Regex \myRIn$\d*\.\d+$ auf das aktuelle und die folgenden Zeichen anzuwenden. Integer werden als normale Token geparst. (Siehe \ref{enum:lexnumber} für Verbesserungen.)

      \paragraph{String}
        Wenn das momentane Zeichen ein \myRIn$"$ ist, werden alle Zeichen gelesen, bis ein weiteres \myRIn$"$ gefunden wird. Um das escapen von \myRIn$"$ zu unterstützen, wird die Anzahl, der aufeinander folgenden \myRIn$\\$ gezählt. Wenn es sich um eine ungerade Zahl handelt, ist das \myRIn$"$ escaped und wird nicht als String Ende angesehen. Das Ergebnis dieses Verfahrens ist in \autoref{fig:extok} Zeile 34 zu sehen. Ohne dieses Verfahren würde es drei \myMinin{Token}s geben, und der Whitespace wäre ``verloren'' gegangen.

      \paragraph{Besondere Token}
        Besondere Token sind zum Beispiel: \myRIn$==$ oder \myRIn$!=$. Für diese Token ist es nötig das folge Zeichen zu kennen, um zu entscheiden, was für ein Token die Zeichen darstellen sollen.

      \paragraph{Normale Token}
        Normale Token sind all die Zeichenketten, die dem Regex \myRIn$[a-zA-Z0-9_]$ genüge tun. Diese werden an dem Zeichen beendet, welche dem Regex nicht gleichen (also \myRIn$[^a-zA-Z0-9_]$).

    \switchcolumn
      \begin{myCodeEnv}
        \begin{myInvBox}[width=.9\linewidth]
          \lstinputlisting[]{code/extok.txt}
        \caption{Tokenized Makro / TokenList}
        \label{fig:extok}
        \end{myInvBox}
      \end{myCodeEnv}
  \end{paracol}

  \paragraph{Token Erstellung}
    Ein \myMinin{Token} wird mit der Zeile und Spalte, in der es beginnt, und dem Token (zB. \myMIn$"1 "$) initialisiert. Ebenso wird dem \myMinin{Token} ein Pointer auf einen (momentan) leeren String mitgegeben. Am Ende einer Zeile wird diesem, leeren String, dann die gesamte Zeile zugewiesen. Da es sich um einen Pointer handelt, wird die Zeile allen \myMinin{Token}s, aus der Zeile, gleichzeitig zugewiesen. Der Pointer, den der \myMinin{Tokenizer} hat, wird durch einen neuen Pointer, auf einen leeren String ersetzt, um diesen den nächsten \myMinin{Token}s, aus der nächsten Zeile, zu geben.

  %---------------------------------
  % Parser
  %---------------------------------
  \subsection{Parser}
  \label{ssec:Parser}
    Der \myMinin{Parser} arbeitet intern mit der \myMinin{TokenList} und gibt den einzelnen Funktionen diese, sowie den aktuellen Index(\myMinin{size_t}/\myMinin{unsigned int}). Da der Index so wie die \myMinin{TokenList} nur als Referenz übergeben wird, erstellen die einzelnen Methoden eine Kopie von dem Index, bevor sie anfangen zu arbeiten. Die Kopie des Indexes sorgt dafür, dass wenn ein Fehler, in einem Unter-UnterFunktionsaufruf auftritt, die aufrufenden Funktionen noch `wissen', welches \myMinin{Token} sie am Anfang bekommen haben und so gute Fehlermeldungen produzieren können. Das die Indexe als Referenz übergeben wurden, liegt daran, dass es zwar möglich ist, mehrere Rückgabewerte unterschiedlichen Typs zu haben (\myMinin{std::pair<T1,T2>} oder \myMinin{std::tuple<T1, T2, ... Tn>}), dies aber ein schlechteres Interface bieten würde.

    Der \myMinin{Parser} fängt mit einem \myMinin{ast::Scope} als root Node des Baumes an. Im Anschluss daran, werden die \myMinin{Token}s nach einander geparst. Die Funktionen, die das Parsen übernehmen, implementieren die Syntax aus \autoref{ssec:Syntax}.

    Die erzeugte AST Struktur -- von dem root \myMinin{ast::Scope} -- ist in \autoref{fig:exastroot} zu sehen. Diese, wie alle folgenden AST Strukturen, sind von dem Parser und durch den Stream (Bit-Shift) Operator, von den AST Elementen generiert worden. Das Ausgeben der Datenstruktur wurde den \myMinin{pod} Klassen hinzugefügt, um diese leichter entwickeln und debuggen zu können. Da der AST zu viel eingerückt und zu lang für eine Seite ist, werden nur Ausschnitte gezeigt, die aus dem Beispiel (\autoref{fig:exmacro}) generiert wurden.
    \begin{paracol}{2}
      \begin{myCodeEnv}
        \centering
        \begin{myInvBox}[width=.9\linewidth]
          \lstinputlisting{code/exastroot.txt}
        \end{myInvBox}
        \caption{Root Scope des Beispieles}
        \label{fig:exastroot}
      \end{myCodeEnv}
      \switchcolumn
      \begin{myCodeEnv}
        \centering
        \begin{myInvBox}[width=.9\linewidth]
          \lstinputlisting[lastline=4]{code/extok.txt}
        \end{myInvBox}
        \caption*{Aktuelle \myMinin{TokenList}}
      \end{myCodeEnv}
      \myQuestion{Ich hoffe das ich hier die Regel `brechen' darf -- Ich behaupte das dies `eine' Abbildung ist und somit \autoref{fig:exastroot} für `beide' reicht\ldots}
    \end{paracol}

    %---------------------------------
    % Definition parsen
    %---------------------------------
    \subsubsection{Definition parsen}
    \label{sssec:Definition parsen}
      Um ein \myMinin{ast::Define} Objekt zu erzeugen, erwartet die \myMinin{Parser} Methode, dass das momentane \myMinin{Token} entweder \myRIn$def$ entspricht, oder \myRIn$var$.

      Um \myMinin{ast::Funktion} zu parsen, erwartet die Methode, dass das momentane \myMinin{Token} \myRIn$def$ entspricht -- \myRIn$var$ um eine \myMinin{ast::Variable} zu parsen. Wenn keiner der beiden Fälle eintritt, wird \myMinin{false} zurückgegeben -- alle Methoden zum Parsen verhalten sich so. Das \myMinin{false}, anstelle von einem \myMinin{ast::Define} Objekt zurückgeben werden kann, wird durch den \myMinin{optional<T>} Typ erreicht \autocite{cpp-fundamentals}.

      \paragraph{Funktion}
        Wenn \myRIn$def$ geparst wurde, wird die \myMinin{TokenList} an die Funktion für \myMinin{ast::Funtion} übergeben. Diese erwartet, als aktuelles \myMinin{Token} einen Bezeichner (siehe \autoref{fig:idsyntax}) und, dass das nächste eine offene Klammer \myRIn$\($ ist. Nach der Klammer kann eine beliebige Anzahl von Komma getrennten Bezeichnern angegeben werden. Diese werden dem \myMinin{ast::Function} Objekt als Array von \myMinin{ast::Variable} Objekten übergeben. Nach den Parametern wird eine geschlossene Klammer \myRIn$\)$ erwartet. Zuletzt wird die Funktion zum parsen von \myMinin{ast::Scope} aufgerufen und das Ergebnis in dem \myMinin{ast::Function} Objekt gesetzt.

        Wenn Fehler beim parsen auftreten -- zum Beispiel, dass kein Bezeichner oder das \myMinin{ast::Scope} fehlt -- schmeißt die Methode eine Exception, die bis zu der \myMinin{static} globalen Methode hoch wandert. Das parsen der Funktion ist von einem \myMinin{try-catch} Block umschlossen -- sollte also eine Exception geworfen werden, wird diese gefangen, und mit dem Dateinamen, Zeile, Spalte und Quellcode der Zeile erweitert, um dann wieder geworfen zu werden.

        Das Ergebnis, von dem Beispiel (\myMIn$def fun(foo) {$), ist in \autoref{fig:exastfundef} zu sehen, \myMinin{ast::Define} (Zeile 1) enthält die \myMinin{ast::Function} (Zeile 3) mit ihren Parametern (Zeile 5 ff.) und dem Funktionsscope (Zeile 9).

        \begin{paracol}{2}
          \begin{myCodeEnv}
            \centering
            \begin{myInvBox}[width=.9\linewidth]
              \lstinputlisting{code/exastfundef.txt}
            \end{myInvBox}
            \caption{Funktionsdefinition des Beispiels}
            \label{fig:exastfundef}
          \end{myCodeEnv}
          \switchcolumn
          \begin{myCodeEnv}
            \centering
            \begin{myInvBox}[width=.9\linewidth]
              \lstinputlisting[firstline=1,lastline=13]{code/extok.txt}
            \end{myInvBox}
            \caption*{Aktuelle \myMinin{TokenList}}
          \end{myCodeEnv}
        \end{paracol}

      \paragraph{Variable}
        Wenn das geparste \myMinin{Token} \myRIn$var$ war, wird die \myMinin{TokenList} an die Funktion für \myMinin{ast::Variable} übergeben. Diese erwartet, als aktuelles \myMinin{Token}, nur einen Bezeichner. Es ist also wichtig, dass zuerst probiert wird eine \myMinin{ast::Funktion} zu parsen und erst im Anschluss eine \myMinin{ast::Variable}.

        Vermutlich, entgegen der Erwartungshaltung des Lesers, wird hier nicht die Zuweisung behandelt, dies geschieht bei der \myMinin{ast::Operator} Funktion. Im Verlauf der Erklärung, wie Operatoren geparst werden, sollte es offensichtlich werden, wieso dies so ist.

        Wie bei der Methode zum parsen von \myMinin{ast::Function}, befindet sich die Logik dieser Methode in einem \myMinin{try-catch} Block.

    %---------------------------------
    % Scope parsen
    %---------------------------------
    \subsubsection{Scope parsen}
    \label{sssec:Scope parsen}
      Die \myMinin{ast::Scope} Klasse ist eine der meist verwendeten Klassen aus dem \myMinin{ast} Paket. Die \myMinin{ast::Scope} Klasse macht sich \myMinin{variant<T1, T2, ..., Tn>} \autocite{cpp-variant} zu Nutze -- \myMinin{variant} ist eine typsichere Union. Der \myMinin{variant} Typ des \myMinin{ast::Scope}s hat, als Templateparameter, alle \myMinin{ast} Typen, die in einem Loop Scope auftreten können (\autoref{fig:loopscopesyntax}).

      Die \myMinin{Parser} Methode erwartet, dass das aktuelle \myMinin{Token} \myRIn$\{$ entspricht. Wenn dem so ist, werden so lange alle \myMinin{ast} Klassen probiert geparst zu werden, bis ein \myMinin{Token} nicht aufgelöst werden kann. Dies ist entweder der Fall, wenn das Token \myRIn$\}$ ist -- somit dieses \myMinin{ast::Scope} schließt -- oder ein unerwartetes Token ist. Im letzteren Fall wird eine Excpetion geschmissen. Wenn eine Methode ein validen Wert zurück gibt, wird das Objekt dem Array des \myMinin{ast::Scope}s als Node hinzugefügt.

      Ähnlich wie in dem Railroad Diagramm aus \autoref{fig:commonsyntax}, müssen einige \myMinin{ast} Elemente mit einem \myRIn$;$ gefolgt werden, da sie auch in einem Kontext eingesetzt werden können, in dem kein \myRIn$;$ benötigt ist. Diese Token werden durch das Scope gelesen und finden sich nicht im AST wieder, da sie keinen weiteren Wert haben. Sollten sie fehlen, wodurch Statements nicht zuverlässig geparst werden können, wird eine Exception geschmissen.

      Die parse Methode des \myMinin{ast::Scope}s ist relativ simpel, da hier nur die richtige Reihenfolge der Methoden eingehalten und bei bestimmten \myMinin{ast} Elementen ein \myRIn$;$ gelesen werden muss. \myMinin{ast::Variable} muss zum Beispiel als letztes probiert geparst zu werden, da diese nur einen Bezeichner brauchen, welcher auch zu einem Funktionsaufruf gehören kann.

      Das geparste \myMinin{ast::Scope} der \myMIn$def fun(foo) {$ Methode ist in \autoref{fig:exastfunscope} zu sehen.

      \begin{paracol}{2}
        \begin{myCodeEnv}
          \centering
          \begin{myInvBox}[width=.9\linewidth]
            \lstinputlisting{code/exastfunscope.txt}
          \end{myInvBox}
          \caption{Funktionsscope des Beispiels}
          \label{fig:exastfunscope}
        \end{myCodeEnv}
        \switchcolumn
        \begin{myCodeEnv}
          \centering
          \begin{myInvBox}[width=.9\linewidth]
            \lstinputlisting[firstnumber=6,firstline=6,lastline=14]{code/extok.txt}
          \caption*{Aktuelle \myMinin{TokenList}}
          \end{myInvBox}
        \end{myCodeEnv}
      \end{paracol}

    %---------------------------------
    % do-while parsen
    %---------------------------------
    \subsubsection{do-while parsen}
    \label{sssec:do-while parsen}
      In Zeile 2 des Beispiels, wird ein \myMinin{do-while} Schleife definiert. Der \myMinin{Parser} guckt bei \myMinin{ast::DoWhile} nach dem \myRIn$do$, erwartet im Anschluss ein Scope, das wiederum von einem \myRIn$while$, einer \myMinin{ast::Condition} und \myRIn$;$ gefolgt wird.

      Ähnlich wie bei der Funktionsdeklaration, befindet sich die Logik dieser Methode in einem \myMinin{try-catch} Block.

      \autoref{fig:exastdowhile} zeigt den geparsten AST für den \myMinin{ast::DoWhile}.
      \begin{paracol}{2}
        \begin{myCodeEnv}
          \centering
          \begin{myInvBox}[width=.9\linewidth]
            \lstinputlisting{code/exastdowhile.txt}
          \end{myInvBox}
          \caption{do-while Schleife des Beispiels}
          \label{fig:exastdowhile}
        \end{myCodeEnv}
        \switchcolumn
        \begin{myCodeEnv}
          \centering
          \begin{myInvBox}[width=.9\linewidth]
            \lstinputlisting[firstnumber=7,firstline=7,lastline=20]{code/extok.txt}
          \end{myInvBox}
          \caption*{Aktuelle \myMinin{TokenList}}
        \end{myCodeEnv}
      \end{paracol}


    %---------------------------------
    % Operator und Condition parsen
    %---------------------------------
    \subsubsection{Operator und Condition parsen}
    \label{sssec:Operator und Condition parsen}
      Der Unterschied zwischen dem Parsen, von einem Operator und einer Condition ist, dass Operatoren geparst werden, wenn der linke Teil des Operators (im Fall, dass es sich um einen binären Operator handelt), schon geparst ist. Die Logik der \myMinin{ast::Operator} parse Methode muss dies berücksichtigen -- die \myMinin{ast::Condition} parse Methode nutzt intern die \myMinin{ast::Operator} Methode, um Operatoren zu unterstützen. Abgesehen von diesem Unterschied, können die beiden Methoden gleich behandelt werden.

      Wenn der \myMinin{Parser} \myMinin{ast::Operator}en parsed, passiert dies in zwei Schritten. Im ersten Schritt werden alle \myMinin{ast} Elemente (Operatoren und Werterzeuger) erstellt, die der \myMinin{Paser} aus den \myMinin{Token}s erstellen kann. Diese sind nach dem parsen allerdings nur als eine Liste angeordnet, da der \myMinin{Parser} nicht wissen kann, in welcher Reihenfolge er die \myMinin{Token}s zusammenzusetzen hat. Die Liste wird dann, in dem zweiten Schritt, in einen Baum verwandelt. Das geschieht, in dem der Parser einen \myMinin{ast::Operator} mit seinen jeweiligen Operanden verbindet. Dabei wird die Präzedenz bzw. Reihenfolge, die in \autoref{fig:opsyntax} zu sehen ist, angewendet bzw. erstellt.

      Operatoren richtig zu parsen ist eine der schwierigsten Aufgaben, beim Bau eines Parsers, da der zweite Schritt nicht nur die Präzedenz der Operatoren berücksichtigen muss, sondern auch die Auflösungsreihenfolge. Mit Ausnahme von dem Assignmentoperator, werden alle Binärenoperatoren von links nach rechts zusammengesetzt. Alle Unärenoperatoren werden von rechts nach links zusammengesetzt. Alle \myMIn$+$ und \myMIn$-$ Operatoren sind zu Beginn unär, und werden während des zweiten Schritts zu Binärenoperatoren, wenn sich ein Werterzeuger vor ihnen befindet. Operatoren, die kein Operanden haben, sind in diesem Fall keine Werterzeuger.

      Beide Methoden umschließen ihre Logik mit einem \myMinin{try-catch} Block, um Informationen zu dem Kontext des Fehlers zu liefern.

      \paragraph{Binäroperator}
        In Zeile 3, des Beispieles (\myMIn$foo = foo + 1.1;$), sieht man den Fall, in dem der linke Operand von dem \myMinin{ast::Operator} schon geparst ist. \myMinin{foo} wurde als Variable geparst, da dieser Parser ohne Vorausschauen implementiert wurde. Als nächstes Token ist \myTIn$=$ in der Liste, was das parsen von einem binären Operator indiziert.

        Die \myMinin{ast::Operator} Methode erwartet, dass -- in dem Fall, dass es sich um einen binären Operatoren handelt -- das zuletzt geparste Element ein Werterzeuger ist (\autoref{fig:vprsyntax}). Dieses wird als linkes Element des \myMinin{ast::Operator} gesetzt. Als nächstes erwartet die Methode, dass das nächste \myMinin{Token} auch ein Werterzeuger ist.

        Werterzeuger werden in dem \myMinin{ast::Operator}, sowie in anderen Klassen, die Werterzeuger als Attribute haben, als \myMinin{variant} gespeichert. Das die Werterzeuger, in einem \myMinin{variant} gespeichert werden, spiegelt sich nicht in dem generierten Text des AST wieder.

        Die Datenstruktur nach dem ersten Schritt zeigt \autoref{fig:exastdowhilescopehalf}.
        \columnratio{0.475}
        \begin{paracol}{2}
          \begin{myCodeEnv}
            \centering
            \begin{myInvBox}[width=.9\linewidth]
              \lstinputlisting{code/exastdowhilescopehalf.txt}
            \end{myInvBox}
            \caption{Erster Schritt der Variablen Addition des Beispiels}
            \label{fig:exastdowhilescopehalf}
          \end{myCodeEnv}
          \switchcolumn
          \begin{myCodeEnv}
            \centering
            \begin{myInvBox}[width=.9\linewidth]
              \lstinputlisting{code/exastdowhilescopehalftwo.txt}
            \end{myInvBox}
            \caption{Halber zweiter Schritt der Variablen Addition des Beispiels}
            \label{fig:exastdowhilescopehalftwo}
          \end{myCodeEnv}
        \end{paracol}
        \columnratio{0.7}

        In dem zweiten Schritt wird die Liste von links, bis zu dem \myMIn$+$, durchgegangen. Beim zusammensetzen des \myMIn$+$ greift dieses auf \myMIn$foo$ und auf den Double zu. Anschließend wird die Liste von rechts nach links, bis zu dem \myMIn$=$, durchgegangen. Der \myMIn$=$ Operator greift dann, auf \myMIn$foo$ und den \myMIn$+$ Operator zu, der das andere \myMIn$foo$ und den Double enthält, was in \autoref{fig:exastdowhilescopehalftwo} zu sehen ist. Der generierte AST ist in \autoref{fig:exastdowhilescope} zu sehen.
        \begin{paracol}{2}
          \begin{myCodeEnv}
            \centering
            \begin{myInvBox}[width=.9\linewidth]
              \lstinputlisting{code/exastdowhilescope.txt}
            \end{myInvBox}
            \caption{Variablen Addition des Beispiels}
            \label{fig:exastdowhilescope}
          \end{myCodeEnv}
          \switchcolumn
          \begin{myCodeEnv}
            \centering
            \begin{myInvBox}[width=.9\linewidth]
              \lstinputlisting[firstnumber=9,firstline=9,lastline=29]{code/extok.txt}
            \end{myInvBox}
            \caption*{Aktuelle \myMinin{TokenList}}
          \end{myCodeEnv}
        \end{paracol}

      \paragraph{Unäroperator}
        Im Fall, dass es sich um einen Unärenoperator handelt, wird der Operator gelesen (\myRIn$\+|\-|!|print|typeof$) und im Anschluss ein Werterzeuger erwartet.

        Die \autoref{fig:exastdowhilecon} zeigt die geparste \myMinin{ast::Condition} aus Zeile 4 des Beispiels (\myMIn$} while(!foo);$).
        \begin{paracol}{2}
          \begin{myCodeEnv}
            \centering
            \begin{myInvBox}[width=.9\linewidth]
              \lstinputlisting{code/exastdowhilecon.txt}
            \end{myInvBox}
            \caption{do-while Condition des Beispiels}
            \label{fig:exastdowhilecon}
          \end{myCodeEnv}
          \switchcolumn
          \begin{myCodeEnv}
            \centering
            \begin{myInvBox}[width=.9\linewidth]
              \lstinputlisting[firstnumber=17,firstline=17,lastline=25]{code/extok.txt}
            \end{myInvBox}
            \caption*{Aktuelle \myMinin{TokenList}}
          \end{myCodeEnv}
        \end{paracol}


    %---------------------------------
    % Literals parsen
    %---------------------------------
    \subsubsection{Literals parsen}
    \label{sssec:Literals parsen}
      Um Literals zu parsen, wendet der \myMinin{Parser} für String \myRIn$".*"$, Integer \myRIn$\d+$, Doubles \myRIn$\d*\.\d+$ und Booleans \myRIn$true|false$ als Regex an, um zu erkennen, ob ein \myMinin{Token} ein Literal beschreibt. Für den String reicht in diesem Fall der Regex aus, da der \myMinin{Tokenizer} den String als ein \myMinin{Token} produziert hat.

      \begin{lrbox}{\myMinSavBox}
        \myMinin{"t\\tt"}$\rightarrow$\myMinin{"t\tt"}
      \end{lrbox}

      Um die nummerischen Tokens zu Werten zu konvertieren (lexen), nutzt der \myMinin{Parser} die C++ Funktionen \myMinin{std::stod(...)} und \myMinin{std::stoi(...)}. Für die Booleanwerte reicht die Überprüfung, ob das \myMinin{Token} ein Boolean darstellt. Und der String wird kopiert und anschließend werden alle escapeden Zeichen unescaped (\myMinin{"t\tt"}$\rightarrow$\myMinin{"t  t"}\footnote{
        In C++ sieht es so aus: \usebox{\myMinSavBox}.
      }).

      Der Double aus Zeile 3 des Beispiels, ist in \autoref{fig:exastdowhilescopedouble} zu sehen.
      \begin{paracol}{2}
        \begin{myCodeEnv}
          \centering
          \begin{myInvBox}[width=.9\linewidth]
            \lstinputlisting{code/exastdowhilescopedouble.txt}
          \end{myInvBox}
          \caption{Double Literal des Beispiels}
          \label{fig:exastdowhilescopedouble}
        \end{myCodeEnv}
        \switchcolumn
        \begin{myCodeEnv}
          \centering
          \begin{myInvBox}[width=.9\linewidth]
            \lstinputlisting[firstnumber=13,firstline=13,lastline=17]{code/extok.txt}
          \end{myInvBox}
          \caption*{Aktuelle \myMinin{TokenList}}
        \end{myCodeEnv}
      \end{paracol}

    %---------------------------------
    % Return parsen
    %---------------------------------
    \subsubsection{Return parsen}
    \label{sssec:Return parsen}
      Return ist leicht zu parsen, da es nur einen Werterzeuger, nach dem Keyword \myRIn$return$ erwartet.

      Wie einige andere Methoden zuvor, umschließt die \myMin{ast::return} Methode die Logik mit einem \myMinin{try-catch} Block.

      \autoref{fig:exastreturn} zeigt Zeile 6 des Beispiels.
      \begin{paracol}{2}
        \begin{myCodeEnv}
          \centering
          \begin{myInvBox}[width=.9\linewidth]
            \lstinputlisting{code/exastreturn.txt}
          \end{myInvBox}
          \caption{return Statement des Beispiels}
          \label{fig:exastreturn}
        \end{myCodeEnv}
        \switchcolumn
        \begin{myCodeEnv}
          \centering
          \begin{myInvBox}[width=.9\linewidth]
            \lstinputlisting[firstnumber=22,firstline=22,lastline=27]{code/extok.txt}
          \end{myInvBox}
          \caption*{Aktuelle \myMinin{TokenList}}
        \end{myCodeEnv}
      \end{paracol}

    %---------------------------------
    % Funktionsaufruf parsen
    %---------------------------------
    \subsubsection{Funktionsaufruf parsen}
    \label{sssec:Funktionsaufruf parsen}
      Um den Funktionsaufruf in Zeile 12 des Beispieles (\myMIn$return fun(foo:foo);$) zu parsen, erwartet die \myMinin{ast::Callable} Funktion, dass das erste \myMinin{Token} ein Bezeichner ist und darauf folgend (ohne Abstand) sich ein \myRIn$\($ befindet. Anschließend wird eine Komma getrennte Liste von Parameternamen zu Werterzeugern erwartet. Dabei ist der Parametername von dem Werterzeuger durch ein \myRIn$:$ getrennt. Auf diese Liste muss eine \myRIn$\)$ folgen.

      Auch diese Methode umschließt die Logik mit einem \myMinin{try-catch} Block.

      \autoref{fig:exastcall} zeigt das Ergebnis aus der Zeile 12 des Beispieles.
      \begin{paracol}{2}
        \begin{myCodeEnv}
          \centering
          \begin{myInvBox}[width=.9\linewidth]
            \lstinputlisting{code/exastcall.txt}
          \end{myInvBox}
          \caption{Funktionsaufruf des Beispiels}
          \label{fig:exastcall}
        \end{myCodeEnv}
        \switchcolumn
        \begin{myCodeEnv}
          \centering
          \begin{myInvBox}[width=.9\linewidth]
            \lstinputlisting[firstnumber=36,firstline=36,lastline=45,showlines=true]{code/extok.txt}
          \end{myInvBox}
          \caption*{Aktuelle \myMinin{TokenList}}
        \end{myCodeEnv}
      \end{paracol}

    %---------------------------------
    % Analyser
    %---------------------------------
    \subsubsection{Analyser}
    \label{sssec:Analyser}
      Nach dem der \myMinin{Parser} den AST geparst hat, nutzt dieser den \myMinin{Analyser}, um herauszufinden, ob sich in dem Baum Konstrukte befinden, die unerwünscht sind. Zum Beispiel, dass die \myMinin{main(...)} Methode manuell aufgerufen wird.

      Wie zuvor beschrieben (siehe \autoref{sssec:Analyser Architektur}) nutzt der \myMinin{Analyser} ein Signal/Visitor System\footnote{
        Das Signal System ist eine vorhandene Firmenbibliothek und wurde somit nicht während der Arbeit entwickelt.
      }, um bei jedem beliebigen Element, Funktionen auszuführen. In dem Fall, dass überprüft werden soll, ob die \myMinin{main()} Methode manuell aufgerufen wird, reicht es aus sich bei dem Signal anzumelden, welches \myMinin{ast::Callable} signalisiert. In der Funktion, die das Signal ausführt, wird dann überprüft, ob das \myMinin{Token} \myRIn$main$ gleicht. Wenn dem so ist, ist der AST nicht kompatible und eine Fehlermeldung wird in dem \myMinin{Analyser} zu der Fehlerliste hinzugefügt. Wenn der AST durchlaufen ist, und somit alle Prüfungen ausgeführt wurden, wird die Fehlerliste an den \myMinin{Parser} übergeben. Dieser schmeißt die Fehlerliste dann als Exception.

      Der \myMinin{Analyser} baut während des Ablaufen des AST auch einen Stack auf. Dieser Stack gleicht dem des Interpreters, ist aber nur eine Liste von \myMinin{Token}s, da die Variablen und Funktionen nur auf Existenz geprüft werden müssen. Beim Prüfen, ob alle Variablen existieren, wird nachgesehen, ob in der Liste von Variablen ein \myMinin{Token} dem der \myMinin{ast::Variable} gleicht.

      Ein Fehler den der \myMinin{Analyser} nicht prüfen kann ist, dass eine Funktion nicht existiert. Da der \myMinin{Interpreter} auf den \myMinin{CommandProvider} zugreift, um Funktionen zu finden, und diese Funktionen durchaus durch ein Makro registriert werden können, ist ein solcher Fehler erst zur Laufzeit zu finden.

  %---------------------------------
  % Interpreter
  %---------------------------------
  \subsection{Interpreter}
  \label{ssec:Interpreter}
    Der \myMinin{Interpreter} durchläuft den AST, wie der \myMinin{Analyser}, recursive decent. Anstelle, dass der Interpreter Signale bei den AST Elementen ausführt, setzt der \myMinin{Interpreter} die Elemente um. Der \myMinin{Interpreter} ist durch die Nutzung von \myMinin{Stack} und \myMinin{OperatorProvider} eine der kleinsten Klassen -- abgesehen von den Klassen aus dem \myMinin{pod} Paket.


    %---------------------------------
    % Scope Interpretierung
    %---------------------------------
    \subsubsection{Scope Interpretierung}
    \label{sssec:Scope Interpretierung}
      Bevor ein \myMinin{ast::Scope} interpretiert werden kann, erweitert der \myMinin{Interpreter} den \myMinin{Stack}, mit einem weiteren \myMinin{Stack} Objekt. Dieses repräsentiert das \myMinin{ast::Scope}, indem es Variablen und Funktionsdefinitionen verwaltet.

      Um ein \myMinin{ast::Scope} zu interpretieren, führt der \myMinin{Interpreter} zuerst alle Funktionsdeklarationen durch. Im Anschluss, geht der \myMinin{Interpreter} die \myMinin{ast} Elemente in dem \myMinin{ast::Scope} durch und interpretiert sie. Im Anschluss an das interpretieren des root \myMinin{ast::Scope}s, wird die \myMinin{main()} Methode von dem \myMinin{Interpreter} aufgerufen.

      \autoref{fig:int1} zeigt die Startsituation des Interpreter Stacks.
      \begin{figure}[H]
        \centering
        \myInput{img/int1.tikz}
        \caption{Root \myMinin{Stack}}
        \label{fig:int1}
      \end{figure}

    %---------------------------------
    % Funktionsdeklarationen
    %---------------------------------
    \subsubsection{Funktionsdeklarationen}
    \label{sssec:Funktionsdeklarationen}
      Bei Funktionsdeklarationen, fügt der \myMinin{Interpreter} dem \myMinin{Stack} eine Referenz des \myMinin{ast::Funciton} Objektes, aus dem AST hinzu. Da es sich um eine Referenz handelt, wird hier nicht kopiert. \autoref{fig:int2} und \autoref{fig:int3} zeigen den \myMinin{Stack}, nach den jeweiligen Funktionsdeklarationen.
      \begin{figure}[H]
        \centering
        \begin{minipage}{.45\linewidth}
            \begin{figure}[H]
              \centering
              \myInput{img/int2.tikz}
              \caption{\myMinin{Stack} nach der \myMinin{fun(foo)} Deklaration}
              \label{fig:int2}
            \end{figure}
        \end{minipage}%
        \begin{minipage}{.45\linewidth}
          \begin{figure}[H]
            \centering
            \myInput{img/int3.tikz}
            \caption{\myMinin{Stack} nach der \myMinin{main()} Deklaration}
            \label{fig:int3}
          \end{figure}
        \end{minipage}
      \end{figure}


    %---------------------------------
    % Variablendeklarationen
    %---------------------------------
    \subsubsection{Variablendeklarationen}
    \label{sssec:Variablendeklarationen}
      Bei einer Variablendeklarationen, wird die \myMinin{std::map}, des \myMinin{Stack}s, um einen String und ein \myMinin{any} Objekt erweitert (siehe \autoref{enum:betterruntimeerrors}).

      In \autoref{fig:int5} ist die Variablendeklaration, und in \autoref{fig:int6} die anschließende Initialisierung, der Variable aus der \myMinin{main()} Methode zu sehen.
      \begin{figure}[H]
        \centering
        \begin{minipage}{.45\linewidth}
          \begin{figure}[H]
            \centering
            \myInput{img/int5.tikz}
            \caption{\myMinin{Stack} nach Variablendeklaration}
            \label{fig:int5}
          \end{figure}
        \end{minipage}%
        \begin{minipage}{.45\linewidth}
          \begin{figure}[H]
            \centering
            \myInput{img/int6.tikz}
            \caption{\myMinin{Stack} nach Variableninitialisierung}
            \label{fig:int6}
          \end{figure}
        \end{minipage}
      \end{figure}

    %---------------------------------
    % Funktionsaufruf
    %---------------------------------
    \subsubsection{Funktionsaufruf}
    \label{sssec:Funktionsaufruf}
      Bei dem Funktionsaufruf (\myMinin{return fun(foo:foo);}), fragt der \myMinin{Interpreter} als erstes den \myMinin{Stack}, nach einer Referenz eines \myMinin{ast::Function} Objektes, welches dem Funktionsaufruf gleicht. Es muss also eine Funktion definiert worden sein, die vom Bezeichner \myRIn$fun$ gleicht und einen Parameter namens \myRIn$foo$ besitzt. Im Anschluss erstellt der \myMinin{Interpreter} einen neuen \myMinin{Stack}, der den root \myMinin{Stack} als Pointer hat -- siehe \autoref{fig:intstack}. Wenn der neue \myMinin{Stack} den \myMinin{main()} \myMinin{Stack} als Pointer hätte, könnte der neue \myMinin{Stack} direkt auf alle Variablen aus der \myMinin{main()} Methode zugreifen. Dem neuen \myMinin{Stack} wird dann ein Alias names \myMinin{foo} hinzugefügt, der auf die \myMinin{foo} Variable aus dem \myMinin{main()} \myMinin{Stack} zeigt, dies ist in \autoref{fig:int8} zu sehen. Nachdem der \myMinin{Stack} vorbereitet ist, wird das \myMinin{ast::Scope} der Funktionsdeklaration interpretiert.

      \begin{figure}[H]
        \centering
        \myInput{img/intstack.tikz}
        \caption{\myMinin{Stack} Verbindungen}
        \label{fig:intstack}
      \end{figure}


      Sollte der \myMinin{Stack} keine passende Funktion haben, greift der \myMinin{Interpreter} auf den \myMinin{core::CommandProvider} zurück. Wenn dieser ein \myMinin{core::Command} zurück gibt, werden diesem die Argumente übergeben. Wenn der \myMinin{core::CommandProvider} auch kein passendes \myMinin{core::Command} für den Funktionsaufruf hat, wird eine Exception geschmissen, was zum Ende des Interpretierens führt. Da der Interpreter recursive decent implementiert ist, wird durch den Funktionsstack wieder ein Stack von Fehlermeldungen aufgebaut, der den Nutzer zu der Problemquelle führt.
      \begin{figure}[H]
        \centering
        \myInput{img/int8.tikz}
        \caption{\myMinin{Stack} am Anfang der \myMinin{fun} Methode}
        \label{fig:int8}
      \end{figure}

    %---------------------------------
    % Do-While
    %---------------------------------
    \subsubsection{Do-While}
    \label{sssec:Do-While}
      Ein \myMinin{ast::DoWhile} wird interpretiert, in dem das \myMinin{ast::Scope} ausgeführt wird und im Anschluss die \myMinin{ast::Condition} ausgewertet wird. Sollte die das Ergebnis \myMinin{true} sein, wir das \myMinin{ast::Scope} wieder ausgeführt und am Ende wieder die \myMinin{ast::Condition} geprüft.

      Während der Ausführung ist es möglich, dass \myMinin{return} oder zB. \myMinin{break} aufgerufen wird. Wenn eines dieser beiden Elemente interpretiert wird, wird eine Flag gesetzt, die der \myMinin{DoWhile} Methode mitteilt, das der Loop unterbrochen wird. Diese Logik findet sich in allen \myMinin{ast::Loop} und der \myMinin{ast::Scope} Methode wieder.

    %---------------------------------
    % Operator
    %---------------------------------
    \subsubsection{Operator}
    \label{sssec:Operator}
      Um \myMinin{ast::Operator} Objekte zu interpretieren, löst der \myMinin{Interpreter} die Werterzeuger soweit auf, das zwei \myMinin{any} Werte hat. Diese Werte werden, mit dem Operator als \myMinin{enum}, an den \myMinin{OperatorProvider} zum evaluieren gegeben.

      Der \myMinin{OperatorProvider} nutzt die Typinformation des \myMinin{any} Typs (\myMinin{typeid(T)}) um die richtige Funktion für die beiden Typen zu finden. Wenn keine passende Funktion gefunden wird, wird eine Exception geschmissen, ansonsten werden die Werte an die Funktion gegeben und das Ergebnis an den \myMinin{Interpreter} retuned. In dem Fall des Beispieles (\myMinin{foo = foo + 1.1;}) wird die Funktion für \myMinin{string} und \myMinin{double} gesucht, die diese Typen addieren kann.

      Der Assignmentoperator wird nicht von dem \myMinin{OperatorProvider} angeboten, da dieser abhängig von dem \myMinin{Stack} State ist. Wenn die Variable ein Alias ist (wie in dem Fall des Beispieles -- siehe \autoref{fig:int8}), muss dieser gelöscht werden und durch eine `echte' Variable ersetzt werden, bevor der Wert verändert werden kann.

      Die \autoref{fig:int9} zeigt das Ergebnis der zwei Operatoren -- der \myMinin{Stack} von dem \myMinin{DoWhile} wurde ausgelassen, da dieser leer bleibt und deshalb als Proxy zu \myMin{Stack 2} dient.
      \begin{figure}[H]
        \centering
        \myInput{img/int9.tikz}
        \caption{\myMinin{Stack} nach dem Assignmentoperator der \myMinin{fun} Methode}
        \label{fig:int9}
      \end{figure}


    %---------------------------------
    % Return
    %---------------------------------
    \subsubsection{Return}
    \label{sssec:Return}
      Um ein \myMinin{ast::Return} zu interpretieren, interpretiert der \myMinin{Interpreter} den Werterzeuger soweit aus, dass er ein \myMinin{any} Objekt erhält. In jedem Fall, kann dieses Objekt aus der Funktion gemoved \autocite[S.268 ff.]{C++14-std} werden, was gut für die Performance des \myMinin{Interpreter}s ist.

      \autoref{fig:int10} zeigt den Zustand nach dem returnen aus \myMinin{fun(foo)}.
      \begin{figure}[H]
        \centering
        \myInput{img/int10.tikz}
        \caption{\myMinin{Stack} nach dem \myMinin{return} der \myMinin{fun} Methode}
        \label{fig:int10}
      \end{figure}

  %---------------------------------
  % Fehlermeldungen
  %---------------------------------
  \subsection{Fehlermeldungen}
  \label{ssec:Fehlermeldungen}
    Wenn in Zeile 3 das \myRIn$;$ vergessen wird, erhält man die Fehlermeldung aus \autoref{fig:error2} -- diese Fehlermeldung wird von dem \myMinin{Parser} ausgegeben und führt dazu, dass das parsen abgebrochen wird.

    \begin{myCodeEnv}
      \centering
      \begin{myInvBox}[width=.9\linewidth]
        \lstinputlisting{code/error2.txt}
      \end{myInvBox}
      \caption{Fehler bei unbekannter Variable}
      \label{fig:error2}
    \end{myCodeEnv}

    Eine Fehlermeldung von dem \myMinin{Analyser} ist in \autoref{fig:error1} zu sehen -- weder in dem root \myMinin{ast::Scope}, noch in der \myMinin{main()} Funktion, ist eine Variable \myMinin{fo} definiert.
    \begin{myCodeEnv}
      \centering
      \begin{myInvBox}[width=.9\linewidth]
        \lstinputlisting{code/error1.txt}
      \end{myInvBox}
      \caption{Fehler bei unbekannter Variable}
      \label{fig:error1}
    \end{myCodeEnv}

%---------------------------------
% Evaluation
%---------------------------------
\section{Evaluation}
\label{sec:Evaluation}
  % TODO compiler bugs
  % TODO ChaiScript http://chaiscript.com/ --- May 25, 2009 23fc75c  --- schlechte Fehlermeldungen

\myFixme{Ich habe \href{http://chaiscript.com/}{http://chaiscript.com/} gefunden. Quasi das was ich hier mache, bloß das die 9 Jahre Zeit hatten -- ich habe also einen Referenzpunkt! :)} % FIXME Das solltest Du gleich am Anfang (Einleitung oder Problemstellung) nennen und darstellen, warum Du einen eigenen Ansatz entwickelst. „Related Work“ fehlt in Deiner Arbeit ja leider völlig (habe ich zugegebenermaßen auch aus den Augen verloren). % FIXME

%---------------------------------
% Zusammenfassung und Ausblick
%---------------------------------
\section{Zusammenfassung und Ausblick}
\label{sec:Zusammenfassung und Ausblick}

  %---------------------------------
  % Literatur
  %---------------------------------
  \subsection{Ausblick}
  \label{ssec:Ausblick}
    \begin{enumerate}[ref=\autoref{ssec:Ausblick}: Punkt \arabic*]
      \item Debugger / Stepping\\
        Es könnte ein Interface angeboten werde, mit dem man durch die Ausführung eines Macros Schritt für Schritt gehen kann.
      \item C++17 std::string\_view\\
        Um weniger Speicher zu verbrauchen und durch weniger Memory Allokationen schneller beim Tokenizen zu sein.
      \item Mehr Fehler von dem Parser\label{enum:Mehr Fehler}\\
        Anstelle, dass der Parser Exceptions nutzt und nach dem ersten Fehler aufhört zu parsen, ist es möglichen einen \myMinin{Stack} von Fehlermeldungen zu produzieren -- wie es in dem \myMinin{Analyser} gemacht wird. Nach einem Fehler müsste nur bis zum nächsten Scopeanfang (\myTIn${$) , Scopeende(\myTIn$}$) oder Semikolon(\myTIn$;$) -- je nach dem wo der Fehler aufgetreten ist -- die Tokens verworfen werden und dann weiter geparst werden.\\
        Eine weitere Variante ist es, AST Elemente als poisoned zu kennzeichnen, was alle Fehler, die in Verbindung mit dem Element auftreten, verworfen werden, da es sehr wahrscheinlich eine Folgefehler ist.

        Dies hätte zur Folge, dass der Nutzer mehr Fehler auf einmal beseitigen kann.
      \item Verkettete \myMinin{Stack} Liste in ein Array umwandeln\label{enum:linkedlist}\\
        Wenn sich herausstellt, dass die verkettete Liste von dem \myMinin{Stack} zu langsam ist, kann der Interpreter ein Array nutzen um die \myMinin{Stack}s zu speichern, und die \myMinin{Stack}s Nutzen anstelle eines Pointers einen Offset, von dem sie aus die anderen \myMinin{Stack} fragen können. Der Vorteil von Arrays gegen LinktLists ist die wesentlich höhere Cache-Locality
      \item Einen Makro AST Buffer bereitstellen.\label{enum:astbuffer}\\
        Da das parsen und validieren der Makros ziemlich langsam ist, ist es ratsam einen Provider zu implementieren, der den Namen des Makros mit dem geparsten AST assoziiert. Der AST wird von dem \myMinin{Interpreter} nicht verändert, weswegen das Makro nur geparst werden muss, wenn es sich verändert hat.

        Ein weiterer Vorteil wäre, dass das Makro nicht als String einem anderen Makro bekannt sein muss oder als \myMinin{core::ConcreteCommand} implementiert sein muss, da der \myMinin{Interpreter} im den AST des anderen Makros weiter parsen würde. Dafür müsste der \myMinin{Interpreter} natürlich ein wenig angepasst werden, da er nun den `\myMinin{MakroProvider}' vor dem \myMinin{CommandProvider} nach einem passenden Makro fragen müsste.
      \item Besseres tokenizen und lexen von Zahlen.\label{enum:lexnumber}\\
        Momentan werden Zahlen sehr primitiv getokenized und gelext. C++ unterstützt Zahlen mit Wissenschaftlicher zu lexen -- dies wird nicht vom Tokenizer wie Parser unterstützt.
      \item AST Optimierungen.\\
        Ein AST kann genutzt werden, um den Code, den er repräsentiert, zu optimieren. Eine Optimierung wäre es zum Beispiel, dass Literals, die in arithmetischen Ausdrücken stehen, ausgerechnet werden.
      \item Bessere Laufzeitfehler.\label{enum:betterruntimeerrors}\\
        Um Bessere Laufzeitfehler in dem \myMinin{Interpreter} erzeugen zu können, sollte das gesamte \myMinin{Token} in der \myMinin{std::map} gespeichert werden, anstelle eines einfachen Strings. Ein Beispiel wäre, wenn eine Variable für ein \myMinin{core::Command} genutzt wird und der Typ des \myMinin{any} Objektes nicht stimmt.
    \end{enumerate}


\microtypesetup{protrusion=false} % disables protrusion locally in the document

%---------------------------------
% Literaturverzeichnis
%---------------------------------
% \section*{Literaturverzeichnis}
\label{sec:Literaturverzeichnis}
\begingroup
\sloppy
\printbibliography[title={Literaturverzeichnis}, heading=bibintoc]
\endgroup
\listoffigures
\listofmyCodeEnvTypes
\microtypesetup{protrusion=true} % disables protrusion locally in the document


%---------------------------------
% Anhänge
%---------------------------------
\section*{Anhänge}
\label{sec:Anhänge}
\addcontentsline{toc}{section}{Anhänge}

\end{document}
