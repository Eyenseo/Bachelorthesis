%---------------------------------
% Preamble
%---------------------------------
\input{preamble.tex}

%---------------------------------
% Document start
%---------------------------------
\begin{document}

\listoftodos

%---------------------------------
% Titlepage
%---------------------------------
\input{titlepage.tex}

%---------------------------------
% table of contents
%---------------------------------
\microtypesetup{protrusion=false} % disables protrusion locally in the document
\tableofcontents
\microtypesetup{protrusion=true} % disables protrusion locally in the document
\newpage

%---------------------------------
% Allgemeines
%---------------------------------
\addsec{Allgemeines}
\label{sec:Allgemeines}
  %---------------------------------
  % Eidesstattliche Erklärung
  %---------------------------------
  \subsection*{Eidesstattliche Erklärung}
  \addcontentsline{toc}{subsection}{Eidesstattliche Erklärung}
  \label{ssec:Eidesstattliche Erklärung}
    Ich, \MetaAuthor, Matrikel-Nr. \MetaStudentNumber, versichere hiermit, dass ich meine Bachelorarbeit mit dem Thema
    \begin{center}
      \vspace*{-1em}
      \textit{\MetaTitle}
      \vspace*{-1em}
    \end{center}
    selbständig verfasst und keine anderen als die angegebenen Quellen und Hilfsmittel benutzt habe, wobei ich alle wörtlichen und sinngemäßen Zitate als solche gekennzeichnet habe. Die Arbeit wurde bisher keiner anderen Prüfungsbehörde vorgelegt und auch nicht veröffentlicht.

    \vspace*{3em}
    \begin{tabular}{@{}rc}
      \raisebox{.2em}{Bremen, den \today}
        &\makebox[4cm]{\hrulefill}\\
      {}
        &\MetaAuthor
    \end{tabular}

\pagebreak

  %---------------------------------
  % Danksagung
  %---------------------------------
  \subsection*{Danksagung}
  \addcontentsline{toc}{subsection}{Danksagung}
  \label{ssec:Danksagung}
\myTodo{Danke an Mutter, Vater und alle Profs} % TODO

    % \begin{figure}[H]
    %   \centering
    %   \begin{tikzpicture}[%
    %     spy using outlines={%
    %       circle,%
    %       Cornsilk,%
    %       magnification=2,%
    %       size=3.5cm,%
    %       connect spies%
    %     }%
    %   ]
    %     \node{
    %       \pgfimage[%
    %         interpolate=true,%
    %         width=.8\linewidth%
    %       ]{%
    %         img/bb%
    %       }
    %     };
    %     \spy on (.1,-.3) in node [left] at (-2,1.9);
    %   \end{tikzpicture}

    %   \caption{\textit{``Das soll meine Zukunft sein?''}}
    % \end{figure}

\pagebreak

%---------------------------------
% Einleitung
%---------------------------------
\section{Einleitung}
\label{sec:Einleitung}
  Die Einführung von Automatisierung in ein Softwaresystem ist vergleichbar mit den Maschinen, die in der industrielle Revolution auftauchten. Anstelle, dass Menschen arbeiten müssen, um ein gewünschtes Ergebnis zu bekommen, drücken sie auf einen Knopf, und ein anderes System nimmt ihnen die aufwändige Arbeit ab. Dies führt dazu, dass Produkte schneller, mit weniger Arbeitsaufwand erstellt werden können. Zudem ist die entstehende Qualität immer auf einem gleichbleibenden Level und hängt nicht von dem Befinden der Arbeiter ab.

  Die P3-group arbeitet mit Airbus, um Lösungen für den Flugzeugbau zu entwickeln. Dieser Markt ist hart umkämpft, wodurch minimale Gewinne einen großen Unterschied machen können. Ein Feld, welches seit Jahren immer weiter durch wissenschaftliche und technische Durchbrüche optimiert wird, sind die menschlichen Ressourcen. Automatisierung sorgt dafür, dass sich wiederholende Arbeitsabläufe -- aus der Sicht des Nutzers -- zu einem einzigen Schritt werden und so Zeit sparen.

  Makros sind die Fließbänder der digitalen Welt, und diese Arbeit beschäftigt sich mit der Entwicklung eines Makro Systems bzw. Sprache.

  Makros werden durch die Verbindung kleinerer Bausteine (Anweisungen) erstellt. Diese können andere Makros oder Anweisungen, die die Anwendungsumgebung bereitstellt, sein. Dies ist mit einem Fließband in der Autoindustrie zu vergleichen. Jede Station ist genau für eine Aufgabe zuständig und kümmert sich um nichts anderes.

  Die Makrosprache ist ein Baukasten, mit dem Makros erstellt -- ``Fließbänder'' für spezielle Aufgaben erzeugt -- werden können.

  %---------------------------------
  % Problemfeld
  %---------------------------------
  \subsection{Problemfeld}
  \label{ssec:Problemfeld}
    Softwaresysteme haben oft das Problem, dass sie mit einigen zentralen Features anfangen, die fest definiert werden (sollten), bevor ein Vertrag geschlossen wird. Für weitere Funktionalität, die über die Vereinbarungen im Vertrag hinausgehen, muss der Vertrag erweitert werden. Wenn der Vertrag erfüllt ist, und im Anschluss weitere Wünsche aufkommen, muss ein weiterer Vertrag aufgesetzt werden und die vorher gelieferte Software muss angepasst, gegebenenfalls erweitert werden. Dies kann zur Folge haben, dass große Teile der Software umgeschrieben werden müssen, oder sogar, dass die Architektur der gesamten Anwendung verändert werden muss.

    Wenn frühzeitig ein Makrosystem/-sprache und ein entsprechendes Erweiterungskonzept für Module bzw. Plugins eingeführt wird, ist die Wahrscheinlichkeit, dass der Kern der Applikation für Erweiterungen angefasst werden muss, wesentlich geringer. Durch diese Kombination kann einfach ein weiteres Modul geladen werden, welches die neuen Grundbausteine der Applikation hinzufügt. Diese können dann in einem neuen, oder angepassten Makro genutzt werden, um den Wunsch der Kunden zu erfüllen. Im Falle, dass es keiner neuen Grundbausteine bedarf, reicht es sogar, nur ein Makro zu liefern. Die Vorteile dieser Methode sind, dass -- wenn man davon ausgeht, dass die benutzen Makros und Grundbausteine fehlerfrei durch ausreichendes Testen der Software sind -- keine neuen Bugs in den Kern der Software eingeführt werden können und somit immens zu der Stabilität der Software beigetragen wird. Ein weiterer Vorteil ist, dass die Makros mit wesentlich weniger Aufwand entwickelt werden können, weil sie sich auf einem höheren Level befinden. Für Kunden ist eine nutzbare Makrosprache auch interessant, weil sie zum Teil, durch das hausinterne Personal Anforderungen an die Software realisieren können, ohne den langen Weg über eine Firma zu gehen. Dies bedeutet auch, dass die Software eine bessere Chance hat, die Zeit zu überdauern.

  %---------------------------------
  % Ziele der Arbeit
  %---------------------------------
  \subsection{Ziele der Arbeit}
  \label{ssec:Ziele der Arbeit}
    Die Ziele der Arbeit sind es ein Makrosystem zu entwickeln, welches \ldots
    \begin{itemize}
      \item auf keinem festen \emph{Application Programming Interface (API)} aufbaut.

        Ein Feature der bestehenden Software ist es, dass sie durch \emph{Module}\footnote{
          Bibliotheken, die zur Laufzeit -- nach den dynamischen Bibliotheken --  nachgeladen werden können, um die Funktionalität der Applikation zu erweitern.
        } erweitert werden kann. Eines dieser Module wird das Makrosystem sein, welchen in dieser Arbeit entwickelt wird. Durch diese Modularität, gibt es kein festest Interface.

      \item nicht nur Anweisungen abarbeitet.

        Um eine große Bandbreite an Automatisierungsmöglichkeiten anbieten zu können, bedarf es logischer Ausdrücke, die bedingte Anweisungen erlauben. Ebenso ist es wichtig, dass man entscheiden kann, wie oft etwas ausgeführt werden soll, sprich Schleifen. Und die Makros sollen sowohl von dem Programm, als auch von anderen Makros Parameter übergeben bekommen können.

      \item nicht mehr kann als es können muss.

        Je mächtiger ein System ist, desto komplexer ist es. Zudem sind Features nur etwas wert, wenn sie gewinnbringend verkauft werden können.

      \item wartbar ist.

        Die Implementierung sollte keine komplexen Bestandteile besitzen, über die nicht geschlussfolgert werden kann.

      \item benutzerfreundlich ist.

        Die Lösung soll benutzerfreundlich sein, das heißt, dass Fehlermeldungen dem Nutzer schnell zu seinem Fehler führen und keine false positives enthalte.
    \end{itemize}

  %---------------------------------
  % Hintergründe und Entstehung des Themas
  %---------------------------------
  \subsection{Hintergründe und Entstehung des Themas}
  \label{ssec:Hintergründe und Entstehung des Themas}
    Die P3-group ist daran interessiert, dass sie ihren Kunden Lösungen schnell und in hoher Qualität anbieten kann. Um dies zu erreichen arbeiten sie daran, dass alle Softwaresysteme, die von ihnen angeboten werden, Automatisierung über Makros unterstützen. Wirtschaftlich rentieren sich die Makros dadurch, dass sie von den Firmen gemietet und nicht nur einmal verkauft werden. Zum Beispiel, werden alle Flugzeugteile ausgewählt und dann deren Gewicht ermittelt. Ein anderes Mal sollen nur spezielle Teile aus einem bestimmten Werkstoff zusammen gezählt und deren Preis ermittelt werden. Anstelle, dass hier eine sehr komplexe Suchfunktion entwickelt wurde, können hier zwei Makros zum Einsatz kommen, die jeweils eine Aufgabe erfüllen und somit für den Benutzer sicher zu handhaben sind. Die Komplexität der Software wurde durch das zweite Makro nicht sonderlich beeinflusst, da dieses intern auf Funktionalität zurückgreifen kann, die schon vom ersten genutzt wird.

  %---------------------------------
  % Struktur der Arbeit, wesentliche Inhalte der Kapitel
  %---------------------------------
  \subsection{Struktur der Arbeit, wesentliche Inhalte der Kapitel}
  \label{ssec:Struktur der Arbeit, wesentliche Inhalte der Kapitel}
    Die Arbeit ist in drei wesentliche Kapitel aufgeteilt, \myNamedRef{sec:Anforderungsanalyse}, \myNamedRef{sec:Konzeption} und \myNamedRef{sec:Exemplarische Realisierung}. Der Fokus dieser Kapitel geht vom Theoretischen zum Praktischen. Innerlich folgen die Kapitel den Arbeitsabläufen, die zur Entwicklung des Makrosystems genutzt wurden. Zudem gibt es dies \hyperref[sec:Einleitung]{Einleitungs} Kapitel, eine \nameref{sec:Evaluation} und einen \nameref{ssec:Ausblick}.

    In dem Kapitel \nameref{sec:Anforderungsanalyse} werden die Anforderungen, sowie deren Probleme analysiert. Das Kapitel \nameref{sec:Konzeption} beschäftigt sich mit den Lösungen für die Anforderungen sowie der Probleme, die im vorherigen Kapitel gefunden wurden. Unter anderem beinhaltet das Kapitel die Software Architektur, sowie den Syntax für die Makrosprache. In dem Kapitel \nameref{sec:Exemplarische Realisierung} wird auf entscheidende Punkte der exemplarischen Realisierung eingegangen.

%---------------------------------
% Anforderungsanalyse
%---------------------------------
\section{An\-for\-de\-rungs\-ana\-ly\-se}
\label{sec:Anforderungsanalyse}
  Dieses Kapitel beschäftigt sich mit dem Problemfeld und den Anforderungen an die entstehende Lösung. In der \nameref{ssec:Diskussion des Problemfeldes} geht es vor allem darum, das Problemfeld zu analysieren und die Unterprobleme ausfindig zu machen, um abstrakte Lösungsansätze für diese zu entwickeln. Bei den \nameref{ssec:Anforderungen an die angestrebte Lösung} ist das Ziel die Anforderungen, die die Problemlösung erfüllen sollte, zu definieren.

  %---------------------------------
  % Diskussion des Problemfeldes
  %---------------------------------
  \subsection{Diskussion des Problemfeldes}
  \label{ssec:Diskussion des Problemfeldes}
    Ein Makrosystem ist eine Komponente eines Softwaresystems, welche es erlaubt, die Software über eine Reihenfolge von Zeichen so zu steuern, als ob ein Mensch die Applikation bedient hätte.

    Die Funktionalität eines Makrosystems ist vergleichbar mit Programmiersprachen -- dort wird, durch eine Ansammlung von Zeichen, der Computer veranlasst, eine bestimmte Abfolge von Hardwareanweisungen auszuführen. Der Unterschied von einem Makrosystem zu zum Beispiel C ist, dass bei einem Makrosystem der Befehlssatz durch die Anwendung vorgegeben wird, wohingegen der Befehlssatz von C durch die
    Hardware % FIXME Nein, durch die Spezifikation der Sprache!
    vorgegeben ist.
    Somit ist ein Makrosystem eher mit einer Sprache zu vergleichen, die sich einer virtuellen Maschine bedient -- wie Java -- als mit C. % FIXME Den Vergleich finde ich nicht geeignet. Ein Makrosystem ist doch nichts anderes als eine Sprache, in der ich (zumindest) Prozeduren (Makros) aufrufen und Kontrolllogik definieren kann. Das geht sowohl bei Java als auch bei C.
    \\
    Der Befehlssatz dieses Makrosystems kommt aus dem vorhandenen
    System % FIXME Ich denke, Du solltest _vorher_ (z.B. als erstem Abschnitt in diesem Kapitel) das „System“ einführen und dabei auch darauf eingehen, wie die „Prozeduren“ / Module als Kommandos entworfen sind.
    , da dort das \emph{Command-Pattern} \autocite[S.263]{Gamma:1995:DPE:186897} eingesetzt wird und somit ein ideales Interface für Automatisierung bietet.

\myFixme{Das folgende ist ziemlich komprimiert -- muss das noch ausführlicher durchgekaut werden (Kapitel Grundlagen?), oder ist das `Allgemeinwissen'?}  % FIXME Weiß nicht. Ist schon sehr minimalistisch… Wenn Du kannst, kannst Du ja noch ein bisschen mehr Hintergrund einführen (ggf. mit kleinen Beispielen zur Arbeit von Tokenizer und Parser (Kette darstellen: String -> Tokenfolge -> AST)).
                                                                                                                                                             %
    % FIXME Die folgenden drei Absätze gehen für meine Begriffe schon zu sehr in Richtung Entwurf / Konzeption. Verschieben?
    Für alle Programmiersprachen ist es von Nöten, die Reihenfolge von Zeichen (\myMinin{string}), in sinnvolle Stücke zu zerteilen -- dies übernimmt ein Tokenizer. Meist wird dieser in den Parser\autocite[S.46]{eirund2013formale} integriert, welcher die Stücken des Strings in ein Format bringt, welches der \emph{Interpreter} \autocite[S.274]{Gamma:1995:DPE:186897} verstehen kann. Das Format ist meist ein \emph{abstrakter Syntaxbaum}\footnote{
      \textit{Abstract syntax tree} ist eine digitale Darstellung einer Programmiersprache.
    } (AST), welcher den String eindeutig repräsentiert. Der Interpreter arbeitet dann nur noch mit dem AST, welcher vorgibt welche Befehle der Interpreter ausführen muss, um das als String angegebene Programm auszuführen.

    Das vorhandene System ist in C++ geschrieben, weswegen es sich größten Teils erübrigt über andere Programmiersprachen nachzudenken. Durch das \emph{name mangling}\footnote{
      Beim `name mangling' fügt der Compiler den Funktionsnamen weite Informationen hinzu, um eine eindeutige Funktionssignatur zu erhalten.
    } ist es schwierig eine API von C++ zu anderen Programmiersprachen anzubieten -- meistens geschieht dies über eine C API. Bei dieser verliert man den Vorteil der Objektorientierung und muss meistens auch die Daten zwischen C++$\longleftrightarrow$C und C$\longleftrightarrow$XYZ (z.B Python oder Lua) konvertieren, was langsam ist. Die Makros müssen aber auf Daten arbeiten, welche als Objekte von C++ vorliegen, deswegen müsste der Stack, mit dem der Interpreter arbeitet, in der C++ Ebene bleiben. Damit würde eine Implementierung von Tokenizer, Parser, AST und Interpreter die Wartbarkeit, durch die Teilung und die weitere Programmiersprache deutlich verschlechtern. Zusätzlich ist das Ziel eine Applikation zu automatisieren, und nicht mit komplett neuen Funktionalitäten zu erweitern, was die Vorteile von z.B Python größtenteils zunichte macht.

    Die vorhandene Software ist Cross-Plattform (Windows und Linux) entwickelt. Im Rahmen dieser Bachelorarbeit wird die Software nur auf Linux entwickelt, da die \emph{Standard} Implementation von Microsoft
    unberechenbar % FIXME Solche Bemerkungen bitte streichen bzw. nicht in dieser unwissenschaftlichen Form bringen.
    ist und bei der Fehlersuche meist viel Zeit in Anspruch nimmt. Bei der Entwicklung wird daher darauf geachtet, dass keine Linux spezifischen Bibliotheken in Anspruch genommen werden. Das schließt leider nicht aus, dass die entstehende Software, ohne Anpassungen, auf Windows ausgeführt werden kann.

  %---------------------------------
  % Anforderungen an die angestrebte Lösung
  %---------------------------------
  \subsection{Anforderungen an die angestrebte Lösung}
  \label{ssec:Anforderungen an die angestrebte Lösung}
    Die Probleme, ein Makrosystem/-sprache in C++ zu implementieren, fangen dann an, wenn man von den Makros will, dass diese nicht nur hintereinander abgearbeitet werden, ohne dass sie wissen, dass andere Makros vor ihnen bzw. nach ihnen ausgeführt werden -- wie in \autoref{fig:sequential} zu sehen ist.

    \begin{figure}[H]
      \centering
      \myInput{img/sequential.tikz}
      \caption{Sequenzielles Abarbeiten von Prozessschritten.}
      \label{fig:sequential}
    \end{figure}

    \autoref{fig:logic} zeigt den ersten Schritt zu einer nützlichen Implementation -- Logik. Hierbei bietet man an, dass der Makro-Entwickler durch Rückgabewerte aus Makros entscheiden kann, welche weiteren Makros er ausführen möchte.

    \begin{figure}[H]
      \centering
      \myInput{img/logic.tikz}
      \caption{Logische Ausdrücke um bedingte Anweisungen zuzulassen.}
      \label{fig:logic}
    \end{figure}

    Obwohl man mit solchen Makros schon einige Probleme lösen kann, ist es nicht das, was man zur Verfügung haben will, wenn man mit
    objektorientierten % FIXME Objektorientiert ist hieran ja gar nichts - das Wort kannst Du also streichen (und vielleicht statt von „Sprachen“ eher von „vollständigen Programmiersprachen“ sprechen?).

    Sprachen arbeitet bzw. mehr als ein \textit{`ja'} oder nein \textit{`nein'} braucht.

    Was ein Makrosystem/-sprache anbieten muss ist, dass Instanzen von verschiedenen Klassen/Typen zurückgegeben und beliebig viele Parameter (unterschiedlicher Klassen/Typen) dem Makro mitgegeben werden können. Leider sind gerade diese Punkte ein Problem in C++, weil C++ keine Reflexion\autocites{vinoski2005time}{ferber1989computational} unterstützt.
    Dies ist durch eine Implementation\footnote{
      Das Command-Pattern wurde mit Hilfe des \texttt{any} \autocite{cpp-fundamentals} sowie \texttt{optional} \autocite{cpp-fundamentals} Typs implementiert.
    }
    des Command-Patterns gelöst worden. % FIXME Inwieweit ist das Wiederholung? Das Command-Pattern hast Du ja vorher schon mal erwähnt? Vielleicht wird mir auch nur nicht auf Anhieb klar, wie das Command-Pattern das Problem der Reflexion löst.
    Somit kommt in diesem Schritt `nur' noch hinzu, dass es Schleifen, sowie komplexe Parameter und Rückgabewerte geben kann, siehe \autoref{fig:loop}.

    \begin{figure}[H]
      \centering
      \myInput{img/loop.tikz}
      \caption{Schleife, die Anweisungen für ein Element aus der Liste aufrufen.}
      \label{fig:loop}
    \end{figure}

    Letztendlich kann man sagen, dass ein solches Makrosystem/-sprache eine Programmiersprache mit Interpreter sein sollte, deren Laufzeitumgebung eine anderes Softwaresystem ist.

    Die Fehlermeldungen, die bei Syntaxfehlern auftreten, sollten dem Nutzer möglichst viele sinnvolle Informationen liefern -- als Vorbild dient hier Clang (siehe \autoref{fig:clang_error}).

    \begin{myCodeEnv}
      \centering
      \begin{minipage}{.9\textwidth}
        \begin{lstlisting}[keepspaces,escapechar=°,numbers=none]
°\textbf{ main.cpp:4:42: \textcolor{red}{error}: expected ';' after expression}°
   std::cout << "Hallo Welt!" << std::endl
                                          °\textcolor{Green}{\textasciicircum}°
                                          °\textcolor{Green}{;}
        °\end{lstlisting}
      \end{minipage}
      \caption{Clang Fehlermeldung.}
      \label{fig:clang_error}
    \end{myCodeEnv}

%---------------------------------
% Konzeption
%---------------------------------
\section{Konzeption}
\label{sec:Konzeption}
  Dieses Kapitel beschäftigt sich mit der theoretischen Problemlösung.

  \autoref{ssec:Syntax} beschreibt die Syntax, welche von dem Tokenizer und Parser umgewandelt werden soll. Im \autoref{ssec:Grundarchitektur} wird die Grundarchitektur des Makrosystems beschrieben. Diese Grundarchitektur umfasst nur die grobe Architektur des Makrosystems, da in dem \autoref{ssec:Detaillierte Teilarchitekturen} auf die komplexeren Teile der Architektur eingegangen wird.

  %---------------------------------
  % Syntax
  %---------------------------------
  \subsection{Syntax}
  \label{ssec:Syntax}
    Die Syntax ist an C\autocite{C-std}, Python\autocite{Python-std}, JavaScript \autocite{Ecma-std} und Swift\autocite{Swift-std} angelegt. C liefert den größten Anteil der Syntax, von Python wurde \lstinline[style=MyMacroStyleIn]$def$ übernommen, von JavaScript \lstinline[style=MyMacroStyleIn]$var$ und die \emph{named parameter}\footnote{
      Named Parameter sind Parameter, die über einen Namen ihren Wert beim Funktionsaufruf zugewiesen bekommen. Die Normale Wertzuweisungsstrategie ist nach der Reihenfolge der Deklaration vor zu gehen.
    }
    Syntax \lstinline[style=MyMacroStyleIn]$fun(foo:gun());$ von Swift. Die Unterscheidung zwischen \lstinline[style=MyMacroStyleIn]$def$ und \lstinline[style=MyMacroStyleIn]$var$ sorgt dafür, dass der Programmierer nach den ersten drei Zeichen weiß, was der folgende Code machen wird. Das die Makrosprache named parameter unterstützt, liegt daran, dass das
    Command-Pattern % FIXME Schon wieder ;-) Dass Du Dich darauf immer wieder beziehst, macht deutlich, wie wichtig es ist, dass Du die Realisierung der Prozeduren/Module und das Command-Pattern vorher umfassend einführst!
    so implementiert wurde, dass Parameter alias Bezeichnungen benutzen können, um eine hohe Kompatibilität zwischen unabhängig entwickelten Modulen zu gewährleisten. Dies ist in der Makrosprache nicht so einfach möglich, somit sind die named parameter der bestmögliche Kompromiss, da diese erlauben, die Parameter in beliebiger Reihenfolge anzugeben.

    %---------------------------------
    % Syntax Grundlagen
    %---------------------------------
    \subsubsection{Syntax Grundlagen}
    \label{sssec:Syntax Grundlagen}
      Bezeichner müssen dem regulären Ausdruck (Regex) aus \autoref{fig:id_syntax} entsprechen. Das heißt, dass Bezeichner nur aus kleinen Buchstaben, Nummern und Unterstrichen bestehen können und am Anfang einen Buchstaben haben müssen. Grund für diese drastische Einschränkung ist, dass der Code einheitlich aussehen soll (die erste Regel was Bezeichnungen/Formatierung angeht ist, dass man sich an dem orientiert was schon existiert). Um dies besser garantieren zu können, wurde die CamelCase Schreibweise von vorn herein ausgeschlossen. Außerdem sind Bezeichner, die einem keyword entsprechen
  \myFixme{Update der keywords} % TODO
      (\lstinline[style=MyMacroStyleIn]$def$, \lstinline[style=MyMacroStyleIn]$var$, \lstinline[style=MyMacroStyleIn]$if$, \lstinline[style=MyMacroStyleIn]$else$, \lstinline[style=MyMacroStyleIn]$for$, \lstinline[style=MyMacroStyleIn]$do$, \lstinline[style=MyMacroStyleIn]$while$, \lstinline[style=MyMacroStyleIn]$break$, \lstinline[style=MyMacroStyleIn]$return$), einen Booleanwert entsprechen (\lstinline[style=MyMacroStyleIn]$true$, \lstinline[style=MyMacroStyleIn]$false$), oder \lstinline[style=MyMacroStyleIn]$main$ gleichen -- abgesehen von der einen \lstinline[style=MyMacroStyleIn]$main$ Methode -- verboten.

      \begin{figure}[H]
        \centering
        \myInput{img/id_syntax.tikz}
        \caption{Bezeichner}
        \label{fig:id_syntax}
      \end{figure}
      % FIXME Variable:  Was macht das Wörtchen hier? Ach so, habe ich nach Abbildung 7 verstanden…
      % TODO Tauschen?
      % FIXME FunktionsaufrufEEEEEE: Singular!?

      \autoref{fig:vpr_syntax} zeigt alle Werterzeuger, dass sind Konstrukte, die einen Wert für eine andere Operation bereitstellen.
      \begin{figure}[H]
        \centering
        \myInput{img/vpr_syntax.tikz}
        \caption{Werterzeuger}
        \label{fig:vpr_syntax}
      \end{figure}

      In \autoref{fig:return_syntax} ist die Syntax von \lstinline[style=MyMacroStyleIn]$return$ zu sehen.
      \begin{figure}[H]
        \centering
        \myInput{img/ret_syntax.tikz}
        \caption{Syntax von return.}
        \label{fig:return_syntax}
      \end{figure}

      Literals sind entweder Doubles, Integer, Strings oder Boolean Werte, wie \autoref{fig:lit_syntax} zeigt. In Strings ist es möglich besondere Zeichen zu escapen, zum Beispiel kann ein Zeilenumbruch, wie in anderen Programmiersprachen, mit \lstinline[style=MyMacroStyleIn]$"\n"$ oder ein Tab mit \lstinline[style=MyMacroStyleIn]$"\t"$, erzeugt werden.
      \begin{figure}[H]
        \centering
        \myInput{img/lit_syntax.tikz}
        \caption{Syntax von Literals.}
        \label{fig:lit_syntax}
      \end{figure}
      % FIXME __Double__ Funktioniert das so? Wenn ich das richtig lese, kannst Du nur Doubles wie 5.9 erzeugen, aber nicht 123.456. Wiederholung des Ziffer-Ausdrucks? Analog bei Integer und String…

      Abbildungen \ref{fig:scope_syntax}, \ref{fig:loop_scope_syntax} und \ref{fig:common_syntax} zeigen den Syntax von einem Scope. Scopes sind Bestandteile von Funktionen und Kontrollstrukturen, wobei sich Loop Scopes von normalen Scopes nur darin unterscheiden, dass sie das \lstinline[style=MyMacroStyleIn]$break$ Keyword unterstützen. Alle Scopes -- abgesehen von Funktionsdeklarationsscopes --
      die auf ein Loop Scope folgen % FIXME Meinst Du wirklich folgen? Verstehe ich dann nicht. Oder meinst Du geschachtelte Scopes?
      , sind automatisch Loop Scopes. Scopes verhalten sich wie C Scopes, was bedeutet, dass der Syntax \lstinline[style=MyMacroStyleIn]$var foo; {var foo;}$ richtig ist -- das erste \lstinline[style=MyMacroStyleIn]$foo$, wird von dem zweiten verdeckt.
      \begin{figure}[H]
        \centering
        \begin{minipage}{.45\textwidth}
          \vspace*{2.45em}
          \begin{figure}[H]
            \centering
            \myInputUnlimited{img/scope_syntax.tikz}
            \caption{Syntax vom Scope.}
            \label{fig:scope_syntax}
          \end{figure}
        \end{minipage}%
        \begin{minipage}{.45\textwidth}
          \begin{figure}[H]
            \centering
            \myInputUnlimited{img/loop_scope_syntax.tikz}
            \caption{Syntax vom Loop Scope.}
            \label{fig:loop_scope_syntax}
          \end{figure}
        \end{minipage}
      \end{figure}

      \begin{figure}[H]
        \centering
        \myInput{img/common_syntax.tikz}
        \caption{Syntax allgemeiner Strukturen.}
        \label{fig:common_syntax}
      \end{figure}
\myFixme{Fehlende Semikolons - Literal, Werterzeuger, break} % TODO


    %---------------------------------
    % Definitionen
    %---------------------------------
    \subsubsection{Definitionen}
    \label{sssec:Definitionen}
      Variablen können, wie in \autoref{fig:var_syntax} zu sehen ist, definiert werden: \lstinline[style=MyMacroStyleIn]$var foo;$. Um anschließend der Variablen einen Wert zuzuweisen, ist es unter anderem erlaubt, dies zu tun: \lstinline[style=MyMacroStyleIn]$var foo = fun();$ oder \lstinline[style=MyMacroStyleIn]$var foo = true == false;$.
      \begin{figure}[H]
        \centering
        \myInput{img/var_syntax.tikz}
        \caption{Syntax der Variablendeklaration.}
        \label{fig:var_syntax}
      \end{figure}

      Funktionen können über \lstinline[style=MyMacroStyleIn]$def fun(){...}$ definiert werden, was \autoref{fig:fun_syntax} zeigt. Um eine parametrisierte Funktion zu definieren, gibt man die Parameternamen, Komma getrennt, nach dem Funktionsnamen an:
      \lstinline[style=MyMacroStyleIn]$def fun(foo, bar){...}$. % FIXME Hast Du schon irgendwo genannt, dass Du ungetypte Parameter verwendest?
      Es ist nicht erlaubt, ein Whitespace zwischen dem Bezeichner und der Klammer zu haben.

      Der Einstiegspunkt eines jeden Makros ist eine \lstinline[style=MyMacroStyleIn]$def main(){...}$ Funktion. Der Syntax ist der selbe wie bei den normalen Funktionen und erlaubt es daher auch Parameter anzugeben. Deswegen können die Makros aus anderen Makros, oder aus der C++ Ebene über einen äquivalenten Syntax mit Parametern aufgerufen werden.
      \begin{figure}[H]
        \centering
        \myInput{img/fun_syntax.tikz}
        \caption{Syntax der Funktionsdeklaration.}
        \label{fig:fun_syntax}
      \end{figure}

    %---------------------------------
    % Kontrollstrukturen
    %---------------------------------
    \subsubsection{Kontrollstrukturen}
    \label{sssec:Kontrollstrukturen}
      Die Syntax von \lstinline[style=MyMacroStyleIn]$if/else$ und \lstinline[style=MyMacroStyleIn]$do-/while$ aus den Abbildungen \ref{fig:if_syntax}, \ref{fig:while_syntax} und \ref{fig:do_while_syntax} sollten wie erwartet aussehen.
      \begin{figure}[H]
        \centering
        \myInput{img/if_syntax.tikz}
        \caption{Syntax von if.}
        \label{fig:if_syntax}
      \end{figure}
      % FIXME Werterzeuger: Reicht das hier? Was ist, wenn der Werterzeuger den Wert 5 oder „Test“ liefert? Müsstest Du nicht einen booleschen Werterzeuger verwenden?

      \begin{figure}[H]
        \centering
        \myInput{img/while_syntax.tikz}
        \caption{Syntax von while.}
        \label{fig:while_syntax}
      \end{figure}

      \begin{figure}[H]
        \centering
        \myInput{img/do_while_syntax.tikz}
        \caption{Syntax von do-while.}
        \label{fig:do_while_syntax}
      \end{figure}
\myTodo{For, For-each Schleife wenn implementiert} % TODO

    %---------------------------------
    % Befehle
    %---------------------------------
    \subsubsection{Befehle}
    \label{sssec:Befehle}
      \autoref{fig:call_syntax} zeigt die Syntax, um eine definierte Funktion aufzurufen. \lstinline[style=MyMacroStyleIn]$fun(foo:gun(), bar:foo);$ weist dem \lstinline[style=MyMacroStyleIn]$foo$ Parameter den Wert von \lstinline[style=MyMacroStyleIn]$gun()$ zu und dem Parameter \lstinline[style=MyMacroStyleIn]$bar$ wird der Wert von \lstinline[style=MyMacroStyleIn]$foo$ aus dem Scope zugewiesen.
      \begin{figure}[H]
        \centering
        \myInput{img/cal_syntax.tikz}
        \caption{Syntax von Funktionsaufrufen.}
        \label{fig:call_syntax}
      \end{figure}
\myFixme{Kein Semikolon} % TODO

      Die Operator Syntax aus \autoref{fig:op_syntax} sollte, ähnlich wie die \lstinline[style=MyMacroStyleIn]$return$ Syntax,
      nicht allzu überraschend sein. % FIXME Das ist auch so ein Null-Aussage-Satz. Streichen!
      Geklammerte Ausdrücke werden zuerst vollständig ausgewertet, bevor der Operator angewendet wird. Das heißt, dass \lstinline[style=MyMacroStyleIn]$(a || b) && c$ folgender Weise interpretiert wird.
\myFixme{Das geht leider nicht so ganz aus dem Diagramm hervor -- Ideen?} % FIXME Das kann auch aus dem Diagramm nicht hervorgehen, weil in den Diagrammen ja nur Syntax steht und die Auswertung eine Frage der Semantik ist. Da Du die Semantik sicherlich nicht formal (mit Formeln) definieren willst: Text schreiben! Und vielleicht dann auch explizit sagen, dass Du von links nach rechts auswertest, dass Du Klammerung berücksichtigst und dass es - vermutlich - keine „Kurzschlusssemantik“ gibt, also alle Ausdrücke ausgewertet werden.
      \lstinline[style=MyMacroStyleIn]$a$ oder \lstinline[style=MyMacroStyleIn]$b$ wird zuerst ausgewertet und deren Ergebnis wird mit \lstinline[style=MyMacroStyleIn]$c$ genutzt. Entgegen dessen wird bei \lstinline[style=MyMacroStyleIn]$a || b && c$ zuerst \lstinline[style=MyMacroStyleIn]$a$, und dann \lstinline[style=MyMacroStyleIn]$b$ und \lstinline[style=MyMacroStyleIn]$c$ ausgewertet.
      \begin{figure}[H]
        \centering
        \myInput{img/op_syntax.tikz}
        \caption{Syntax von Operatoren.}
        \label{fig:op_syntax}
      \end{figure}
\myTodo{Wenn implementiert ===, !==, typeof, print} % TODO

  %---------------------------------
  % Grundarchitektur
  %---------------------------------
  \subsection{Grundarchitektur}
  \label{ssec:Grundarchitektur}
    Das Ziel der folgenden Architektur ist,
    die Funktionalität, die in \autoref{fig:abstract_goal_uml} zu sehen ist, % FIXME 1.) Da ist keine Funktionalität zu sehen! 2.) Du solltest _erst_ einmal beschreiben, was Du erreichen möchtest (ohne Klassen zu nennen!!) und _dann_ den dazugehörigen Entwurf darstellen / beschreiben. 3.) Vererbungspfeile sind falsch herum. Gibt nachträgliche Abzüge in Deiner SWT-Note!!!
    zu ermöglichen.

    \begin{figure}[H]
      \centering
      \myInput{img/abstract_goal_uml.tikz}
      \caption{Abstraktes Ziel der resultierenden Architektur.}
      \label{fig:abstract_goal_uml}
    \end{figure}
    \myMinin{Executable} ist das Interface, welches alle \myMinin{Command}s aus dem Command-Pattern implementieren. % FIXME Mir ist die Verbindung zu den Prozeduren/Modulen, die im Makro aufgerufen werden sollen, nicht klar.
    Eine weitere Implementation dieses Interfaces ist --
    nicht zu verwechseln mit Ma\emph{k}ros -- die \myMinin{Macro} Klasse. % FIXME Mir ist der Unterschied gerade nicht klar. Bitte deutlicher machen!
    Diese erlaubt es Entwicklern ein Makro auszuführen. Im weiteren Verlauf dieser Arbeit geht es hauptsächlich um die Ma\emph{k}ros, da sich die Implementation der \myMinin{Macro} Klasse am Ende aus den Teillösungen ergibt.

    Da das komplette UML Diagramm sehr unübersichtlich ist und nicht auf ein A2 Blatt passt, sind die folgenden Diagramme Ausschnitte aus dem Kompletten und spiegeln es zusammen wieder.

    \autoref{fig:top_pack_uml} zeigt die Abhängigkeiten der Pakete (namespaces) in dem Modul, welches die Makrofunktionalität anbieten soll. Das \myMinin{ast} Paket beinhaltet alle Klassen, die den abstrakten Syntaxbaum ausmachen und von dem Parser und dem Interpreter verwendet werden. In dem \myMinin{parser} Paket befinden sich der Tokenizer und Parser. In dem \myMinin{token} Paket befindet sich die Token, da diese in kein anderes Paket gehört.
    \begin{figure}[H]
      \centering
      \myInput{img/top_pack_uml.tikz}
      \caption{Abhängigkeiten von dem Makro Modul.}
      \label{fig:top_pack_uml}
    \end{figure}
    % FIXME Kein Tokenizer-Paket? Das wundert mich aber sehr…

    %---------------------------------
    % Token und Parser Paket
    %---------------------------------
    \subsubsection{Token und Parser Paket} % FIXME Noch mal zu Deiner Frage auf Seite 8: ja, führ das Thema (dort) bitte mal etwas weiter aus, da Du hier ja auch keine konzeptionellen Details zum Thema Parsing bringst.
    \label{sssec:Token und Parser Paket}
      Der \myMinin{Parser} aus \autoref{fig:parser_pack_uml} bedient sich des \myMinin{Tokenizer}, um eine \myMinin{TokenList} von \myMinin{Token}s zu bekommen. Diese \myMinin{TokenList} kann er dann parsen, bzw. in einen abstrakten Syntaxbaum umwandeln.
      \begin{figure}[H]
        \centering
        \myInput{img/parser_pack_uml.tikz}
        \caption{Parser Paket UML}
        \label{fig:parser_pack_uml}
      \end{figure}
      % FIXME Ich verstehe noch immer nicht, warum es kein Paket Tokenizer mit den Klassen Tokenizer, TokenList und ggf. Token gibt…

      Der \myMinin{Tokenizer} wandelt den String, der das Makro beschreibt, in eine Reihenfolge von \myMinin{Token}s um. Tokens sind alle Zeichen, die von whitespace (\lstinline[language=MyRegex]$\s*$) getrennt sind, die nicht den Anforderungen als Bezeichner genügen (\lstinline[language=MyRegex]$[^a-zA-Z0-9_]$, siehe \autoref{fig:id_syntax}), die durch einen Punkt eine Dezimalzahl bilden (\lstinline[language=MyRegex]$\d*\.\d+$) oder einen String darstellen (\lstinline[language=MyRegex]$".*?"$\footnote{
        Dieser Regex funktioniert nur für einfache Varianten (kein escapen) von Strings und dient deswegen nur der Veranschaulichung.
      }). Der \myMinin{Tokenizer} ist nicht für das
      Lexen % FIXME Dieser Begriff muss auch erläutert werden (Kapitel 2?).
      verantwortlich -- dies wird von dem Parser übernommen.

      \myMinin{Token}s beinhalten die Zeile sowie Spalte als Zahl, und den gesamten Quelltext aus der Zeile, aus der das \myMinin{Token} entstanden ist. Dies ist von Nöten, um später gute Fehlermeldungen zu erzeugen, mit denen ein Benutzer schnell weiß, wo er nach dem Fehler suchen muss. Des weiteren enthält die Klasse einen String, der den Teil des Makros enthält, den die Instanz darstellen soll (zB. \lstinline[style=MyMacroStyleIn]$if$).

      Der \myMinin{Parser} ist dafür verantwortlich, dass die \myMinin{TokenList} in einen AST umgewandelt wird. Es gibt drei Hauptarten von Parsern\autocite[S.77\,f.]{eirund2013formale}
      \emph{LL} % FIXME Abkürzungen immer mindestens bei der ersten Verwendung ausschreiben.
      \footnote{
        LL Parser arbeiten `vorwärts', links nach rechts und probieren auf der linken Seite, des gelesenen bzw. teils geparsten Quelltextes zu reduzieren. Man gelangt zum Schluss, am Ende des Baumes an.
      },
      \emph{LR} % FIXME Abkürzungen immer mindestens bei der ersten Verwendung ausschreiben.
      \footnote{
        LR Parser arbeiten `rückwärts', links nach rechts und probieren auf der rechten Seite, des ungelesenen Quelltextes zu reduzieren um Terminals auf der linken Seite zu sammeln. Man gelangt zum Schluss an dem Anfang des Baumes an. \autocite{cs143-stanford}
      } und
      \emph{recursive descent} % FIXME Bei allen drei Varianten müsstest Du mal die Grundidee erläutern, damit Deine Wahl nachvollziehbar wird. Ggf. auch in Kapitel 2.
      \footnote{
        Recursive descent Parser bauen durch Funktionsaufrufe einen Stack auf, der den Zweigen des Baumes gleicht.
      }.
\myFixme{Ist es ok, dass ich die Parser nur kurz in den Fußnoten erklärt habe (Grundlagen Kapitel?)} % FIXME Nein, siehe Kommentar beim „descent“.
      LL und LR Parser sind meistens schneller als recursive descent, da sie mit Hilfe von Zustandstabellen arbeiten, die meist aus der Backus-Naur-Form heraus entstehen. Der Nachteil bei den beiden ist, dass LL und umso mehr LR Parser, schwer zu warten sind, weswegen meist Parser-Generatoren genutzt werden, um den Quelltext für den Parser zu generieren. Außerdem sind die Fehlermeldungen, die LL und LR Parser erzeugen meistens schlechter als die, die recursive descent Parser von Natur aus mit sich bringen\autocite{scott2010gll}. Da die Wartbarkeit und Fehlermeldungen wichtige Punkte auf der Anforderungsliste sind, wurde sich für einen recursive descent Parser entschieden. Zudem sind die gelungenen Parser von Clang\autocite{clang-feat} und GCC\autocite{gcc-new-parser} ein gutes Beispiel und Vorbild, was mit recursive descent Parsern erreicht werden kann.

      Beim Parsen müssen die Literals umgewandelt  werden (Lexen) -- aus dem Token \myMinin{"1.01"} muss der Double \myMinin{1.01} werden, escapete Symbole in einem String müssen umgewandelt werden (z.B.: \myMinin{"t\tt"}$\rightarrow$\myMinin{"t  t"}).
      Die Operatoren müssen in der richtigen Reihenfolge zusammengestellt werden % FIXME Das hat jetzt aber nichts mehr mit dem Lexen zu tun, oder? Macht nämlich den Eindruck…
      (bei
\myFixme{Gibt es ein besseres Beispiel?} % FIXME Bestimmt ;-) Was mir auffällt: Du scheinst doch nicht (nur) von links nach rechts auszuwerten, sondern eine Präzedenz der Operatoren zu haben (&& vor ||). Das musst Du auch aufschreiben (da, wo Du die Operatoren einführst).
      \myMinin{a || b && c} muss \myMinin{a} zuerst ausgewertet werden und dann \myMinin{b && c}, was das Baum wiedergeben muss). Und Variablendeklarationen, mit anschließender Wertzuweisung, müssen in zwei Schritte aufgeteilt werden (erst deklarieren und dann der Variablen den Wert zuweisen\footnote{
        Dies ist valider C Code: \myMinin{const int foo = foo + 1;}
      }).

    %---------------------------------
    % Abstrakter Syntaxbaum Paket
    %---------------------------------
    \subsubsection{Abstrakter Syntaxbaum Paket}
    \label{sssec:Abstrakter Syntaxbaum Paket}
      Wie \autoref{fig:AST_uml} zeigt, sind für alle
      Keywords % FIXME Sehe ich so direkt nicht. „do“ zum Beispiel finde ich nicht. Umformulieren?
      \footnote{
        Es wurden einigele Klassen hinter allgemeinen Begriffen -- wie \myMinin{Loop} -- versteckt, um etwas Übersicht zu bewahren.
      } Klassen von Nöten. Alle Klassen erben von der \myMinin{AST} Klasse,
      welche ein \myMinin{Token} besitzt. % FIXME nur eins???
                                          % TODO Attribut?
      Da die \myMinin{Token} alle Informationen über den Makro Quelltext haben und es sich bei der resultierenden Datenstruktur um einen
      Baum % FIXME Seltsamerweise kann man den Baum in der Abbildung gar nicht erkennen…
      handelt, ist auch der Interpreter in der Lage informative Fehlermeldungen zu generieren.
      \begin{figure}[H]
        \centering
        \myInput{img/AST_uml.tikz}
        \caption{Stammbaum der AST Klassen.}
        \label{fig:AST_uml}
      \end{figure}

      \autoref{fig:Scope_uml} zeigt die \myMinin{Scope} Klasse,
      diese Klasse kann beliebig viele andere \myMinin{AST} Instanzen aufnehmen. % FIXME Ach so, ein AST ist rekursiv definiert. Sag das doch!!
      Da das \myMinin{Scope} Instanzen von allen \myMinin{AST} Klassen aufnehmen kann, und einige Klassen wiederum ein \myMinin{Scope} besitzen, kommt es hier zu einem dependency circle. Weil das \myMinin{Scope} eine der meist benutzten Klassen ist, liegt die Auflösung des dependency circles bei den anderen Klassen.
      \begin{figure}[H]
        \centering
        \myInput{img/Scope_uml.tikz}
        \caption{Verbindungen vom Scope.}
        \label{fig:Scope_uml}
      \end{figure}

      \myMinin{Loop}, \myMinin{Function} und \myMinin{If} müssen den dependency circle mit \myMinin{Scope} auflösen. % FIXME 1.) Was ist das Problem bei Dependency Circle? 2.) Wie wird der aufgelöst?
      In \autoref{fig:Condition_uml} sind die restlichen Abhängigkeiten zwischen den \myMinin{AST} Klassen zu sehen.
      \begin{figure}[H]
        \centering
        \myInput{img/Condition_uml.tikz}
        \caption{Abhängigkeiten der AST Klassen}
        \label{fig:Condition_uml}
      \end{figure}

    %---------------------------------
    % Interpreter Paket
    %---------------------------------
    \subsubsection{Interpreter Paket} % FIXME Ich denke, das solltest Du insgesamt etwas detaillierter betrachten. Da steckt ja doch mehr drin, als man in 9 Zeilen plus Abbildung verstehen kann.
    \label{sssec:Interpreter Paket}
      Der \myMinin{Interpreter} nutzt den \myMinin{parser::Parser}, um einen \myMinin{ast::Scope} zu erzeugen, wie in \autoref{fig:interpreter_pack_uml} zu sehen ist.

      \begin{figure}[H]
        \centering
        \myInput{img/interpreter_pack_uml.tikz}
        \caption{Interpreter Beziehungen.}
        \label{fig:interpreter_pack_uml}
      \end{figure}

      Durch den \myMinin{OperatorProvider} als Mittelmann, ist es möglich Operatoren auf spezielle Objekte anzuwenden, die über die Datentypen der Literals hinausgehen.

      Während der Ausführung übernimmt der \myMinin{Stack} die Verwaltung der definierten Funktionen und Variablen sowie deren Werte. Bei jedem \myMinin{Scope}, wird der \myMinin{Stack} um eine Instanz von sich selber erweitert.

      Sollte der \myMinin{Stack} keine passende Funktion haben, wird der \myMinin{ExecutableProvider} gefragt, wodurch ein C++ \myMinin{Command} ausgeführt wird.

  %---------------------------------
  % Detaillierte Teilarchitekturen
  %---------------------------------
  \subsection{Detaillierte Teilarchitekturen}
  \label{ssec:Detaillierte Teilarchitekturen}
    In diesem Abschnitt werden die komplexeren Bestandteile der Architektur beschrieben. Der \myMinin{Tokenizer} hat keinen Zustand, da er nur einen stream von Zeichen aufteilen muss, und sollte daher nicht weiter beschrieben werden müssen. Dies gilt auch für alle \myMinin{ast} Klassen, da diese \emph{plain old data} (POD) Klassen sind und somit nur Daten verwalten.

    %---------------------------------
    % Parser Architektur
    %---------------------------------
    \subsubsection{Parser Architektur}
    \label{sssec:Parser Architektur}
      Da der \myMinin{Parser} recursive decent implementiert wird, kann der \myMinin{Parser} ohne einen Zustand -- sprich Attribute -- auskommen. In diesem Fall kann darauf verzichtet werden, den \myMinin{Parser} als Klasse zu implementieren und anstelle dessen eine paketglobale Funktion anzubieten. Dies hat den Vorteil, dass der \myMinin{Parser} garantiert Thread-Safe ist, da alle Daten von dem nativen Funktionsstack verwaltet werden.

      Für nahezu alle \myMinin{ast} Klassen bzw. keywords sollte der \myMinin{Parser} eine Methode zum parsen haben. Diese Modularität erlaubt es später den \myMinin{Parser} leichter zu erweitern, bzw. Fehler lokalisieren zu können. Da jede Methode genau für einen Teil der Syntax zuständig ist und es keinen Objekt Zustand gibt, können die Methoden für sich betrachtet und überprüft werden.

      Die Einstiegsmethode des \myMinin{Parser}s muss zusätzlich, zu dem zu parsenden \myMinin{string}, den Namen des Makros bzw. der Datei übergeben bekommen. Dies sorgt dafür, dass die Fehlermeldungen für den Benutzer eindeutig zuzuordnen sind.

      Die Fehlermeldungen sollten so viel Informationen wie möglich an den Nutzer liefern, ohne dass es sich um nutzlose Informationen handelt. So ist es für den Nutzer nicht nur wichtig, in welcher Zeile und Spalte der Fehler liegt, sondern auch in welchem Kontext. Das bedeutet, dass es einen Stack gibt (siehe
      \ref{enum:Mehr Fehler} % FIXME Hier bitte auf „Kapitel X“ verweisen, weil man später im gedruckten Dokument ja keinen Link verfolgen kann und die Nummer des Kapitels daher schon interessant ist.
      ), der dem Nutzer gezeigt werden kann. Sinnvoll ist es zB. alle Scopeanfänge anzugeben (Funktionen/Kontrollstrukturen). Durch diese Informationen ist der Nutzer sofort mit dem Kontext des Fehlers versorgt und kann über den Grund des Fehlers, oder die Lösung  nachdenken, während er zu der Zeile und Spalte navigiert.

\myTodo{operator precedence -  ! * / \% + - == ...}

% TODO Analyser

    %---------------------------------
    % OperatorProvider Architektur
    %---------------------------------
    \subsubsection{OperatorProvider Architektur}
    \label{sssec:OperatorProvider Architektur}
      Der \myMinin{OperatorProvider} ist eine Klasse, deren Aufgabe es ist, Datentypen Funktionen zuzuordnen und zur Verfügung zu stellen. Da die \myMinin{Operatoren} zustandslos sind\footnote{
        Dies kann nicht garantiert werde, es ist allerdings unwahrscheinlich, dass dies ein Problem ist.
      }, müssen die \myMinin{Operatoren} nur ein einziges mal registriert werden. Die \myMinin{Operatoren} für die \myMinin{ast::Literal} Klassen werden von dem \myMinin{OperatorProvider} automatisch registriert.

      Die Überladung von \myMinin{Operatoren} ist ausgeschlossen, ebenso ist nicht vorgesehen, dass Datentypen implizit konvertiert werden. Das heißt, dass ein \myMinin{char} \emph{nicht} zu einem \myMinin{int} promoted\footnote{
        Promoted bedeutet, dass ein kleinerer, primitiver Datentyp zu einem größeren implizit konvertiert werden kann. Dies ist immer dann möglich wenn kein Datenverlust auftritt.
      } werden kann, wie es in den meisten typisierten Programmiersprachen der Fall ist.
\myTodo{implizite convert operatoren? oder auch explizite?} % TODO

    %---------------------------------
    % Stack Architektur
    %---------------------------------
    \subsubsection{Stack Architektur}
    \label{sssec:Stack Architektur}
      Die \myMinin{Stack} Klasse ist der komplexeste Bestandteil des \myMinin{Interpreter}s. Der \myMinin{Stack} verwaltet alle Variablen und Funktionsdeklarationen, die ein Makro macht.

      Für die Variablen muss der \myMinin{Stack} einem \myMinin{string} eine \myMinin{any} Instanz zuweisen. Da keine überflüssigen Kopien bei der Übergabe von Parametern erzeugt werden sollen, muss der \myMinin{Stack} auch einen \myMinin{string} zu einer Referenz auf eine \myMinin{any} Instanz aus einem anderen \myMinin{Stack} erlauben.

      Die Funktionen brauchen nur als konstante Referenzen auf die Funktionsdefinitionen in dem \myMinin{ast} gespeichert werden. Diese Objekte werden nicht verändert und dienen nur als Vorlage, welche der \myMinin{Interpreter} interpretieren muss.

      Letztlich haben die \myMinin{Stack} Instanzen einen Pointer auf den
      \myMinin{Stack} `über' ihnen. % FIXME Das scheint schon wieder der rekursive Stack zu sein… Mach doch mal deutlich, wie der Stack aufgebaut ist!
      Diesen Pointer werden dann genutzt, um nach Variablen und Funktionsdeklarationen zu fragen. Im Fall, dass der \myMinin{Interpreter} nach einer Funktion fragt, kann der \myMinin{Stack} durch die verkettete Liste (siehe
      \ref{enum:linkedlist} % FIXME Hier bitte auf „Kapitel X“ verweisen, weil man später im gedruckten Dokument ja keinen Link verfolgen kann und die Nummer des Kapitels daher schon interessant ist.
      ) nicht nur die Funktionsdefinition zurückgeben, sondern auch gleich den Pointer auf den \myMinin{Stack}, in dem die Funktion definiert wurde. Es ist also nicht nötig, die Funktionen einem \myMinin{Stack} Pointer zuzuordnen, da dies automatisch geschieht.


    %---------------------------------
    % Interpreter Architektur
    %---------------------------------
    \subsubsection{Interpreter Architektur}
    \label{sssec:Interpreter Architektur}
      Die Architektur des \myMinin{Interpreter}s ist durch den \myMinin{ast} und \myMinin{Parser} relativ simpel. Außerdem lösen \myMinin{OperatorProvider} und \myMinin{Stack} die komplexesten Teile des \myMinin{Interpreter}s. Der \myMinin{Interpreter} ist ähnlich wie der \myMinin{Parser} recursive decent implementiert.

      Den AST interpretiert der \myMinin{Interpreter} in mehreren Schritten. Als erstes werden alle Funktionsdefinitionen interpretiert -- dies sorgt dafür, dass keine Definitionsreihenfolge eingehalten werden muss. Im zweiten Schritt wird das globale `root' \myMinin{ast::Scope} abgearbeitet -- das `root' \myMinin{ast::Scope} wird normal behandelt, was heißt, dass Funktionsaufrufe vor der \myMinin{main()} Methode erlaubt sind. Der letzte Schritt ist die Abarbeitung der Einstiegsfunktion \myMinin{main} mit allen Deklarationen und Funktionsaufrufen.

      Für jede \myMinin{ast} Klasse braucht der \myMinin{Interpreter} eine \myMinin{interpret()} Methode. Durch den Aufbau der \myMinin{ast} Klassen, endet der \myMinin{Interpreter} `immer' an einem Werterzeuger (Funktionsaufruf, Variable, \ldots), der von Kontrollstrukturen (\myMinin{if}, \myMinin{while}, \ldots) konsumiert wird.

      Wenn eine Funktion interpretiert werden soll, muss der \myMinin{Interpreter} Variablen, die als Parameter übergeben werden, dem \myMinin{Stack} der Funktion als Referenzen hinzufügen und anschließend das Scope der Funktion interpretieren. % FIXME Dieser Satz ist schwer lesbar; vermutlich auch, weil (wahrscheinlich) 1++ Kommafehler enthalten sind ;-)
      Das Zuweisen von Parametern verhält sich ähnlich wie bei JavaScript -- die Parameter werden als Referenz übergeben und nicht kopiert.
      Wenn dem Parameter ein neuer Wert zugewiesen wird, verändert sich der Wert aus dem aufrufendem Scope nicht. % FIXME Hä? Widerspricht das nicht dem Satz vorher?
      Wenn die aufzurufende Funktion allerdings von dem \myMinin{ExecutableProvider} kommt, werden die Parameter kopiert -- dies ist durch die C++ Ebene vorgegeben und wird normalerweise durch Pointer beschleunigt. Da die Parameternamen zu der Funktionssignatur gehören, ist es möglich mehrere Funktionen mit dem selben Namen anzulegen -- \myMinin{fun()} und \myMinin{fun(foo)} stehen also nicht in Konflikt. Wenn der \myMinin{Stack} keine entsprechende Funktion besitzt, wird der \myMinin{ExecutableProvider} nach einer Funktion gefragt.


      Wenn der \myMinin{Interpreter} einen \myMinin{Operator} zu interpretieren hat, kann dies in drei einfachen Schritten geschehen. Operatoren sind die kompliziertesten Strukturen und dienen daher als Beispiel, wie
      simple % FIXME
      der \myMinin{Interpreter} letztendlich geworden ist. % FIXME 1.) Simpel klingt hier nach Selbstlob ;-) Das machen wir dann schon… 2.) Nicht in der Vergangenheit / zurückblickend schreiben! Du schreibst immer über die Gegenwart, also so, als würdest Du den Interpreter in diesem Moment entwerfen.
      Im ersten Schritt interpretiert er den \myMinin{Operator} soweit, dass er einen/zwei Werterzeuger und einen Operatortyp (zB. \myMinin{==}) hat. Im zweiten Schritt wird der Werterzeuger zu einem Wert ausgewertet, mit dem im dritten Schritt, dann der \myMinin{Operator} vom \myMinin{OperatorProvider} aufgerufen wird.

      Wenn der \myMinin{Interpreter} eine Variable braucht, muss er nur den \myMinin{Stack} fragen.

      Da die \myMinin{ast} Instanzen das \myMinin{Token} besitzen, durch welches sie entstanden sind, ist der \myMinin{Interpreter} -- im Falle, dass kein passender \myMinin{Operator} oder Funktion gefunden werden können -- in der Lage genau so gute Fehlermeldungen zu produzieren, wie der \myMinin{Parser}.

% TODO Analyser

    %---------------------------------
    % Komplexe Rückgabewerte
    %---------------------------------
    \subsubsection{Komplexe Rückgabewerte}
    \label{sssec:Komplexe Rückgabewerte}
      Der Übergang von der C++ Ebene zu der Makro Ebene schien %FIXME Vergangenheit
      am Anfang nahe zu unmöglich, doch durch die Nutzung von dem \myMinin{any} Typ ist es erstaunlich `einfach'. % FIXME Bla bla… Sachlicher formulieren! -> Die Nutzung des any-Typs gestattet den Übergang von …

      Die \myMinin{interpret()} Methoden von dem \myMinin{Interpreter} geben alle einen \myMinin{any} Wert zurück. Dieser kann entweder
      invalid (keine Daten) oder valid (Daten) % FIXME Klingt schon wieder nach Swift (-> „Optionals“) ;-)
      sein. Der \myMinin{Interpreter} selber hat keine Ahnung, was sich in dem \myMinin{any} Typ befindet -- das ist nicht gut, aber der Preis, der gezahlt werden muss (da es keine Reflektion gibt). Dies provoziert Fehler, wenn die \myMinin{Executable}s aufgerufen werden und der erwartete Typ nicht übereinstimmt. Allerdings ist dieses Problem nicht `neu' -- die \myMinin{Executable}s sind von dem Problem ebenso geplagt -- was zur Folge hat, dass die \myMinin{any} Parameter für die \myMinin{Executable}s geprüft werden, bevor mit diesen gearbeitet wird.

      Die bis hier her beschriebene Architektur lässt sich sehr einfach in das Ziel (siehe \autoref{fig:abstract_goal_uml}) konvertieren. % FIXME Da staune ich aber! Die ganzen letzten Seiten willst / kannst Du auf drei Klassen abbilden??
      Der \myMinin{Interpreter} hat als Rückgabewert \myMinin{any}, so wie \myMinin{Executable}. Als Parameter kann der \myMinin{Interpreter} eine Liste von \myMinin{any} Werten -- die einem \myMinin{string} zugewiesen sind -- annehmen, sowie zwei \myMinin{string}s (Makro und Makro Name). \myMinin{Executable} können nur eine Liste von \myMinin{any} Werten, die einem \myMinin{string} zugeweisen sind, annehmen. Zwei \myMinin{any} Werte mehr in der Liste, als Makro und Makro Name löst das Problem der verschiedenen Anzahl von Parametern. Also muss ein \myMinin{Interpreter} nur von einem Wrapper (\myMinin{Marco}), der das \myMinin{Executable} Interface implementiert, umschlossen werden und das anfängliche Ziel ist erreicht.
\myFixme{Ist der letzte Absatz zu abstrakt?} % FIXME Wenn Du mit abstrakt unverständlich meinst: ja ;-)

%---------------------------------
% Exemplarische Realisierung
%---------------------------------
\section{Exemplarische Realisierung}
\label{sec:Exemplarische Realisierung}
  % TODO explain via example, split page in two right data (string ->tokenlist->ast->interpreter) left explanation
  % TODO mention test driven
\myFixme{Ich hätte hier vor, an Hand eines Beispieles, die ``Knackpunkte'' der einzelnen Klassen zu erklären, bzw. den Ablauf wieder zu spiegeln (String->Tokens->Parser/AST->Interpreter). Hört sich das gut an? (Code wäre getrimmt oder Pseudo-Code)} % FIXME Ja, hört sich gut an. Ein einfaches, durchgehendes Beispiel hat mir übrigens in Kapitel 3 gefehlt…

  \begin{myCodeEnv}
    \centering
    \begin{minipage}{.9\textwidth}
      \lstinputlisting[style=MyMacroStyle]{code/ex_macro.txt}
    \end{minipage}
    \caption{Interpreter Beziehungen.}
    \label{fig:ex_macro}
  \end{myCodeEnv}


  \columnratio{0.6}
  \columnsep25pt
  \begin{paracol}{2}[\subsection{Tokenizer}]
    %---------------------------------
    % Tokenizer
    %---------------------------------
    \label{ssec:Tokenizer}

      \textcolor{red}{Erklärung}

      Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum
    \switchcolumn
      \textcolor{red}{Beispiel}

      \begin{myCodeEnv}
        \lstinputlisting[lastline=20]{code/ex_tok.txt}
        \caption{Tokenized Makro}
        \label{fig:ex_tok}
      \end{myCodeEnv}

% ~\\ % BUG FIXME
    %---------------------------------
    % Parser
    %---------------------------------
    \switchcolumn*[\subsection{Parser}]
    \label{ssec:Parser}
      Lorem ipsum dolor sit amet \ldots
    \switchcolumn
      \begin{myCodeEnv}
        \lstinputlisting[lastline=20]{code/ex_ast.txt}
        \caption{Geparsed Makro}
        \label{fig:ex_ast}
      \end{myCodeEnv}

    %---------------------------------
    % Interpreterex_tok
    %---------------------------------
    \switchcolumn*[\subsection{Interpreter}]
    \label{ssec:Interpreter}
      Lorem ipsum dolor sit amet \ldots
    \switchcolumn
      Lorem ipsum dolor sit amet \ldots
  \end{paracol}

  %---------------------------------
  % Interpreterex_tok
  %---------------------------------
  \subsection{Fehlermeldungen}
  \label{ssec:Fehlermeldungen}
\myFixme{Ich vermute das ich in diesem Kapitel 6-8 Seiten zu schreiben habe, wenn es Vorschläge gibt, was noch niedergeschrieben werden sollte, bzw. ausführlicher erklärt werden muss, nur zu. Ich habe wie immer eher das Problem das ich zu wenig Text produziere.} % FIXME  Klingt vom Umfang her ok.
%---------------------------------
% Evaluation
%---------------------------------
\section{Evaluation}
\label{sec:Evaluation}
  % TODO compiler bugs
  % TODO ChaiScript http://chaiscript.com/ --- May 25, 2009 23fc75c  --- schlechte Fehlermeldungen

\myFixme{Ich habe \href{http://chaiscript.com/}{http://chaiscript.com/} gefunden. Quasi das was ich hier mache, bloß das die 9 Jahre Zeit hatten -- ich habe also einen Referenzpunkt! :)} % FIXME Das solltest Du gleich am Anfang (Einleitung oder Problemstellung) nennen und darstellen, warum Du einen eigenen Ansatz entwickelst. „Related Work“ fehlt in Deiner Arbeit ja leider völlig (habe ich zugegebenermaßen auch aus den Augen verloren).

%---------------------------------
% Zusammenfassung und Ausblick
%---------------------------------
\section{Zusammenfassung und Ausblick}
\label{sec:Zusammenfassung und Ausblick}

  %---------------------------------
  % Literatur
  %---------------------------------
  \subsection{Ausblick}
  \label{ssec:Ausblick}
    \begin{enumerate}[ref=Ausblick: Punkt \arabic*]
      \item Ausnutzung des ASTs\\
        Sofern alle Funktionen die ausgeführt werden sollen als thread-safe gekennzeichnet sind, kann das gesamte Macro parallel ausgeführt werden.
      \item Debugger / Stepping\\
        Es könnte ein Interface angeboten werde, mit dem man durch die Ausführung eines Macros Schritt für Schritt gehen kann.
      \item C++17 std::string\_view\\
        Um weniger Speicher zu verbrauchen und durch weniger Memory Allokationen schneller beim Tokenizen zu sein.
      \item Mehr Fehler von dem Parser\label{enum:Mehr Fehler}\\
        Anstelle, dass der Parser Exceptions nutzt und nach dem ersten Fehler aufhört zu parsen, ist es möglichen einen Stack von Fehlermeldungen zu produzieren. Nach einem Fehler müsste nur bis zum nächsten Scopeanfang ({), Scopeende(}) oder Semikolon(;) -- je nach dem wo der Fehler aufgetreten ist -- die Tokens verworfen werden und dann weiter geparst werden.
      \item Verkettete Stack Liste in ein Array umwandeln\label{enum:linkedlist}\\
        Wenn sich herausstellt, dass die verkettete Liste von dem Stack zu langsam ist, kann der Interpreter ein Array nutzen um die Stacks zu speichern, und die Stacks Nutzen anstelle eines Pointers einen Offset, von dem sie aus die anderen Stack fragen können.

        Dies Hätte zur Folge das der Nutzer mehr Fehler auf einmal beseitigen kann.
    \end{enumerate}


%---------------------------------
% Literatur
%---------------------------------
% \section*{Literatur}
% \label{sec:Literatur}
\microtypesetup{protrusion=false} % disables protrusion locally in the document
\printbibliography
\listoffigures
\listofmyCodeEnvTypes
\microtypesetup{protrusion=true} % disables protrusion locally in the document


%---------------------------------
% Anhänge
%---------------------------------
\section*{Anhänge}
\label{sec:Anhänge}
\addcontentsline{toc}{section}{Anhänge}

\end{document}
