%---------------------------------
% Preamble
%---------------------------------
\input{preamble.tex}

%---------------------------------
% Document start
%---------------------------------
\begin{document}

\listoftodos

%---------------------------------
% Titlepage
%---------------------------------
\input{titlepage.tex}

%---------------------------------
% table of contents
%---------------------------------
\tableofcontents
\newpage

%---------------------------------
% Allgemeines
%---------------------------------
\addsec{Allgemeines}
\label{sec:Allgemeines}
  %---------------------------------
  % Eidesstattliche Erklärung
  %---------------------------------
  \subsection*{Eidesstattliche Erklärung}
  \addcontentsline{toc}{subsection}{Eidesstattliche Erklärung}
  \label{ssec:Eidesstattliche Erklärung}
    Ich, \MetaAuthor, Matrikel-Nr. \MetaStudentNumber, versichere hiermit, dass ich meine Bachelorarbeit mit dem Thema
    \begin{center}
      \vspace*{-1em}
      \textit{\MetaTitle}
      \vspace*{-1em}
    \end{center}
    selbständig verfasst und keine anderen als die angegebenen Quellen und Hilfsmittel benutzt habe, wobei ich alle wörtlichen und sinngemäßen Zitate als solche gekennzeichnet habe. Die Arbeit wurde bisher keiner anderen Prüfungsbehörde vorgelegt und auch nicht veröffentlicht.

    \vspace*{3em}
    \begin{tabular}{@{}rc}
      \raisebox{.2em}{Bremen, den \today}
        &\makebox[4cm]{\hrulefill}\\
      {}
        &\MetaAuthor
    \end{tabular}

\pagebreak

  %---------------------------------
  % Danksagung
  %---------------------------------
  \subsection*{Danksagung}
  \addcontentsline{toc}{subsection}{Danksagung}
  \label{ssec:Danksagung}
    \myTodo{Danke an Mutter, Vater und alle Profs}

    \begin{figure}[H]
      \centering
      \begin{tikzpicture}[%
        spy using outlines={%
          circle,%
          Cornsilk,%
          magnification=2,%
          size=3.5cm,%
          connect spies%
        }%
      ]
        \node{
          \pgfimage[%
            interpolate=true,%
            width=.8\linewidth%
          ]{%
            img/bb%
          }
        };
        \spy on (.1,-.3) in node [left] at (-2,1.9);
      \end{tikzpicture}

      \caption{\textit{``Das soll meine Zukunft sein?''}}
    \end{figure}

\pagebreak

%---------------------------------
% Einleitung
%---------------------------------
\section{Einleitung}
\label{sec:Einleitung}
  Die Einführung von Automatisierung in ein Softwaresystem ist vergleichbar mit den Maschinen, die in der industrielle Revolution auftauchten. Anstelle, dass Menschen arbeiten müssen, um ein gewünschtes Ergebnis zu bekommen, drücken sie auf einen Knopf, und ein anderes System nimmt ihnen die aufwändige Arbeit ab. Dies führt dazu, dass Produkte schneller, mit weniger Arbeitsaufwand erstellt werden können. Zudem ist die entstehende Qualität immer auf einem gleichbleibenden Level und hängt nicht von dem Befinden der Arbeiter ab.

  Die P3-group arbeitet mit Airbus, um Lösungen für den Flugzeugbau zu entwickeln. Dieser Markt ist hart umkämpft, wodurch minimale Gewinne einen großen Unterschied machen können. Ein Feld, welches seit Jahren immer weiter durch wissenschaftliche und technische Durchbrüche optimiert wird, sind die menschlichen Ressourcen. Automatisierung sorgt dafür, dass sich wiederholende Arbeitsabläufe -- aus der Sicht des Nutzers -- zu einem einzigen Schritt werden und so Zeit sparen.

  Makros sind die Fließbänder der digitalen Welt, und diese Arbeit beschäftigt sich mit der Entwicklung eines Makro Systems bzw. Sprache.

  Makros werden durch die Verbindung kleinerer Bausteine (Anweisungen) erstellt. Diese können andere Makros oder Anweisungen, die die Anwendungsumgebung bereitstellt, sein. Dies ist mit einem Fließband in der Autoindustrie zu vergleichen. Jede Station ist genau für eine Aufgabe zuständig und kümmert sich um nichts anderes.

  Die Makrosprache ist ein Baukasten, mit dem Makros erstellt -- ``Fließbänder'' für spezielle Aufgaben erzeugt -- werden können.

  %---------------------------------
  % Problemfeld
  %---------------------------------
  \subsection{Problemfeld}
  \label{ssec:Problemfeld}
    Softwaresysteme haben oft das Problem, dass sie mit einigen zentralen Features anfangen, die fest definiert werden (sollten), bevor ein Vertrag geschlossen wird. Für weitere Funktionalität, die über die Vereinbarungen im Vertrag hinausgehen, muss der Vertrag erweitert werden. Wenn der Vertrag erfüllt ist, und im Anschluss weitere Wünsche aufkommen, muss ein weiterer Vertrag aufgesetzt werden und die vorher gelieferte Software muss angepasst, gegebenenfalls erweitert werden. Dies kann zur Folge haben, dass große Teile der Software umgeschrieben werden müssen, oder sogar, dass die Architektur der gesamten Anwendung verändert werden muss.

    Wenn frühzeitig ein Makrosystem/-sprache und ein entsprechendes Erweiterungskonzept für Module bzw. Plugins eingeführt wird, ist die Wahrscheinlichkeit, dass der Kern der Applikation für Erweiterungen angefasst werden muss, wesentlich geringer. Durch diese Kombination kann einfach ein weiteres Modul geladen werden, welches die neuen Grundbausteine der Applikation hinzufügt. Diese können dann in einem neuen, oder angepassten Makro genutzt werden, um den Wunsch der Kunden zu erfüllen. Im Falle, dass es keiner neuen Grundbausteine bedarf, reicht es sogar, nur ein Makro zu liefern. Die Vorteile dieser Methode sind, dass -- wenn man davon ausgeht, dass die benutzen Makros und Grundbausteine fehlerfrei durch ausreichendes Testen der Software sind -- keine neuen Bugs in den Kern der Software eingeführt werden können und somit immens zu der Stabilität der Software beigetragen wird. Ein weiterer Vorteil ist, dass die Makros mit wesentlich weniger Aufwand entwickelt werden können, weil sie sich auf einem höheren Level befinden. Für Kunden ist eine nutzbare Makrosprache auch interessant, weil sie zum Teil, durch das hausinterne Personal Anforderungen an die Software realisieren können, ohne den langen Weg über eine Firma zu gehen. Dies bedeutet auch, dass die Software eine bessere Chance hat, die Zeit zu überdauern.

  %---------------------------------
  % Ziele der Arbeit
  %---------------------------------
  \subsection{Ziele der Arbeit}
  \label{ssec:Ziele der Arbeit}
    Die Ziele der Arbeit sind es ein Makrosystem zu entwickeln, welches \ldots
    \begin{itemize}
      \item auf keinem festen \emph{Application Programming Interface (API)} aufbaut.

        Ein Feature der bestehenden Software ist es, dass sie durch \emph{Module}\footnote{
          Bibliotheken, die zur Laufzeit -- nach den dynamischen Bibliotheken --  nachgeladen werden können, um die Funktionalität der Applikation zu erweitern.
        } erweitert werden kann. Eines dieser Module wird das Makrosystem sein, welchen in dieser Arbeit entwickelt wird. Durch diese Modularität, gibt es kein festest Interface.

      \item nicht nur Anweisungen abarbeitet.

        Um eine große Bandbreite an Automatisierungsmöglichkeiten anbieten zu können, bedarf es logischer Ausdrücke, die bedingte Anweisungen erlauben. Ebenso ist es wichtig, dass man entscheiden kann, wie oft etwas ausgeführt werden soll.

      \item nicht mehr kann als es können muss.

        Je mächtiger ein System ist, desto komplexer ist es. Zudem sind Features nur etwas wert, wenn sie gewinnbringend verkauft werden können.

      \item wartbar ist.

        Die Implementierung sollte keine komplexen Bestandteile besitzen, über die nicht geschlussfolgert werden kann.
    \end{itemize}

  %---------------------------------
  % Hintergründe und Entstehung des Themas
  %---------------------------------
  \subsection{Hintergründe und Entstehung des Themas}
  \label{ssec:Hintergründe und Entstehung des Themas}
    Die P3-group ist daran interessiert, dass sie ihren Kunden Lösungen schnell und in hoher Qualität anbieten kann. Um dies zu erreichen arbeiten sie daran, dass alle Softwaresysteme, die von ihnen angeboten werden, Automatisierung über Makros unterstützen. Wirtschaftlich rentieren sich die Makros dadurch, dass sie von den Firmen gemietet und nicht nur einmal verkauft werden. Zum Beispiel, werden alle Flugzeugteile ausgewählt und dann deren Gewicht ermittelt. Ein anderes Mal sollen nur spezielle Teile aus einem bestimmten Werkstoff zusammen gezählt und deren Preis ermittelt werden. Anstelle, dass hier eine sehr komplexe Suchfunktion entwickelt wurde, können hier zwei Makros zum Einsatz kommen, die jeweils eine Aufgabe erfüllen und somit für den Benutzer sicher zu handhaben sind. Die Komplexität der Software wurde durch das zweite Makro nicht sonderlich beeinflusst, da dieses intern auf Funktionalität zurückgreifen kann, die schon vom ersten genutzt wird.

  %---------------------------------
  % Struktur der Arbeit, wesentliche Inhalte der Kapitel
  %---------------------------------
  \subsection{Struktur der Arbeit, wesentliche Inhalte der Kapitel}
  \label{ssec:Struktur der Arbeit, wesentliche Inhalte der Kapitel}
    Die Arbeit ist in drei wesentliche Kapitel aufgeteilt, \myNamedRef{sec:Anforderungsanalyse}, \myNamedRef{sec:Konzeption} und \myNamedRef{sec:Exemplarische Realisierung}. Der Fokus dieser Kapitel geht vom Theoretischen zum Praktischen. Innerlich folgen die Kapitel den Arbeitsabläufen, die zur Entwicklung des Makrosystems genutzt wurden. Zudem gibt es dies \hyperref[sec:Einleitung]{Einleitungs} Kapitel, eine \nameref{sec:Evaluation} und einen \nameref{sec:Ausblick}.

    In dem Kapitel \nameref{sec:Anforderungsanalyse} werden die Anforderungen, sowie deren Probleme analysiert. Das Kapitel \nameref{sec:Konzeption} beschäftigt sich mit den Lösungen für die Anforderungen sowie der Probleme, die im vorherigen Kapitel gefunden wurden. Unter anderem beinhaltet das Kapitel die Software Architektur, sowie den Syntax für die Makrosprache. In dem Kapitel \nameref{sec:Exemplarische Realisierung} wird auf entscheidende Punkte der exemplarischen Realisierung eingegangen.

%---------------------------------
% Anforderungsanalyse
%---------------------------------
\section{An\-for\-de\-rungs\-ana\-ly\-se}
\label{sec:Anforderungsanalyse}
  % TODO
  \myQuestion{Überschriften ohne Text sind böse, aber was kann ich hier schreiben?}

  %---------------------------------
  % Diskussion des Problemfeldes
  %---------------------------------
  \subsection{Diskussion des Problemfeldes}
  \label{ssec:Diskussion des Problemfeldes}
    Ein Makrosystem ist eine Komponente eines Softwaresystems, welche es erlaubt, die Software über eine Reihenfolge von Zeichen so zu steuern, als ob ein Mensch die Applikation bedient hätte.

    Die Funktionalität eines Makrosystems ist vergleichbar mit Programmiersprachen -- dort wird, durch eine Ansammlung von Zeichen, der Computer veranlasst, eine bestimmte Abfolge von Hardwareanweisungen auszuführen. Der Unterschied von einem Makrosystem zu zum Beispiel C ist, dass bei einem Makrosystem der Befehlssatz durch die Anwendung vorgegeben wird, wohingegen der Befehlssatz von C durch die Hardware vorgegeben ist. Somit ist ein Makrosystem eher mit einer Sprache zu vergleichen, die sich einer virtuellen Maschine bedient -- wie Java -- als mit C.
    Der Befehlssatz dieses Makrosystems kommt aus dem vorhandenen System, da dort das \emph{Command-Pattern}\autocite[S.263]{Gamma:1995:DPE:186897} eingesetzt wird und somit ein ideales Interface für Automatisierung bietet.

    Für
\myQuestion{Das ist alles ziemlich komprimiert -- muss das noch ausführlicher durchgekaut werden, oder ist das `Allgemeinwissen'?}
    alle Programmiersprachen ist es von Nöten, die Reihenfolge von Zeichen (String), in sinnvolle Stücke zu zerteilen -- dies übernimmt ein Tokenizer. Meist wird dieser in den Parser integriert, welcher die Stücken des Strings in ein Format bringt, welches der \emph{Interpreter}\autocite[S.274]{Gamma:1995:DPE:186897} verstehen kann. Das Format ist meist ein \emph{abstrakter Syntaxbaum (AST)}\footnote{%
      \textit{Abstract syntax tree} ist eine digitale Darstellung einer Programmiersprache.
    }, welcher den String eindeutig repräsentiert. Der Interpreter arbeitet dann nur noch mit dem AST, welcher vorgibt welche Befehle der Interpreter ausführen muss, um das als String angegebene Programm auszuführen.

    Das vorhandene System ist in C++ geschrieben, weswegen es sich größten Teils erübrigt über andere Programmiersprachen nachzudenken. Durch das \emph{name mangling}\footnote{
      Beim `name mangling' fügt der Compiler den Funktionsnamen weite Informationen hinzu, um eine eindeutige Funktionssignatur zu erhalten.
    } ist es schwierig eine API von C++ zu anderen Programmiersprachen anzubieten -- meistens geschieht dies über eine C API. Bei dieser verliert man den Vorteil der Objektorientierung und muss meistens auch die Daten zwischen C++$\longleftrightarrow$C und C$\longleftrightarrow$XYZ (z.B Python oder Lua) konvertieren, was langsam ist. Die Makros müssen aber auf Daten arbeiten, welche als Objekte von C++ vorliegen, deswegen müsste der Stack, mit dem der Interpreter arbeitet, in der C++ Ebene bleiben. Damit würde eine Implementierung von Tokenizer, Parser, AST und Interpreter die Wartbarkeit, durch die Teilung und die weitere Programmiersprache deutlich verschlechtern. Zusätzlich ist das Ziel eine Applikation zu automatisieren, und nicht durch komplett neue Funktionen zu erweitern, was die Vorteile von z.B Python größtenteils beseitigt.

  %---------------------------------
  % Anforderungen an die angestrebte Lösung
  %---------------------------------
  \subsection{Anforderungen an die angestrebte Lösung}
  \label{ssec:Anforderungen an die angestrebte Lösung}
    Die Herausforderung, ein Makrosystem/-sprache in C++ zu implementieren fängt dann an, wenn man von den Makros will, dass diese nicht nur hintereinander abgearbeitet werden, ohne dass sie wissen, dass andere Makros vor ihnen bzw. nach ihnen ausgeführt werden -- wie in \autoref{fig:sequential} zu sehen ist.

    \begin{figure}[H]
      \centering
      \includegraphics{img/sequential.tikz}
      \caption{Sequenzielles Abarbeiten von Prozessschritten.}
      \label{fig:sequential}
    \end{figure}

    \autoref{fig:logic} zeigt den ersten Schritt zu einer Herausforderung -- einer nützlichen Implementation -- Logik. Hierbei bietet man an, dass der Makro-Entwickler durch Rückgabewerte aus Makros entscheiden kann, welche weiteren Makros er ausführen möchte.

    \begin{figure}[H]
      \centering
      \includegraphics{img/logic.tikz}
      \caption{Logische Ausdrücke um bedingte Anweisungen zuzulassen.}
      \label{fig:logic}
    \end{figure}

    Obwohl man mit solchen Makros schon einige Probleme lösen kann, ist es nicht das, was man zur Verfügung haben will, wenn man mit objektorientierten Sprachen arbeitet bzw. mehr als ein \textit{`ja'} oder nein \textit{`nein'} braucht.

    Was ein Makrosystem/-sprache anbieten muss ist, dass Instanzen von verschiedenen Klassen/Typen zurückgegeben und beliebig viele Parameter (unterschiedlicher Klassen/Typen) dem Makro mitgegeben werden können. Leider sind gerade diese Punkte ein Problem in C++, weil C++ keine Reflexion\autocites{vinoski2005time}{ferber1989computational} unterstützt. Dies ist -- da es die Zeit, die für die Bachelorarbeit bereitsteht, mehrfach sprengt -- schon durch eine Implementation\footnote{%
      Das Command-Pattern wurde mit Hilfe des \texttt{any}\tablefootnote{%
        \url{http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3804.html}
      }
      sowie \texttt{optional}\tablefootnote{%
        \url{http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3793.html}
      }
      Types implementiert.
    }\spewnotes{}
    des Command-Patterns von gelöst worden. Somit kommt in diesem Schritt `nur' noch hinzu, dass es Schleifen geben kann, siehe \autoref{fig:loop}, und Rückgabewerte in Variablen speicherbar sind.

    \begin{figure}[H]
      \centering
      \includegraphics{img/loop.tikz}
      \caption{Schleife, die Anweisungen für ein Element aus der Liste aufrufen.}
      \label{fig:loop}
    \end{figure}

    Letztendlich kann man sagen, dass ein solches Makrosystem/-sprache eine Programmiersprache mit Interpreter ist, deren Laufzeitumgebung eine anderes Softwaresystem ist.

%---------------------------------
% Konzeption
%---------------------------------
\section{Konzeption}
\label{sec:Konzeption}
  %---------------------------------
  % Syntax
  %---------------------------------
  \subsection{Syntax}
  \label{ssec:Syntax}
    Der Syntax ist an C, Python, JavaScript und Swift angelegt. C liefert den größten Anteil des Syntax, von Python wurde \lstinline[style=MyMacroStyle]$def$ übernommen, von JavaScript \lstinline[style=MyMacroStyle]$var$ und der named parameter Syntax von Swift \lstinline[style=MyMacroStyle]$fun(foo:gun());$.  \lstinline[style=MyMacroStyle]$def$ und \lstinline[style=MyMacroStyle]$var$ sorgen dafür, dass der Programmierer nach den ersten drei Zeichen weiß, was als passieren wird. Das die Makrosprache named parameter unterstützt liegt daran, dass das CommandPattern so implementiert wurde, dass Parameter alias Bezeichnungen benutzen können, um eine hohe Kompatibilität zwischen unabhängig entwickelten Modulen zu gewährleisten.

    \begin{figure}[H]
      \centering
      \input{img/id_syntax.tikz}
      \caption{Bezeichner}
      \label{fig:id_syntax}
    \end{figure}
    Bezeichner müssen dem Regex aus \autoref{fig:id_syntax} entsprechen. Das heißt, dass Bezeichner nur aus keinen Buchstaben, Nummern und Unterstrichen bestehen können und am Anfang einen Buchstaben haben müssen. Grund für diese drastische Einschränkung ist, dass der Code einheitlich aussehen soll (die erste Regel was Bezeichnungen/Formatierung angeht ist, dass man sich an dem orientiert was schon existiert). Um dies besser garantieren zu können, wurde die CamelCase Schreibweise von vorn herein ausgeschlossen. Außerdem sind Bezeichner, die einem keyword entsprechen verboten.
    \myTodo{Liste von keywords.}

    \begin{figure}[H]
      \centering
      \input{img/vpr_syntax.tikz}
      \caption{Werterzeuger}
      \label{fig:vpr_syntax}
    \end{figure}
    \autoref{fig:vpr_syntax} zeigt alle Werterzeuger, dass sind Konstrukte, die einen Wert für eine andere Operation bereitstellen.

    \begin{figure}[H]
      \centering
      \input{img/var_syntax.tikz}
      \caption{Syntax der Variablendeklaration.}
      \label{fig:var_syntax}
    \end{figure}
    Variablen können, wie in \autoref{fig:var_syntax} zu sehen ist, definiert werden: \lstinline[style=MyMacroStyle]$var foo;$. Um nach der Definition einen Wert der Variablen zu zuweisen, ist es erlaubt unter anderem dies zu tun: \lstinline[style=MyMacroStyle]$var foo = fun();$ oder \lstinline[style=MyMacroStyle]$var foo = true == false;$.

    \begin{figure}[H]
      \centering
      \input{img/fun_syntax.tikz}
      \caption{Syntax der Funktionsdeklaration.}
      \label{fig:fun_syntax}
    \end{figure}
    Funktionen können über \lstinline[style=MyMacroStyle]$def fun(){...}$ definiert werden, was \autoref{fig:fun_syntax} zeigt. Um eine parametrisierte Funktion zu definieren, gibt man die Parameternamen, Komma getrennt, nach dem Funktionsnamen an: \lstinline[style=MyMacroStyle]$def fun(foo, bar){...}$. Der Einstiegspunkt eines jeden Makros ist eine \lstinline[style=MyMacroStyle]$def main(){...}$ Funktion. Der Syntax ist der selbe zu normalen Funktionen, und erlaubt es daher auch Parameter übergeben zu bekommen. Deswegen können die Makros aus anderen Makros, oder aus der C++ Ebene über einen äquivalenten Syntax aufgerufen werden.

    \begin{figure}[H]
      \centering
      \input{img/cal_syntax.tikz}
      \caption{Syntax von Funktionsaufrufen.}
      \label{fig:call_syntax}
    \end{figure}
    \autoref{fig:call_syntax} zeigt den Syntax um eine definierte Funktion aufzurufen. \lstinline[style=MyMacroStyle]$fun(foo:gun(), bar:foo);$ weißt dem \lstinline[style=MyMacroStyle]$foo$ Parameter den Wert von \lstinline[style=MyMacroStyle]$gun()$ zu und dem Parameter \lstinline[style=MyMacroStyle]$bar$ wird der Wert von \lstinline[style=MyMacroStyle]$foo$ aus dem Scope zugewiesen. Das zuweisen verhält sich ähnlich wie bei JavaScript -- die Parameter werden als Referenz übergeben und nicht kopiert. Wenn dem Parameter ein neuer Wert zugewiesen wird, verändert sich, im Gegensatz zu JavaScript, auch der Wert aus dem aufrufendem Scope.

    \begin{figure}[H]
      \centering
      \input{img/common_syntax.tikz}
      \caption{Syntax allgemeiner Strukturen.}
      \label{fig:common_syntax}
    \end{figure}

    \begin{figure}[H]
      \centering
      \input{img/scope_syntax.tikz}
      \caption{Syntax vom Scope.}
      \label{fig:scope_syntax}
    \end{figure}

    \begin{figure}[H]
      \centering
      \input{img/loop_scope_syntax.tikz}
      \caption{Syntax vom LoopScope.}
      \label{fig:loop_scope_syntax}
    \end{figure}
    Abbildungen \ref{fig:common_syntax}, \ref{fig:scope_syntax} und \ref{fig:loop_scope_syntax} zeigen den Syntax von einem Scope. Scopes sind Bestandteile von Funktionen und Loops, wobei sich Loop Scopes von normalen scopes nur darin unterscheiden, dass sie das \lstinline[style=MyMacroStyle]$break$ Keyword unterstützen. Scopes verhalten sich wie C Scopes, das heißt, dass der Syntax \lstinline[style=MyMacroStyle]${var foo; {var foo;}}$ richtig ist, und das erste \lstinline[style=MyMacroStyle]$foo$ von dem zweiten verdeckt wird.

    \begin{figure}[H]
      \centering
      \input{img/ret_syntax.tikz}
      \caption{Syntax von return.}
      \label{fig:return_syntax}
    \end{figure}
    In \autoref{fig:return_syntax} ist der Syntax von \lstinline[style=MyMacroStyle]$return$ zu sehen.

    \begin{figure}[H]
      \centering
      \input{img/op_syntax.tikz}
      \caption{Syntax von Operatoren.}
      \label{fig:op_syntax}
    \end{figure}
    Der Operator Syntax aus \autoref{fig:op_syntax} sollte, ähnlich wie der \lstinline[style=MyMacroStyle]$return$ Syntax, nicht all zu überraschend sein. Geklammerte Ausdrücke werden zuerst vollständig ausgewertet, bevor der Operator angewendet wird. Das heißt, dass \lstinline[style=MyMacroStyle]$(a || b)  && c$ folgender Weise interpretiert wird. \lstinline[style=MyMacroStyle]$a$ oder \lstinline[style=MyMacroStyle]$b$ wird zuerst ausgewertet und deren Ergebnis wird mit \lstinline[style=MyMacroStyle]$c$ genutzt. Entgegen dessen wird bei \lstinline[style=MyMacroStyle]$a || b && c$ zuerst \lstinline[style=MyMacroStyle]$a$, und dann \lstinline[style=MyMacroStyle]$b$ und \lstinline[style=MyMacroStyle]$c$ ausgewertet.

    \begin{figure}[H]
      \centering
      \input{img/if_syntax.tikz}
      \caption{Syntax von if.}
      \label{fig:if_syntax}
    \end{figure}

    \begin{figure}[H]
      \centering
      \input{img/while_syntax.tikz}
      \caption{Syntax von while.}
      \label{fig:while_syntax}
    \end{figure}

    \begin{figure}[H]
      \centering
      \input{img/do_while_syntax.tikz}
      \caption{Syntax von do-while.}
      \label{fig:do_while_syntax}
    \end{figure}
    Die Syntax von \lstinline[style=MyMacroStyle]$if/else$ und \lstinline[style=MyMacroStyle]$do-/while$ aus den Abbildungen \ref{fig:if_syntax}, \ref{fig:while_syntax} und \ref{fig:do_while_syntax} sollten wie erwartet aussehen.

    \begin{figure}[H]
      \centering
      \input{img/lit_syntax.tikz}
      \caption{Syntax von Literals.}
      \label{fig:lit_syntax}
    \end{figure}
    Literals sind entweder Doubles, Integer, Strings oder Boolean Werte, wie \autoref{fig:lit_syntax} zeigt.

\myTodo{For Schleife}
\myTodo{For-each Schleife}

  %---------------------------------
  % Level 1 -- Grundarchitektur
  %---------------------------------
  \subsection{Level 1 -- Grundarchitektur}
  \label{ssec:Level 1 -- Grundarchitektur}
    % TODO Architektur
    % keine Ausführung auf dem AST, da ein separater stack
    % https://en.wikipedia.org/wiki/Recursive_descent_parser - easiest to maintain, and understand. Slower than LL and LR (scott2010gll)
    % https://en.wikipedia.org/wiki/LL_parser - not as powerfull as LR, still tidious to implement
    % https://en.wikipedia.org/wiki/LR_parser - no LR parser as too complex, would be possible with a parser generator. (No option because extra software, more breakage)
    % http://stackoverflow.com/a/6319216/1935553 gcc clang handwritten parser
    % TODO parser nicht strickt def fun() == def fun      ()
  %---------------------------------
  % Level 2 -- Logik / primitive Rückgabewerte
  %---------------------------------
  \subsection{Level 2 -- Logik / primitive Rückgabewerte}
  \label{ssec:Level 2 -- Logik / primitive Rückgabewerte}

  %---------------------------------
  % Level 3 -- Komplexe Rückgabewerte
  %---------------------------------
  \subsection{Level 3 -- Komplexe Rückgabewerte}
  \label{ssec:Level 3 -- Komplexe Rückgabewerte}

%---------------------------------
% Exemplarische Realisierung
%---------------------------------
\section{Exemplarische Realisierung}
\label{sec:Exemplarische Realisierung}
  %---------------------------------
  % Tokenizer
  %---------------------------------
  \subsection{Tokenizer}
  \label{ssec:Tokenizer}

  %---------------------------------
  % Abstrakter Syntaxbaum
  %---------------------------------
  \subsection{Abstrakter Syntaxbaum}
  \label{ssec:Abstrakter Syntaxbaum}

  %---------------------------------
  % Parser
  %---------------------------------
  \subsection{Parser}
  \label{ssec:Parser}

  %---------------------------------
  % Interpreter
  %---------------------------------
  \subsection{Interpreter}
  \label{ssec:Interpreter}

  %---------------------------------
  % Makro
  %---------------------------------
  \subsection{Makro}
  \label{ssec:Makro}

%---------------------------------
% Evaluation
%---------------------------------
\section{Evaluation}
\label{sec:Evaluation}
  % TODO compiler bugs

%---------------------------------
% Zusammenfassung und Ausblick
%---------------------------------
\section{Zusammenfassung und Ausblick}
\label{sec:Zusammenfassung und Ausblick}

  %---------------------------------
  % Literatur
  %---------------------------------
  \subsection{Ausblick}
  \label{sec:Ausblick}
    \begin{itemize}
      \item Ausnutzung des ASTs\\
        Sofern alle Funktionen die ausgeführt werden sollen als thread-safe gekennzeichnet sind, kann das gesamte Macro parallel ausgeführt werden.
      \item Debugger / Stepping\\
        Es könnte ein Interface angeboten werde, mit dem man durch die Ausführung eines Macros Schritt für Schritt gehen kann.
      \item C++17 std::string\_view\\
        for better parsing performance and less memory consumption.
    \end{itemize}


%---------------------------------
% Literatur
%---------------------------------
\section{Literatur}
\label{sec:Literatur}
  \nocite{*} % TODO remove
  \printbibliography[heading=none]

%---------------------------------
% Anhänge
%---------------------------------
\section{Anhänge}
\label{sec:Anhänge}

\end{document}
