%---------------------------------
% Preamble
%---------------------------------
\input{preamble.tex}

\begin{document}

%---------------------------------
% Titlepage
%---------------------------------
\maketitle
    \note[enumerate] {
      \item Moin, ihr kennt alle meinen Namen und \ldots
      \item Da wir nur wenig Zeit haben, muss ich euch in den nächsten 20 min $15.000$ Zeilen Code erkläre. Das sind 750 Zeilen pro Minute \ldots
    }

%---------------------------------
% Themen
%---------------------------------
\begin{frame}{Themen} % TODO good?
  \setbeamertemplate{section in toc}[sections numbered]
  \tableofcontents[hideallsubsections]
\end{frame}
    \note[enumerate] {
      \item Da ich das allerdings keinem zumuten kann, werde ich in den folgenden Folien meine Arbeit sehr abstrakt erklären. Und in der Demo nur ein wenig auf den Code eingehen. Wodurch euch langweiliger C++ Code größten Teils erspart bleibt. Wer im Anschluss fragen zum Code hat -- ich werde gerne Fragen beantworten (und länger über den Code reden, als euch recht ist)
      \item Ich habe nichts dagegen, wenn während der Präsentation Fragen gestellt werden -- für allgemeine Fragen bietet es sich an diese vor der Demo zu stellen.
    }

% TODO C++ bitte möglichst klein halten. Interessanter ist ein Querschnitt durch die Arbeit, also von Anforderungen über Konzeption bis Realisierung und Eval - das kann (auch) man alles schön anhand von Konzepten machen, ohne sich in Programmiersprachendetails zu verlieren. Mir fallen da u.a. anderem ein: Makros, Command-Pattern, Architektur, die Kette Tokenizer -> Parser -> Interpreter, ... Fokussiere Dich auf zentrale Ideen - welche das sind, musst letztendlich Du entscheiden (Syntax würde ich ebenfalls klein halten (max. 1 Folie)).

%---------------------------------
% Was?
%---------------------------------
\section{Was?}
  \begin{frame}{Was ist eine Makrosprache?}
    \begin{itemize}[<+- | alert@+>]
      \item
        Eine Programmiersprache
            \note[item]<.>{
              Eine Makrosprache ist mit euch bekannten Programmiersprachen zu vergleichen.
            }
            \note[item]<.>{
              Makros werden genutzt, um eintönige Arbeitsabläufe zu automatisieren. Das ist mit Fließbändern, die in der industriellen Revolution aufgekommen sind zu vergleichen.
            }
            \note[item]<.>{
              Makros führen also Befehle aus, die der Nutzer hätte ausführen können und baut nicht auf einer anderen Programmiersprache auf, sondern auf den Befehlen die die Anwendung anbietet. Das ist mit den Befehlen von Sprachen zu vergleichen, die eine Virtuelle Maschine nutzen. Im Fall der Makrosprache ist die Anwendung die Virtuelle Maschine. Es macht (sollte) also kein Unterschied (machen), ob ein Makro auf Windows geschrieben wurde und dann auf Linux oder XOS ausgeführt wird.
            }

      \item
        Eine Möglichkeit statische Systeme zu dynamischen umzuwandeln
            \note[item]<.>{
              Makros sind Strings, also eine Reihenfolge von Zeichen, die erst zur Laufzeit der Anwendung erstellt werden. Diese werden entweder von dem Benutzer erzeugt oder z.B. von einer Datei gelesen. Das bedeutet, dass die Strings nicht zur Zeit der Entwicklung bzw. der Kompilierung oder der Auslieferung des Softwaresystems bekannt sein müssen.
            }
            \note[item]<.>{
              Makros bieten es den Nutzer also an, eine Anwendung um ``Funktionalität'' zu erweitern, ohne das diese erweitert werden muss.
            }

      \item
        Kein Script
            \note[item]<.>{
              Das Ergebnis soll keine Scriptsprache sein. Zwar kann sich eine Makrosprache wie ein Script anfühlen, sollte aber keines sein.
            }
            \note[item]<.>{
              Der Unterschied von Makros und Scripts liegt vor allem darin, dass Scripts komplett neue Funktionalitäten erzeugen und Makros genutzt werden um vorhandene Funktionen zu automatisieren.
            }
            \note[item]<.>{
              Es ist ein kleiner Unterschied, der allerdings große Folgen hat. Eine Scriptsprache sollte eine wesentlich größere API anbieten, z.B. call-backs und threads support. Diese beiden würden ermöglichen es Scripten anzubieten, die nicht durch den Benutzer direkt angestoßen werden können und asynchron ihre Funktionen ausführen.
            }
            \note[item]<.>{
              Man könnte also sagen das Makros zu den schwächsten Programmiersprachen zählen.
            }
    \end{itemize}
  \end{frame}

  \begin{frame}{Was ist die Gegebenheiten?}
    \begin{itemize}[<+- | alert@+>]
      \item
        C++
            \note[item]<.>{
              Die Anwendung, für diese Makrosprache entwickelt wird ist in C++ geschrieben.
            }
            \note[item]<.>{
              Das hat den Vorteil, dass die Anwendung das Potenzial hat extrem effizient und schnell zu arbeiten.
            }
            \note[item]<.>{
              Ein Nachteil ist, dass C++ eine statische Sprache ist -- also nach dem Kompilieren nicht verändert werden kann, was ausgeführt werden soll. Wäre sie in z.B. Python geschrieben, wären Makros nur ein Python Script welches geladen und abgearbeitet wird.
            }
      \item<+- | alert@+-+(1)>
        Command-Pattern\tikzmark{cmd-pattern}{}%
            \note[item]<.>{
              Das Command-Pattern der Anwendung ist die Schnittstelle die die Makrosprache nutzt um die Anwendung zu verändern.
            }
        \begin{uncoverenv}<+->%
          \begin{tikzpicture}[overlay, remember picture]%
            \node[right=-2of cmd-pattern] (commanduml) {%
              \myInput{img/commanduml.tikz}%
            };
          \end{tikzpicture}%
          \begin{uncoverenv}<.>%
            \begin{tikzpicture}[overlay, remember picture]%
              \node[anchor=north east] (commanduml-cat_surprised) {\includegraphics[width=.5\linewidth]{img/cat_surprised}};
            \end{tikzpicture}%
          \end{uncoverenv}%
              \note[item]<.>{
                Nur weil wir die 750 Zeilen pro Minute sein lassen, heißt es nicht das es einfach wird!
              }
              \note[item]<.>{
                Aber es sieht schlimmer aus als es ist\ldots
              }
          \action{}
        \end{uncoverenv}
            \note[item]<.>{
              Der \myMin{Invoker} wird an den \myMin{Client} geben, der den \myMin{CommandProvider} nach einem \myMin{Command} fragt.
            }
            \note[item]<.>{
              Der \myMin{Client} kann z.B ein Knopf in einer GUI sein.
            }
            \note[item]<.>{
              Der \myMin{HistoryStack} sorgt dafür, dass \myMin{Command}s rückgängig gemacht bzw. wiederhergestellt werden können.
            }
            \note[item]<.>{
              Das \myMin{Command} ist die Elternklasse von dem Konkreten Command welches seine Funktionalität in der \myMin{execute} Methode implementiert.
            }
            \note[item]<.>{
              Wichtig zu beachten ist die \myMin{map<string, any>} von dem \myMin{Command} diese erlaubt es beliebig viele Daten, mit beliebigen Datentypen, typsicher als Parameter zu übergeben -- ohne die Methodensignatur zu verändern.
            }
    \end{itemize}
  \end{frame}

%---------------------------------
% Anforderungen
%---------------------------------
\section{Anforderungen}
  % \begin{frame} FIXME
  % \end{frame}

%---------------------------------
% Konzeption
%---------------------------------
\section{Konzeption}
  %---------------------------------
  % Syntax
  %---------------------------------
  \begin{frame}{Syntax}
  \end{frame}

  %---------------------------------
  % Klassen
  %---------------------------------
  \begin{frame}{Klassen}
  \end{frame}

\note{Everything you want}
%---------------------------------
% Realisierung
%---------------------------------
\section{Realisierung}
  %---------------------------------
  % Tokenizer
  %---------------------------------
  \begin{frame}{Tokenizer}
  \end{frame}
  %---------------------------------
  % Parser
  %---------------------------------
  \begin{frame}{Parser} % TODO mention Analyser
    \note{Analyser}
  \end{frame}
  %---------------------------------
  % Interpreter
  %---------------------------------
  \begin{frame}{Interpreter}
  \end{frame}
  %---------------------------------
  % Probleme
  %---------------------------------
  \begin{frame}{Probleme} % TODO Compiler Fehler, any
  \end{frame}

%---------------------------------
% Fragen
%---------------------------------
  \begin{frame}[standout]
    Fragen?
  \end{frame}

%---------------------------------
% Demo
%---------------------------------
  \section{Demo}

  \appendix
%---------------------------------
% Referenzen
%---------------------------------
  \begin{frame}[allowframebreaks]{Referenzen}
    % \bibliography{demo} FIXME
    % \bibliographystyle{abbrv} FIXME
  \end{frame}
\end{document}

