%---------------------------------
% Preamble
%---------------------------------
\input{preamble.tex}

\begin{document}

%---------------------------------
% Titlepage
%---------------------------------
\maketitle
    \note[enumerate] {
      \item Moin, ihr kennt alle meinen Namen und \ldots
      \item Da wir nur wenig Zeit haben, muss ich euch in den nächsten 20 min $15.000$ Zeilen Code erklären. Das sind 750 Zeilen pro Minute \ldots
    }

%---------------------------------
% Themen
%---------------------------------
\begin{frame}{Themen} % TODO good?
  \setbeamertemplate{section in toc}[sections numbered]
  \tableofcontents[hideallsubsections]
\end{frame}
    \note[enumerate] {
      \item Da ich das allerdings keinem zumuten kann, werde ich in den folgenden Folien meine Arbeit sehr abstrakt erklären. Und in der Demo nur ein wenig auf den Code eingehen. Wodurch euch C++ Code größten Teils erspart bleibt.
      \item Wer im Anschluss Fragen zum Code hat -- ich werde gerne Fragen beantworten (und wahrscheinlich länger über den Code reden, als euch recht ist).
      \item Fragen können vor und nach der Demo gestellt werde. Nachdem meine Professoren ihre Fragen gestellt haben, werde ich auch gerne Fragen von den Zuschauern beantworten, da ich möchte, dass jeder etwas von meiner Präsentation mitnehmen kann.
    }

% TODO C++ bitte möglichst klein halten. Interessanter ist ein Querschnitt durch die Arbeit, also von Anforderungen über Konzeption bis Realisierung und Eval - das kann (auch) man alles schön anhand von Konzepten machen, ohne sich in Programmiersprachendetails zu verlieren. Mir fallen da u.a. anderem ein: Makros, Command-Pattern, Architektur, die Kette Tokenizer -> Parser -> Interpreter, ... Fokussiere Dich auf zentrale Ideen - welche das sind, musst letztendlich Du entscheiden (Syntax würde ich ebenfalls klein halten (max. 1 Folie)).

%---------------------------------
% Was?
%---------------------------------
\section{Was?}
    \note[itemize]{
      \item Fangen wir mit einer einfachen Frage an: `Was?'. \ldots
    }

  %---------------------------------
  % Was ist eine Makrosprache?
  %---------------------------------
  \begin{frame}{Was ist eine Makrosprache?}
    \pause
        \note[item]<.>{
          Was ist eine Makrosprache?
        }

    \begin{itemize}[<+- | alert@+>]
      \item
        Eine Programmiersprache
            \note[item]<.>{
              Eine Makrosprache ist mit euch bekannten Programmiersprachen zu vergleichen.
            }
            \note[item]<.>{
              Makros werden genutzt, um eintönige Arbeitsabläufe zu automatisieren.
            }
            \note[item]<.>{
              Makros führen also Befehle aus, die der Nutzer hätte ausführen können. Somit ist eine Makrosprache eine der höchsten (abstraktesten) Programmiersprachen.
            }
            \note[item]<.>{
              Zu vergleichen ist das am ehesten mit den Sprachen, die eine Virtuelle Maschine nutzen. Im Fall der Makrosprache ist die Anwendung die Virtuelle Maschine. Es sollte also kein Unterschied machen, ob ein Makro auf Windows geschrieben wurde und dann auf Linux oder XOS ausgeführt wird.
            }

      \item
        Eine Möglichkeit statische Systeme zu dynamischen umzuwandeln
            \note[item]<.>{
              Makros sind dynamisch.
            }
            \note[item]<.>{
              Makros sind Strings -- also eine Reihenfolge von Zeichen -- die erst zur Laufzeit der Anwendung erstellt werden. Diese werden entweder von dem Benutzer erzeugt oder z.B. von einer Datei gelesen. Das bedeutet, dass die Strings nicht zur Zeit der Entwicklung bzw. der Kompilierung oder der Auslieferung des Softwaresystems bekannt sein müssen.
            }
            \note[item]<.>{
              Makros bieten den Nutzer an, eine Anwendung um Funktionen zu erweitern, ohne das die Anwendung erweitert werden muss.
            }

      \item
        Kein Script
            \note[item]<.>{
              Eine Makrosprache soll keine Scriptsprache sein. Zwar kann sich eine Makrosprache wie ein Script anfühlen, sollte aber keine sein.
            }
            \note[item]<.>{
              Der Unterschied von Makros und Scripts liegt vor allem darin, dass Scripts komplett neue Funktionalitäten erzeugen und Makros genutzt werden um vorhandene Funktionen zu automatisieren. -- Also ein Subset von Script darstellen.
            }
            \note[item]<.>{
              Es ist ein kleiner Unterschied -- der allerdings große Folgen hat. Eine Scriptsprache sollte eine wesentlich größere API anbieten, z.B. call-backs und threads support. Diese beiden würden Scripts ermöglichen, die nicht durch den Benutzer direkt angestoßen werden müssen und asynchron ihre Funktionen ausführen -- z.B. eine automatische Sicherung nach 5 Minuten.
            }
    \end{itemize}
  \end{frame}

  %---------------------------------
  % Was war die Gegebenheiten?
  %---------------------------------
  \begin{frame}{Was war die Gegebenheiten?}
    \pause
        \note[item]<.>{
          Was war gegeben?
        }

    \begin{itemize}[<+- | alert@+>]
      \item
        C++
            \note[item]<.>{
              Die Anwendung, für die diese Makrosprache entwickelt wurde, ist in C++ geschrieben.
            }
            \note[item]<.>{
              Das hat den Vorteil, dass die Anwendung das Potenzial hat extrem effizient und schnell zu arbeiten.
            }
            \note[item]<.>{
              Ein Nachteil ist, dass C++ eine statische Sprache ist -- also nach dem Kompilieren nicht verändert werden kann was ausgeführt werden soll.
            }
            \note[item]<.>{
              Wäre sie in z.B. Python geschrieben, wären Makros nur ein weiteres Python Script welches geladen und abgearbeitet werden würde. (Was ziemlich einfach wäre zu implementieren.)
            }
      \item<+- | alert@+-+(2)>
        Command-Pattern\tikzmark{cmd-pattern}{}%
            \note[item]<.>{
              Ein zentrales Element ist eine implementation des CommandPatterns.
            }
            \note[item]<.>{
              Das Command-Pattern der Anwendung, ist die Schnittstelle, die die Makrosprache nutzt, um mit der Anwendung zu interagieren.
            }
        \begin{uncoverenv}<+->%
          \begin{tikzpicture}[overlay, remember picture]%
            \node[right=-2of cmd-pattern] (commanduml) {%
              \myInput{img/commanduml.tikz}%
            };
          \end{tikzpicture}%
          \begin{uncoverenv}<.>%
            \begin{tikzpicture}[overlay, remember picture]%
              \node[anchor=north east] (commanduml-cat_surprised) {\includegraphics[width=.5\linewidth]{img/cat_surprised}};
            \end{tikzpicture}%
          \end{uncoverenv}%
              \note[item]<.>{
                Nur weil wir die 750 Zeilen pro Minute sein lassen, heißt es nicht das es einfach wird!
              }
              \note[item]<.>{
                Ich werde euch die wichtigsten Elemente präsentieren, die bei der Entwicklung der Makrosprache, bzw. Programmiersprache, durchlaufen wurden.
              }
              \note[item]<.>{
                Dazu zählt auch dieses UML Diagramm, welches eine wichtige Grundlage ist. -- Es sieht schlimmer aus als es ist\ldots
              }
          \action{}
        \end{uncoverenv}
            \note[item]<.>{
              Der \textbf{Invoker} wird von dem \textbf{CommandProvider} an den \textbf{Client} gegeben, der den nach nach einem \textbf{Command} gefragt hat.
            }
            \note[item]<.>{
              Der \textbf{Client} kann z.B ein Knopf in einer GUI sein.
            }
            \note[item]<.>{
              Der \textbf{HistoryStack} sorgt dafür, dass \textbf{Command}s rückgängig gemacht bzw. wiederhergestellt werden können.
            }
            \note[item]<.>{
              Das \textbf{Command} ist die Elternklasse von dem \textbf{ConcreteCommand} welche ihre Funktionalität in der \textbf{execute} Methode implementiert.
            }
            \note[item]<.>{
              Wichtig zu beachten ist die \textbf{map<string, any>} von dem \textbf{Command} diese erlaubt es beliebig viele Daten, mit beliebigen Datentypen, typsicher als Parameter zu übergeben -- ohne die Methodensignatur zu verändern. Der any Typ wird in C++17 enthalten sein.
            }
    \end{itemize}
  \end{frame}

%---------------------------------
% Anforderungen
%---------------------------------
\section{Anforderungen}
    \note[enumerate]{
      \item Anforderungen an die Lösung\ldots
    }

  \begin{frame}{Anforderungen}
    \begin{itemize}
      \item<+- | alert@+-+(1)>
        Dynamisches Typesystem
            \note[item]<.>{
              Die Makros sollten davon profitieren, dass die Commands Rückgabewerte und Parameter haben. Das heißt, dass es eine Möglichkeit geben muss, dass ``unbekannte'' Datentypen zwischengespeichert werden.
            }
            \note[item]<.>{
              Es soll also möglich sein so etwas zu schreiben \ldots
            }
        \begin{uncoverenv}<+->%
          \tabto{4.6cm}
          \myMIn$var a = 10; a = "10";$
        \end{uncoverenv}
            \note[item]<.>{
              Hier wird der Variable \myMin{a} beim ersten Mal ein Integer zugewiesen und beim zweiten Mal ein String.
            }
            \note[item]<.>{
              Die Lösung für das zwischenspeichern ist der any Typ, der von dem Command-Pattern genutzt wird.
            }
      \item<+- | alert@+-+(1)>
        Kontrollfluss
            \note[item]<.>{
              Makros sollten eine Möglichkeit haben, auf den zustand der Anwendung zu reagieren.

              Ein Beispiel wäre \ldots
            }
        \begin{uncoverenv}<+->
          \tabto{4.6cm}
          \myMIn$if(has_unsaved()) \{ save(); \}$\hspace*{-4cm} % Fixes unwanted linebreak
        \end{uncoverenv}
            \note[item]<.>{
              Das ein Makro nur probiert zu speichern, wenn es etwas zum speichern gibt.
            }
            \note[item]<.>{
              Generell sollte speichern schnell gehen, allerdings kann es passieren, dass eine mehrere Gigabyte große Datei geschrieben werden muss, was dem Nutzer nicht zumuten ist.
            }
      \item<+- | alert@+-+(2)>
        Benutzerfreundlichkeit
            \note[item]<.>{
              Die Makrosprache soll für den Benutzer leicht zu verstehen sein \ldots
            }
        \begin{uncoverenv}<+-+>
          \begin{myInvBox}[width=.9\linewidth]
            \lstinputlisting[style=MyMacroStyle, backgroundcolor=, numbers=none, frame=,]{img/exmacro.txt}
          \end{myInvBox}
          \vspace{-10em}
        \end{uncoverenv}
            \note[item]<.>{
              Der Syntax sollte also deutlich machen, was passieren wird.
            }
            \note[item]<.>{
              Durch \myMIn$def$ wird automatisch klar, das eine Funktion definiert wird und \myMIn$var$ definiert eine Variable.
            }
            \note[item]<.>{
              Da die Implementation des CommandPatterns eine Map nutzt, um die Command Parameter anzugeben, habe ich mich entschieden named parameter zu nutzen, um das überladen von Funktionen anhand der Parameternamen zu ermöglichen. (\textbf{foo:bar})
            }
            \note[item]<.>{
              Aber in meine Augen ist Syntax nur ein kleiner Punkt\ldots
            }

        \begin{uncoverenv}<+->
          \begin{myInvBox}[width=.9\linewidth]
            \lstinputlisting[backgroundcolor=, numbers=none, frame=]{img/error2.txt}
          \end{myInvBox}
          \vspace{-6em}
        \end{uncoverenv}
            \note[item]<.>{
              Wenn der Nutzer einen Fehler macht, soll dieser möglichst einfach zu finden sein -- man will mit einem Tool arbeiten, nicht dagegen kämpfen.
            }
            \note[item]<.>{
              Die Fehlermeldungen müssen dem Nutzer nicht nur sagen was falsch ist, sondern auch wo und weshalb.
            }
            \note[item]<.>{
              In dem Beispiel wurde ein Semikolon in der main Methode vergessen, was die beiden Fehlermeldungen schnell deutlich machen.
            }
        \onslide<+->
            \note[item]<.>{
              Neben der Wartbarkeit war auch die Macht dieser Makrosprache wichtig.
            }
            \note[item]<.>{
              Wie der Syntax gezeigt hat, geht die Sprache in die Richtung von Scripts, man kann Funktionen anlegen, primitive Datentypen nutzen und hat Kontrollstrukturen zur Verfügung.
            }
            \note[item]<.>{
              Da die Makros letztendlich nur auf Commands arbeiten können, ist das Gefahrenpotenzial -- was von unwissenden Nutzern ausgeht -- größtenteils eingeschränkt.
            }
    \end{itemize}
  \end{frame}

%---------------------------------
% Konzeption
%---------------------------------
\section{Konzeption}
    \note[enumerate]{
      \item Konzeption
      \item Die folgende Liste zeigt nicht nur, was entwickelt werden musste, sondern bildet auch den Ablauf beim Ausführen eines Makros ab.
    }

  %---------------------------------
  % Was wurde entwickelt?
  %---------------------------------
  \begin{frame}{Was wurde entwickelt?}
    \begin{itemize}[<+- | alert@+>]
      \item<+- | alert@+-+(1)>
        Tokenizer
            \note[item]<.>{
              Ein Tokenizer.
            }
            \note[item]<.>{
              Der Tokenizer muss den String / das Makro zu einer Liste von Tokens verwandeln \ldots
            }
        \begin{uncoverenv}<+-+>%
          \begin{tikzpicture}[overlay, remember picture, railroad]%
            \node[anchor=west, yshift=-1em] at (page cs:-.4,0) (tokenizerMacro) {%
              \begin{myInvBox}[width=.36\linewidth]%
                \lstinputlisting[style=MyMacroStyle, backgroundcolor=, numbers=none, frame=,]{img/exmacro_2.txt}%
              \end{myInvBox}%
            };%
            \node[right=1of tokenizerMacro] (tokenizerTokens) {%
              \begin{myInvBox}[width=.9\linewidth]%
                \lstinputlisting[backgroundcolor=, numbers=none, frame=,]{img/exmacro_2_tok.txt}%
              \end{myInvBox}%
            };%
            \graph[railroad]{(tokenizerMacro)->(tokenizerTokens);};%
          \end{tikzpicture}%
        \end{uncoverenv}%
            \note[item]<.>{
              Wichtig ist, dass bei dem erstellen der Liste, keine Informationen verloren gehen.
            }
            \note[item]<.>{
              Die Reihenfolge wird durch das Tokenizen zwar nicht verändert, allerdings gehen überflüssige Leerzeichen und Zeilenumbrüche verloren.
            }
            \note[item]<.>{
              Diese sind für Fehlermeldungen extrem wichtig und müssen für die Tokens mitgespeichert werden.
            }

      \item
        \temporal<.>{}{Abstrakter Syntaxbaum}{AST}
            \note[item]<.>{
              Klassen die einen abstrakten Syntaxbaum bilden.
            }
            \note[item]<.>{
              Ein Abstrakter Syntaxbaum beschreibt den Syntax aus dem Makro, ohne  Informationsverlust. ASTs werden genutzt, da es einfacher ist mit ihnen als Datenstruktur zu arbeiten, als mit einem String.
            }
            \note[item]<.>{
              Die meisten Elemente des Syntaxes lassen sich als Klasseninstanzen in dem AST wiederfinden. Prominente Ausnahmen sind Klammern, Semikolons und Leerzeichen.
            }
      \item<+- | alert@+-+(1)>
        Parser\tikzmark{parser}{}%
            \note[item]<.>{
              Ein Parser.
            }
            \note[item]<.>{
              Der Parser ist dafür zuständig, dass die Liste von Tokens in einen abstrakten Syntaxbaum umgewandelt werden.
              \ldots
            }%
        \begin{uncoverenv}<+-+>%
          \begin{tikzpicture}[overlay, remember picture, railroad]%
            \node[anchor=west, yshift=-1em] at (page cs:-.4,0) (parserMacro) {%
              \begin{myInvBox}[width=.28\linewidth]%
                \lstinputlisting[backgroundcolor=, numbers=none, frame=,]{img/exmacro_2_tok.txt}%
              \end{myInvBox}%
            };%
            \node[right=.5of parserMacro] (parserTokens) {%
              \begin{myInvBox}[width=.9\linewidth]%
                \lstinputlisting[backgroundcolor=, numbers=none, frame=,]{img/exmacro_2_ast.txt}%
              \end{myInvBox}%
            };%
            \graph[railroad]{(parserMacro)->($(parserTokens.west)+(0:.6)$);};%
            \end{tikzpicture}%
        \end{uncoverenv}%
            \note[item]<.>{
              Das heißt, dass der Parser, die Tokens in diese Form überführen muss.
            }%
            \note[item]<.>{
              Die \textbf{@-Symbole} weisen auf eine Objektinstanz hin und das was in den Klammern eingeschlossen ist, ist ein Bestandteil des umschließenden Objektes.
            }%
      \item<+- | alert@+-+(1)>
        Analyser\tikzmark{analyser}{}%
            \note[item]<.>{
              Ein Analyser.
            }
            \note[item]<.>{
              Der Analyser ist dafür da, um Fehler zu finden, die nicht aus dem Parsen hervorgehen. Also Fehler die nicht syntaktisch sind, oder nur schwer beim Parsen zu finden sind.
              \ldots
            }
        \begin{uncoverenv}<+-+>%
          \begin{tikzpicture}[overlay, remember picture]%
            \node[coordinate] at (page cs:-.4,0) (analyserMacroHelper){};
            \node[anchor=north west, yshift=.6em] at (analyserMacroHelper |- analyser) (analyserMacro) {%
              \myMIn$def fun()\{ break; \}$
            };%
          \end{tikzpicture}%
        \end{uncoverenv}
            \note[item]<.>{
              Ein Beispiel wäre die Funktion \myMin{fun}.
              }
            \note[item]<.>{
              Der AST kann den Code darstellen. Eine Funktionsdefinition, die in dem Funktionsscope ein break Element hat.
            }
            \note[item]<.>{
              Bloß macht dies wenig Sinn, da \myMin{break} nur in Schleifen eine Funktion hat.
            }
      \item
        Interpreter
            \note[item]<.>{
              Letztlich bedarf es einem Interpreter.
            }
            \note[item]<.>{
              Der Interpreter interpretiert den AST, den der Parser erzeugt hat und ist die Komponente -- bzw. der Client aus dem CommandPattern -- der die Commands ausführt.
            }
            \note[item]<.>{
              Somit kommen wir zu wir \ldots (zu weiteren UML Diagrammen)
            }
    \end{itemize}
  \end{frame}

  %---------------------------------
  % AST Klassenhierarchie
  %---------------------------------
  \begin{frame}{AST Klassenhierarchie}
    \begin{uncoverenv}<+>%
      \begin{tikzpicture}[overlay, remember picture]%
        \node[anchor=center] at (page cs:0,0) (commanduml-cat_surprised) {\includegraphics[width=.6\linewidth]{img/grumpy_cat}};
      \end{tikzpicture}%
    \end{uncoverenv}%
        \note[item]<.>{
          Zu weiteren UML Diagrammen.
        }
        \note[item]<.>{
          Für meinen Geschmack helfen die Diagramme nicht genug.
        }
        \note[item]<.>{
          Sie sind aber die beste Möglichkeit, die ich kenne, anderen Menschen mein Wissen, über die Datenstrukturen, zu übertragen.
        }

    \begin{actionenv}<+->
      \begin{tikzpicture}[remember picture,overlay,every node/.style={anchor=center}]%
        \node at(current page.center) (ASTuml) {%
          \scalebox{.9}{%
            \myInput{img/ASTuml.tikz}%
          }
        };
      \end{tikzpicture}%
          \note[item]<.>{
            Die AST Klassenhierarchie.
          }
          \note[item]<.>{
            Alle abstrakten Syntax Klassen haben die \textbf{AST} Klasse als Elternklasse. Diese hat ein \textbf{Token}, welches das Stück des Makros enthält, welches das Objekt repräsentieren soll.
          }
    \end{actionenv}
  \end{frame}

  \begin{frame}{AST Scope}
    \begin{tikzpicture}[remember picture,overlay,every node/.style={anchor=center}]%
      \node at(current page.center) (Scopeuml) {%
        \scalebox{.7}{%
          \myInput{img/Scopeuml.tikz}%
        }
      };
    \end{tikzpicture}%
        \note[item]{
          Die Scope Abhängigkeiten.
        }
        \note[item]{
          Das \textbf{Scope} kann Instanzen von allen Klassen aufnehmen.
        }
        \note[item]{
          Durch die Aufnahme von anderen AST Instanzen wird hier ein Teil des Baumes erstellt.
        }
  \end{frame}

  \begin{frame}{AST Klassen}
    \begin{tikzpicture}[remember picture,overlay,every node/.style={anchor=center}]%
      \node at(current page.center) (Conditionuml) {%
        \scalebox{.7}{%
          \myInput{img/Conditionuml.tikz}%
        }
      };
    \end{tikzpicture}%
        \note[item]{
          Dieses UML Diagramm zeigt die restlichen Abhängigkeiten der Klassen -- die meisten Verbindungen sollten Selbstverständlich sein.
        }
        \note[item]{
          Eine \textbf{Funktion} besteht aus einem \textbf{Scope}. Ein \textbf{Loop} besteht aus einem \textbf{Scope} und einer \textbf{Condition}. Eine \textbf{Condition} kann aus \textbf{Variablen}, \textbf{Funktionsaufrufen} usw. bestehen.
        }
  \end{frame}

  \begin{frame}{Parser Klassen}
    \begin{tikzpicture}[remember picture,overlay,every node/.style={anchor=center}]%
      \node at(current page.center) (parserpackuml) {%
        \scalebox{.7}{%
          \myInput{img/parserpackuml.tikz}%
        }
      };
    \end{tikzpicture}%
        \note[item]{
          Die Parser Klassen.
        }
        \note[item]{
          Der \textbf{Parser} nutzt den \textbf{Tokenizer} um eine \textbf{TokenList} von dem Makrostring zu erstellen.
        }
        \note[item]{
          Diese TokenListe wandelt er dann in einen \textbf{AST} um.
        }
        \note[item]{
          Der produzierte AST wird dann von dem \textbf{Analyser} überprüft.
        }
  \end{frame}

  \begin{frame}{Interpreter Klassen}
    \begin{uncoverenv}<+-+>%
      \begin{tikzpicture}[remember picture,overlay,every node/.style={anchor=center}]%
        \node at(current page.center) (interpreterpackuml) {%
            \myInput{img/interpreterpackuml.tikz}%
        };
      \end{tikzpicture}%
          \note[item]<.>{
            Letztlich die Interpreter Klassen.
          }
          \note[item]<.>{
            Der \textbf{Interpreter} nutzt den \textbf{Parser} um einen AST zu erzeugen, den er dann interpretieren kann.
          }
          \note[item]<.>{
            Um dies zu tun, muss der Interpreter auch Daten verwalten. Das wird von dem \textbf{Stack} übernommen.
          }
          \note[item]<.>{
            Der Stack bildet einen Stack mit Instanzen von sich selber \ldots
          }
    \end{uncoverenv}
    \begin{uncoverenv}<+-+(1)>%
      \begin{tikzpicture}[remember picture,overlay,every node/.style={anchor=center}]%
        \node at(current page.center) (stackex) {%
            \myInput{img/stackex.tikz}%
        };
      \end{tikzpicture}%
          \note[item]<.>{
            Diese Art und Weise einen Stack aufzubauen ist normal in C oder C++.
          }
          \note[item]<.>{
            In dem Beispiel wird der Stack durch die drei Stack Instanzen (\textbf{1, 2 und 3}) gebildet.
          }
          \note[item]<.>{
            Ein späteres Beispiel wird wahrscheinlich mehr Aufschluss über die Funktionsweise bringen. \ldots (Denn dafür wisst ihr noch zu wenig.)
          }

      \begin{uncoverenv}<+>%
        \begin{tikzpicture}[overlay, remember picture]%
          \node[anchor=center] at (page cs:.5,-.5) (commanduml-no_you_didnt_cat) {\reflectbox{\includegraphics[width=.5\linewidth]{img/no_you_didnt_cat}}};
        \end{tikzpicture}%
      \end{uncoverenv}%
          \note[item]<.>{
            Denn dafür wisst ihr noch zu wenig. Nehmt es erst einmal so hin, das dies Sinnvoll ist.
          }
    \end{uncoverenv}

    \begin{uncoverenv}<+-+>%
      \begin{tikzpicture}[remember picture,overlay,every node/.style={anchor=center}]%
        \node at(current page.center) (interpreterpackuml) {%
            \myInput{img/interpreterpackuml.tikz}%
        };
      \end{tikzpicture}%
          \note[item]<.>{
            Der \textbf{OperatorProvider} wird von dem Interpreter genutzt um die \textbf{Operator}en -- wie $+$ und $-$ auf Variablen anzuwenden.
          }
          \note[item]<.>{
            Die Nutzung eines OperatorProviders sorgt dafür, dass Operatoren für beliebige Datentypen angeboten werden können, ohne den Interpreter anzupassen.
          }
          \note[item]<.>{
            Der Code, des OperatorProviders ist sehr Interessant -- leider haben wir nicht genug Zeit um diesen durchzugehen. Deswegen muss ich euch mit dem any Typ abspeisen, der auch hier ein wichtiger Eckpunkt ist.
          }
          \note[item]<.>{
            Um Funktionsaufrufe auszuführen -- die nicht zu selber definierten Funktionen führen -- nutzt der Interpreter den \textbf{CommandProvider}.
          }
    \end{uncoverenv}
  \end{frame}

%---------------------------------
% Realisierung
%---------------------------------
\section{Realisierung}
    \note[enumerate]{
      \item Das war die trockene Theorie.
      \item In den Folgenden Folien werde ich an dem Vorherigen Beispiel die einzelnen Schritte erklären, die beim Interpretieren durchlaufen werden.
    }

  %---------------------------------
  % Tokenizer
  %---------------------------------
  \begin{frame}{Tokenizer}
  \end{frame}
  %---------------------------------
  % Parser
  %---------------------------------
  \begin{frame}{Parser} % TODO mention Analyser
    \note{Analyser}
  \end{frame}
  %---------------------------------
  % Interpreter
  %---------------------------------
  \begin{frame}{Interpreter}
  \end{frame}
  %---------------------------------
  % Probleme
  %---------------------------------
  \begin{frame}{Probleme} % TODO Compiler Fehler, any
  \end{frame}

%---------------------------------
% Fragen
%---------------------------------
  \begin{frame}[standout]
    Fragen?
  \end{frame}
      \note[itemize]{
        \item \textbf{Katzen:} Ich habe genug theoretische und zum teil langweilige Präsentationen in meinem Studium gesehen. Dem Trend wollte ich nicht folgen -- und auch wenn meine Präsentation nicht so viel Wissen vermittelt hat, hatte sie zumindest Katzen. Wer reine Theorie will, ist mit meiner THesis besser beraten als mit mir.
      }

%---------------------------------
% Demo
%---------------------------------
  \section{Demo}

  \appendix
%---------------------------------
% Referenzen
%---------------------------------
  \begin{frame}[allowframebreaks]{Referenzen}
    % \bibliography{demo} FIXME
    % \bibliographystyle{abbrv} FIXME
  \end{frame}
\end{document}

