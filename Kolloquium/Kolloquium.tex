%---------------------------------
% Preamble
%---------------------------------
\input{preamble.tex}

\begin{document}

%---------------------------------
% Titlepage
%---------------------------------
\maketitle
    \note[enumerate] {
      \item Moin, ihr kennt alle meinen Namen und \ldots
      \item Da wir nur wenig Zeit haben, muss ich euch in den nächsten 20 min $15.000$ Zeilen Code erkläre. Das sind 750 Zeilen pro Minute \ldots
    }

%---------------------------------
% Themen
%---------------------------------
\begin{frame}{Themen} % TODO good?
  \setbeamertemplate{section in toc}[sections numbered]
  \tableofcontents[hideallsubsections]
\end{frame}
    \note[enumerate] {
      \item Da ich das allerdings keinem zumuten kann, werde ich in den folgenden Folien meine Arbeit sehr abstrakt erklären. Und in der Demo nur ein wenig auf den Code eingehen. Wodurch euch langweiliger C++ Code größten Teils erspart bleibt. Wer im Anschluss fragen zum Code hat -- ich werde gerne Fragen beantworten (und länger über den Code reden, als euch recht ist)
      \item Ich habe nichts dagegen, wenn während der Präsentation Fragen gestellt werden -- für allgemeine Fragen bietet es sich an diese vor der Demo zu stellen.
    }

% TODO C++ bitte möglichst klein halten. Interessanter ist ein Querschnitt durch die Arbeit, also von Anforderungen über Konzeption bis Realisierung und Eval - das kann (auch) man alles schön anhand von Konzepten machen, ohne sich in Programmiersprachendetails zu verlieren. Mir fallen da u.a. anderem ein: Makros, Command-Pattern, Architektur, die Kette Tokenizer -> Parser -> Interpreter, ... Fokussiere Dich auf zentrale Ideen - welche das sind, musst letztendlich Du entscheiden (Syntax würde ich ebenfalls klein halten (max. 1 Folie)).

%---------------------------------
% Was?
%---------------------------------
\section{Was?}
  \begin{frame}{Was ist eine Makrosprache?}
    \begin{itemize}[<+- | alert@+>]
      \item
        Eine Programmiersprache
            \note[item]<.>{
              Eine Makrosprache ist mit euch bekannten Programmiersprachen zu vergleichen.
            }
            \note[item]<.>{
              Makros werden genutzt, um eintönige Arbeitsabläufe zu automatisieren. Das ist mit Fließbändern, die in der industriellen Revolution aufgekommen sind zu vergleichen.
            }
            \note[item]<.>{
              Makros führen also Befehle aus, die der Nutzer hätte ausführen können und baut nicht auf einer anderen Programmiersprache auf, sondern auf den Befehlen die die Anwendung anbietet. Das ist mit den Befehlen von Sprachen zu vergleichen, die eine Virtuelle Maschine nutzen. Im Fall der Makrosprache ist die Anwendung die Virtuelle Maschine. Es macht (sollte) also kein Unterschied (machen), ob ein Makro auf Windows geschrieben wurde und dann auf Linux oder XOS ausgeführt wird.
            }

      \item
        Eine Möglichkeit statische Systeme zu dynamischen umzuwandeln
            \note[item]<.>{
              Makros sind Strings, also eine Reihenfolge von Zeichen, die erst zur Laufzeit der Anwendung erstellt werden. Diese werden entweder von dem Benutzer erzeugt oder z.B. von einer Datei gelesen. Das bedeutet, dass die Strings nicht zur Zeit der Entwicklung bzw. der Kompilierung oder der Auslieferung des Softwaresystems bekannt sein müssen.
            }
            \note[item]<.>{
              Makros bieten es den Nutzer also an, eine Anwendung um ``Funktionalität'' zu erweitern, ohne das diese erweitert werden muss.
            }

      \item
        Kein Script
            \note[item]<.>{
              Das Ergebnis soll keine Scriptsprache sein. Zwar kann sich eine Makrosprache wie ein Script anfühlen, sollte aber keines sein.
            }
            \note[item]<.>{
              Der Unterschied von Makros und Scripts liegt vor allem darin, dass Scripts komplett neue Funktionalitäten erzeugen und Makros genutzt werden um vorhandene Funktionen zu automatisieren.
            }
            \note[item]<.>{
              Es ist ein kleiner Unterschied, der allerdings große Folgen hat. Eine Scriptsprache sollte eine wesentlich größere API anbieten, z.B. call-backs und threads support. Diese beiden würden ermöglichen es Scripten anzubieten, die nicht durch den Benutzer direkt angestoßen werden können und asynchron ihre Funktionen ausführen.
            }
            \note[item]<.>{
              Man könnte also sagen das Makros zu den schwächsten Programmiersprachen zählen.
            }
    \end{itemize}
  \end{frame}

  \begin{frame}{Was ist die Gegebenheiten?}
    \begin{itemize}[<+- | alert@+>]
      \item
        C++
            \note[item]<.>{
              Die Anwendung, für diese Makrosprache entwickelt wird ist in C++ geschrieben.
            }
            \note[item]<.>{
              Das hat den Vorteil, dass die Anwendung das Potenzial hat extrem effizient und schnell zu arbeiten.
            }
            \note[item]<.>{
              Ein Nachteil ist, dass C++ eine statische Sprache ist -- also nach dem Kompilieren nicht verändert werden kann, was ausgeführt werden soll. Wäre sie in z.B. Python geschrieben, wären Makros nur ein Python Script welches geladen und abgearbeitet wird.
            }
      \item<+- | alert@+-+(1)>
        Command-Pattern\tikzmark{cmd-pattern}{}%
            \note[item]<.>{
              Das Command-Pattern der Anwendung ist die Schnittstelle die die Makrosprache nutzt um die Anwendung zu verändern.
            }
        \begin{uncoverenv}<+->%
          \begin{tikzpicture}[overlay, remember picture]%
            \node[right=-2of cmd-pattern] (commanduml) {%
              \myInput{img/commanduml.tikz}%
            };
          \end{tikzpicture}%
          \begin{uncoverenv}<.>%
            \begin{tikzpicture}[overlay, remember picture]%
              \node[anchor=north east] (commanduml-cat_surprised) {\includegraphics[width=.5\linewidth]{img/cat_surprised}};
            \end{tikzpicture}%
          \end{uncoverenv}%
              \note[item]<.>{
                Nur weil wir die 750 Zeilen pro Minute sein lassen, heißt es nicht das es einfach wird!
              }
              \note[item]<.>{
                Aber es sieht schlimmer aus als es ist\ldots
              }
          \action{}
        \end{uncoverenv}
            \note[item]<.>{
              Der \myMin{Invoker} wird an den \myMin{Client} geben, der den \myMin{CommandProvider} nach einem \myMin{Command} fragt.
            }
            \note[item]<.>{
              Der \myMin{Client} kann z.B ein Knopf in einer GUI sein.
            }
            \note[item]<.>{
              Der \myMin{HistoryStack} sorgt dafür, dass \myMin{Command}s rückgängig gemacht bzw. wiederhergestellt werden können.
            }
            \note[item]<.>{
              Das \myMin{Command} ist die Elternklasse von dem Konkreten Command welches seine Funktionalität in der \myMin{execute} Methode implementiert.
            }
            \note[item]<.>{
              Wichtig zu beachten ist die \myMin{map<string, any>} von dem \myMin{Command} diese erlaubt es beliebig viele Daten, mit beliebigen Datentypen, typsicher als Parameter zu übergeben -- ohne die Methodensignatur zu verändern.
            }
    \end{itemize}
  \end{frame}

%---------------------------------
% Anforderungen
%---------------------------------
\section{Anforderungen}
  \begin{frame}{Anforderungen}
    \begin{itemize}
      \item<+- | alert@+-+(1)>
        Dynamisches Typesystem
            \note[item]<.>{
              Die Makros sollten davon profitieren, dass die Commands Rückgabewerte und Parameter haben. Das heißt, dass es eine Möglichkeit geben muss, dass ``unbekannte'' Datentypen zwischengespeichert werden müssen.
            }
            \note[item]<.>{
              Es soll also möglich sein so etwas zu schreiben \ldots
            }
        \begin{uncoverenv}<+->%
          \tabto{4.5cm}
          \myMIn$var a = 10; a = "10";$
        \end{uncoverenv}
            \note[item]<.>{
              Hier wird der Variable \myMin{a} beim ersten Mal ein Integer zugewiesen und beim zweiten Mal ein String.
            }
            \note[item]<.>{
              Die Lösung für das zwischenspeichern ist der any Typ der der von dem Command-Pattern genutzt wird. Dieser wird in C++17 enthalten sein.
            }
      \item<+- | alert@+-+(1)>
        Kontrollfluss
            \note[item]<.>{
              Makros sollten eine Möglichkeit haben, auf den zustand der Anwendung zu reagieren.

              Ein Beispiel wäre \ldots
            }
        \begin{uncoverenv}<+->%
          \tabto{4.5cm}
          \myMIn$if(has_unsaved()) \{ save(); \}$
        \end{uncoverenv}
            \note[item]<.>{
              Das ein Makro nur probiert zu speichern, wenn es etwas zum speichern gibt. Generell sollte speichern schnell gehen, allerdings kann es passieren, dass eine mehrere Gigabyte große Datei geschrieben werden muss, was man dem Nutzer nicht zumuten möchte.
            }
      \item<+- | alert@+-+(2)>
        Benutzerfreundlichkeit\tikzmark{user-x}{}%
            \note[item]<.>{
              Die Makrosprache soll für den Benutzer leicht zu verstehen sein \ldots
            }
        \begin{uncoverenv}<+-+>%
          \begin{myInvBox}[width=.9\linewidth]
            \lstinputlisting[style=MyMacroStyle, backgroundcolor=, numbers=none, frame=,]{img/exmacro.txt}
          \end{myInvBox}
          \vspace{-10em}
        \end{uncoverenv}
            \note[item]<.>{
              Der Syntax sollte deutlich machen was passiert.
            }
            \note[item]<.>{
              Durch \myMIn$def$ wird automatisch klar, das eine Funktion definiert wird und \myMIn$var$ definiert eine Variable.
            }
            \note[item]<.>{
              Da die Implementation des CommandPatterns eine Map nutzt um die Command Parameter anzugeben, nutzt der Syntax named parameter.
            }
            \note[item]<.>{
              Aber Syntax nur ein kleiner Punkt\ldots
            }

        \begin{uncoverenv}<+->%
          \begin{myInvBox}[width=.9\linewidth]
            \lstinputlisting[backgroundcolor=, numbers=none, frame=]{img/error2.txt}
          \end{myInvBox}
          \vspace{-6em}
        \end{uncoverenv}
            \note[item]<.>{
              Wenn der Nutzer einen Fehler macht, soll dieser möglichst einfach zu finden sein.
            }
            \note[item]<.>{
              Die Fehlermeldungen müssen dem Nutzer nicht nur sagen was falsch ist, sondern woher sie kommen.
            }
        \onslide<+->
            \note[item]<.>{
              Neben der Wartbarkeit war auch die Macht dieser Makrosprache wichtig.
            }
            \note[item]<.>{
              Wie der Syntax gezeigt hat, geht die Sprache in die Richtung von Scripts, man kann Funktionen anlegen, primitive Datentypen nutzen und hat Kontrollstrukturen zur Verfügung. Da die Makros letztendlich nur auf Commands arbeiten können, ist das Gefahrenpotenzial, was von unwissenden Nutzern ausgeht größtenteils eingeschränkt.
            }
    \end{itemize}
  \end{frame}

%---------------------------------
% Konzeption
%---------------------------------
\section{Konzeption}
  %---------------------------------
  % Syntax
  %---------------------------------
  \begin{frame}{Syntax}
  \end{frame}

  %---------------------------------
  % Klassen
  %---------------------------------
  \begin{frame}{Klassen}
  \end{frame}

\note{Everything you want}
%---------------------------------
% Realisierung
%---------------------------------
\section{Realisierung}
  %---------------------------------
  % Tokenizer
  %---------------------------------
  \begin{frame}{Tokenizer}
  \end{frame}
  %---------------------------------
  % Parser
  %---------------------------------
  \begin{frame}{Parser} % TODO mention Analyser
    \note{Analyser}
  \end{frame}
  %---------------------------------
  % Interpreter
  %---------------------------------
  \begin{frame}{Interpreter}
  \end{frame}
  %---------------------------------
  % Probleme
  %---------------------------------
  \begin{frame}{Probleme} % TODO Compiler Fehler, any
  \end{frame}

%---------------------------------
% Fragen
%---------------------------------
  \begin{frame}[standout]
    Fragen?
  \end{frame}

%---------------------------------
% Demo
%---------------------------------
  \section{Demo}

  \appendix
%---------------------------------
% Referenzen
%---------------------------------
  \begin{frame}[allowframebreaks]{Referenzen}
    % \bibliography{demo} FIXME
    % \bibliographystyle{abbrv} FIXME
  \end{frame}
\end{document}

