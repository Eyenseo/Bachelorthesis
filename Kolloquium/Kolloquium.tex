%---------------------------------
% Preamble
%---------------------------------
\input{preamble.tex}

\begin{document}

%---------------------------------
% Titlepage
%---------------------------------
\maketitle
    \note[enumerate] {
      \item Moin, ich denke ihr kennt alle meinen Namen und \ldots
      \item Da wir nur wenig Zeit haben, muss ich euch in den nächsten 20 min $15.000$ Zeilen Code erklären. Das sind 750 Zeilen pro Minute \ldots
    }

%---------------------------------
% Themen
%---------------------------------
\begin{frame}{Themen} % TODO good?
  \setbeamertemplate{section in toc}[sections numbered]
  \tableofcontents[hideallsubsections]
\end{frame}
    \note[enumerate] {
      \item Das kann ich allerdings keinem zumuten, weshalb ich in den folgenden Folien meine Arbeit sehr abstrakt erklären werde. In der Demo werde ich auch nur ein wenig auf den Code eingehen. Wodurch euch C++ Code größten Teils erspart bleibt.
      \item Wer im Anschluss Fragen zum Code hat -- ich werde gerne Fragen beantworten (und wahrscheinlich länger über C++ reden, als euch recht ist).
      \item Fragen zu der Präsentation und der Demo können vor und nach der Demo gestellt werde. Nachdem meine Professoren ihre Fragen gestellt haben, werde ich auch gerne Fragen von den Zuschauern beantworten, da ich möchte, dass jeder etwas von meiner Präsentation mitnehmen kann.
    }

% TODO C++ bitte möglichst klein halten. Interessanter ist ein Querschnitt durch die Arbeit, also von Anforderungen über Konzeption bis Realisierung und Eval - das kann (auch) man alles schön anhand von Konzepten machen, ohne sich in Programmiersprachendetails zu verlieren. Mir fallen da u.a. anderem ein: Makros, Command-Pattern, Architektur, die Kette Tokenizer -> Parser -> Interpreter, ... Fokussiere Dich auf zentrale Ideen - welche das sind, musst letztendlich Du entscheiden (Syntax würde ich ebenfalls klein halten (max. 1 Folie)).

%---------------------------------
% Was?
%---------------------------------
\section{Was?}
    \note[enumerate]{
      \item Fangen wir mit einer einfachen Frage an: `Was?'. \ldots
    }

  %---------------------------------
  % Was ist eine Makrosprache?
  %---------------------------------
  \begin{frame}{Was ist eine Makrosprache?}
    \pause
        \note[item]<.>{
          Was ist eine Makrosprache?
        }

    \begin{itemize}[<+- | alert@+>]
      \item
        Eine Programmiersprache
            \note[item]<.>{
              Eine Makrosprache ist mit euch bekannten Programmiersprachen zu vergleichen.
            }
            \note[item]<.>{
              Makros werden genutzt, um eintönige Arbeitsabläufe zu automatisieren.
            }
            \note[item]<.>{
              Makros führen also Befehle aus, die der Nutzer hätte ausführen können. Somit ist eine Makrosprache eine der höchsten (abstraktesten) Programmiersprachen.
            }
            \note[item]<.>{
              Zu vergleichen ist das am ehesten mit den Sprachen, die eine Virtuelle Maschine nutzen. Im Fall der Makrosprache ist die Anwendung die Virtuelle Maschine. Es sollte also kein Unterschied machen, ob ein Makro auf Windows geschrieben wurde und dann auf Linux oder XOS ausgeführt wird.
            }

      \item
        Eine Möglichkeit statische Systeme zu dynamischen umzuwandeln
            \note[item]<.>{
              Makros sind dynamisch.
            }
            \note[item]<.>{
              Makros sind Strings -- also eine Reihenfolge von Zeichen -- die erst zur Laufzeit der Anwendung erstellt werden. Diese werden entweder von dem Benutzer erzeugt oder z.B. von einer Datei gelesen. Das bedeutet, dass die Strings nicht zur Zeit der Entwicklung oder der Auslieferung des Softwaresystems bekannt sein müssen.
            }
            \note[item]<.>{
              Makros bieten den Nutzer an, eine Anwendung um Funktionen zu erweitern, ohne das die Anwendung erweitert werden muss.
            }

      \item
        Kein Script
            \note[item]<.>{
              Eine Makrosprache soll keine Scriptsprache sein. Zwar kann sich eine Makrosprache wie ein Script anfühlen, sollte aber keine sein.
            }
            \note[item]<.>{
              Der Unterschied von Makros und Scripts liegt vor allem darin, dass Scripts komplett neue Funktionalitäten erzeugen und Makros genutzt werden um vorhandene Funktionen zu automatisieren. -- Also ein Subset von Script darstellen.
            }
            \note[item]<.>{
              Es ist ein kleiner Unterschied -- der allerdings große Folgen hat. Eine Scriptsprache sollte eine wesentlich größere API anbieten, z.B. call-backs und threads support. Diese beiden würden Scripts ermöglichen, die nicht durch den Benutzer direkt angestoßen werden müssen und asynchron ihre Funktionen ausführen -- z.B. eine automatische Sicherung nach 5 Minuten.
            }
    \end{itemize}
  \end{frame}

  %---------------------------------
  % Was war meine Ausgangssituation?
  %---------------------------------
  \begin{frame}{Was war meine Ausgangssituation?}
    \pause
        \note[item]<.>{
          Was war meine Ausgangssituation?
        }

    \begin{itemize}[<+- | alert@+>]
      \item
        C++
            \note[item]<.>{
              Die Anwendung, für die diese Makrosprache entwickelt wurde, ist in C++ geschrieben.
            }
            \note[item]<.>{
              Das hat den Vorteil, dass die Anwendung das Potenzial hat extrem effizient und schnell zu arbeiten.
            }
            \note[item]<.>{
              Ein Nachteil ist, dass C++ eine statische Sprache ist -- also nach dem Kompilieren nicht verändert werden, kann was ausgeführt werden soll.
            }
            \note[item]<.>{
              Wäre sie in z.B. Python geschrieben, wären Makros nur ein weiteres Python Script welches geladen und abgearbeitet werden würde. (Was ziemlich einfach wäre zu implementieren.)
            }
      \item<+- | alert@+-+(2)>
        Command-Pattern\tikzmark{cmd-pattern}{}%
            \note[item]<.>{
              Ein zentrales Element er vorhandenen Software ist eine Implementation des CommandPatterns.
            }
            \note[item]<.>{
              Das Command-Pattern der Anwendung, ist die Schnittstelle, die die Makrosprache nutzt, um mit der Anwendung zu interagieren. \ldots
            }
        \begin{uncoverenv}<+->%
          \begin{tikzpicture}[overlay, remember picture]%
            \node[right=-2of cmd-pattern] (commanduml) {%
              \myInput{img/commanduml.tikz}%
            };
          \end{tikzpicture}%
          \begin{uncoverenv}<.>%
            \begin{tikzpicture}[overlay, remember picture]%
              \node[anchor=north east] (commanduml-cat_surprised) {\includegraphics[width=.5\linewidth]{img/cat_surprised}};
            \end{tikzpicture}%
          \end{uncoverenv}%
              \note[item]<.>{
                Nur weil wir die 750 Zeilen pro Minute sein lassen, heißt es nicht das es einfach wird!
              }
              \note[item]<.>{
                Ich werde euch die wichtigsten Elemente präsentieren, die bei der Entwicklung der Makrosprache, bzw. Programmiersprache, durchlaufen wurden.
              }
              \note[item]<.>{
                Dazu zählt auch dieses UML Diagramm, welches eine wichtige Grundlage ist. -- Es sieht schlimmer aus als es ist\ldots
              }
          \action{}
        \end{uncoverenv}
            \note[item]<.>{
              Der \textbf{Invoker} wird von dem \textbf{CommandProvider} an den \textbf{Client} gegeben -- der \textbf{Client} kann z.B ein Knopf in einer GUI sein.
            }
            \note[item]<.>{
              Der \textbf{HistoryStack} sorgt dafür, dass \textbf{Command}s rückgängig gemacht bzw. wiederhergestellt werden können.
            }
            \note[item]<.>{
              Das \textbf{Command} ist die Elternklasse von dem \textbf{ConcreteCommand} welche ihre Funktionalität in der \textbf{execute} Methode implementiert. Die einen Rückgabewert vom Typ any erlaubt.
            }
            \note[item]<.>{
              Ebenso zu beachten ist die \textbf{map<string, any>}. Diese erlaubt es beliebig viele Daten, mit beliebigen Datentypen, typsicher als Parameter zu übergeben -- ohne die Methodensignatur zu verändern.
            }
            \note[item]<.>{
              Der any Typ -- der beliebige Datentypen typsicher wrapped -- wird in C++17 enthalten sein.
            }
    \end{itemize}
  \end{frame}

%---------------------------------
% Anforderungen
%---------------------------------
\section{Anforderungen}
    \note[enumerate]{
      \item Anforderungen an die Lösung\ldots
    }

  \begin{frame}{Anforderungen}
    \begin{itemize}
      \item<+- | alert@+-+(1)>
        Dynamisches Typesystem
            \note[item]<.>{
              Die Makros sollten davon profitieren, dass die Commands Rückgabewerte und Parameter haben. Das heißt, dass es eine Möglichkeit geben muss, dass ``unbekannte'' Datentypen zwischengespeichert werden.
            }
            \note[item]<.>{
              Unbekannt impliziert, dass die Makrosprache mit allen Datentypen arbeiten können muss.
            }
            \note[item]<.>{
              Durch das dynamische Typsystem soll es also möglich sein, so etwas zu schreiben \ldots
            }
        \begin{uncoverenv}<+->%
          \tabto{4.6cm}
          \myMIn$var a = 10; a = "10";$
        \end{uncoverenv}
            \note[item]<.>{
              Hier wird der Variable \myMin{a} beim ersten Mal ein Integer zugewiesen und beim zweiten Mal ein String.
            }
            \note[item]<.>{
              Die Lösung für das zwischenspeichern ist der any Typ, der von dem Command-Pattern genutzt wird.
            }
      \item<+- | alert@+-+(1)>
        Kontrollfluss
            \note[item]<.>{
              Die Makros sollten auch eine Möglichkeit haben, auf den Zustand der Anwendung zu reagieren.

              Ein Beispiel wäre \ldots
            }
        \begin{uncoverenv}<+->
          \tabto{4.6cm}
          \myMIn$if(has_unsaved()) \{ save(); \}$\hspace*{-4cm} % Fixes unwanted linebreak
        \end{uncoverenv}
            \note[item]<.>{
              Das ein Makro nur probiert zu speichern, wenn es etwas zum speichern gibt.
            }
            \note[item]<.>{
              Generell sollte speichern schnell gehen, allerdings kann es passieren, dass eine mehrere Gigabyte große Datei geschrieben werden muss, was dem Nutzer nicht zumuten ist.
            }
      \item<+- | alert@+-+(2)>
        Benutzerfreundlichkeit
            \note[item]<.>{
              Außerdem soll die Makrosprache für den Benutzer leicht zu verstehen sein. Da der Benutzer auch der Endkunde sein kann \ldots
            }
        \begin{uncoverenv}<+-+>
          \begin{myInvBox}[width=.9\linewidth]
            \lstinputlisting[style=MyMacroStyle, backgroundcolor=, numbers=none, frame=,]{img/exmacro.txt}
          \end{myInvBox}
          \vspace{-10em}
        \end{uncoverenv}
            \note[item]<.>{
              Der Syntax sollte also deutlich machen, was passieren wird.
            }
            \note[item]<.>{
              Durch \myMIn$def$ wird automatisch klar, das eine Funktion definiert wird und \myMIn$var$ definiert eine Variable.
            }
            \note[item]<.>{
              Da die Implementation des CommandPatterns eine Map nutzt, um die Parameter des Commands anzugeben, habe ich mich entschieden named parameter zu nutzen (\textbf{foo:bar}). Diese schreiben keine Reihenfolge vor und ermöglichen das überladen von Funktionen anhand der Parameternamen.
            \note[item]<.>{
              Aber in meine Augen ist Syntax nur ein kleiner Punkt der Benutzerfreundlichkeit \ldots
            }
            }

        \begin{uncoverenv}<+->
          \begin{myInvBox}[width=.9\linewidth]
            \lstinputlisting[backgroundcolor=, numbers=none, frame=]{img/error2.txt}
          \end{myInvBox}
          \vspace{-6em}
        \end{uncoverenv}
            \note[item]<.>{
              In dem Beispiel wurde ein Semikolon in der main Methode vergessen, was die beiden Fehlermeldungen schnell deutlich machen.
            }
            \note[item]<.>{
              Wenn der Nutzer einen Fehler macht, soll dieser möglichst einfach zu finden sein -- man will mit einem Tool arbeiten, nicht dagegen kämpfen.
            }
            \note[item]<.>{
              Die Fehlermeldungen müssen dem Nutzer nicht nur sagen was falsch ist, sondern auch wo und weshalb.
            }
        \onslide<+->
            \note[item]<.>{
              Neben der Wartbarkeit, war auch die Macht dieser Makrosprache wichtig.
            }
            \note[item]<.>{
              Wie der Syntax gezeigt hat, geht die Sprache in die Richtung von Scripts, man kann Funktionen anlegen, primitive Datentypen nutzen und hat Kontrollstrukturen zur Verfügung.
            }
            \note[item]<.>{
              Da die Makros letztendlich nur auf Commands arbeiten können, ist das Gefahrenpotenzial -- was von unwissenden Nutzern ausgeht -- größtenteils eingeschränkt.
            }
    \end{itemize}
  \end{frame}

%---------------------------------
% Konzeption
%---------------------------------
\section{Konzeption}
    \note[enumerate]{
      \item Kommen wir nun zur Konzeption
      \item Die folgende Liste zeigt nicht nur, was entwickelt werden musste, sondern auch den abstrakten Ablauf, der beim Ausführen eines Makros stattfindet.
    }

  %---------------------------------
  % Was wurde entwickelt?
  %---------------------------------
  \begin{frame}{Was wurde entwickelt?}
    \begin{itemize}[<+- | alert@+>]
      \item<+- | alert@+-+(1)>
        Tokenizer
            \note[item]<.>{
              Als erstes brauchen wir einen Tokenizer.
            }
            \note[item]<.>{
              Der Tokenizer muss den String / das Makro zu einer Liste von Tokens -- also Teilstücke -- verwandeln \ldots
            }
        \begin{uncoverenv}<+-+>%
          \begin{tikzpicture}[overlay, remember picture, railroad]%
            \node[anchor=west, yshift=-1em] at (page cs:-.4,0) (tokenizerMacro) {%
              \begin{myInvBox}[width=.36\linewidth]%
                \lstinputlisting[style=MyMacroStyle, backgroundcolor=, numbers=none, frame=,]{img/exmacro_2.txt}%
              \end{myInvBox}%
            };%
            \node[right=1of tokenizerMacro] (tokenizerTokens) {%
              \begin{myInvBox}[width=.9\linewidth]%
                \lstinputlisting[backgroundcolor=, numbers=none, frame=,]{img/exmacro_2_tok.txt}%
              \end{myInvBox}%
            };%
            \graph[railroad]{(tokenizerMacro)->(tokenizerTokens);};%
          \end{tikzpicture}%
        \end{uncoverenv}%
            \note[item]<.>{
              Wichtig ist, dass bei dem erstellen der Liste, keine Informationen verloren gehen.
            }
            \note[item]<.>{
              Zwar wird die Reihenfolge durch das Tokenizen nicht verändert, allerdings gehen überflüssige Leerzeichen und Zeilenumbrüche verloren.
            }
            \note[item]<.>{
              Diese sind für Fehlermeldungen extrem wichtig und müssen mitgespeichert werden.
            }

      \item
        \temporal<.>{}{Abstrakter Syntaxbaum}{AST}
            \note[item]<.>{
              Für den Folgenden Schritt muss es Klassen geben, die einen abstrakten Syntaxbaum bilden.
            }
            \note[item]<.>{
              Ein Abstrakter Syntaxbaum beschreibt den Syntax aus dem Makro, ohne Informationsverlust und ist nur ein passiver Bestandteil des Ablaufes.
            }
            \note[item]<.>{
              ASTs werden genutzt, da es einfacher ist mit ihnen als Datenstruktur zu arbeiten, als mit einem String.
            }
            \note[item]<.>{
              Die meisten Elemente des Syntaxes lassen sich als Klasseninstanzen in dem AST wiederfinden. Prominente Ausnahmen sind Klammern, Semikolons und Leerzeichen.
            }
      \item<+- | alert@+-+(1)>
        Parser\tikzmark{parser}{}%
            \note[item]<.>{
              Das nächste aktive Element ist ein Parser.
            }
            \note[item]<.>{
              Der Parser ist dafür zuständig, dass die Liste von Tokens in einen abstrakten Syntaxbaum umgewandelt werden.
              \ldots
            }%
        \begin{uncoverenv}<+-+>%
          \begin{tikzpicture}[overlay, remember picture, railroad]%
            \node[anchor=west, yshift=-1em] at (page cs:-.4,0) (parserMacro) {%
              \begin{myInvBox}[width=.28\linewidth]%
                \lstinputlisting[backgroundcolor=, numbers=none, frame=,]{img/exmacro_2_tok.txt}%
              \end{myInvBox}%
            };%
            \node[right=.5of parserMacro] (parserTokens) {%
              \begin{myInvBox}[width=.9\linewidth]%
                \lstinputlisting[backgroundcolor=, numbers=none, frame=,]{img/exmacro_2_ast.txt}%
              \end{myInvBox}%
            };%
            \graph[railroad]{(parserMacro)->($(parserTokens.west)+(0:.6)$);};%
            \end{tikzpicture}%
        \end{uncoverenv}%
            \note[item]<.>{
              Das heißt, dass der Parser, die Tokens in \textbf{diese} Form überführen muss.
            }%
            \note[item]<.>{
              Die \textbf{@-Symbole} weisen auf eine AST Objektinstanz hin.
            }%
            \note[item]<.>{
              Das was in den Klammern (\textbf{\{\}}) eingeschlossen ist, ist ein Bestandteil des umschließenden Objektes.
            }%
      \item<+- | alert@+-+(1)>
        Analyser\tikzmark{analyser}{}%
            \note[item]<.>{
              Als vorletztes Element bedarf es einem Analyser.
            }
            \note[item]<.>{
              Der Analyser ist dafür da, um Fehler zu finden, die nicht aus dem Parsen hervorgehen. Also Fehler die nicht syntaktisch sind, oder nur schwer beim Parsen zu finden sind.
              \ldots
            }
        \begin{uncoverenv}<+-+>%
          \begin{tikzpicture}[overlay, remember picture]%
            \node[coordinate] at (page cs:-.4,0) (analyserMacroHelper){};
            \node[anchor=north west, yshift=.6em] at (analyserMacroHelper |- analyser) (analyserMacro) {%
              \myMIn$def fun()\{ break; \}$
            };%
          \end{tikzpicture}%
        \end{uncoverenv}
            \note[item]<.>{
              Ein Beispiel wäre die Funktion \myMin{fun}.
              }
            \note[item]<.>{
              Der AST kann den Code darstellen. Eine Funktionsdefinition, die in dem Funktionsscope ein break Element hat.
            }
            \note[item]<.>{
              Bloß macht dies wenig Sinn, da \myMin{break} nur in Schleifen eine Funktion hat.
            }
            \note[item]<.>{
              Es ist also wichtig dem Nutzer zu sagen, dass das was er geschrieben hat höchst wahrscheinlich nicht das ist, was er erwartet.
            }
      \item
        Interpreter
            \note[item]<.>{
              Letztlich bedarf es einem Interpreter.
            }
            \note[item]<.>{
              Der Interpreter interpretiert den AST, den der Parser erzeugt hat und ist die Komponente -- bzw. der Client, aus dem CommandPattern -- der die Commands ausführt.
            }
            \note[item]<.>{
              Somit kommen wir zu wir \ldots (zu weiteren UML Diagrammen)
            }
    \end{itemize}
  \end{frame}

  %---------------------------------
  % AST Klassenhierarchie
  %---------------------------------
  \begin{frame}{AST Klassenhierarchie}
    \begin{uncoverenv}<+>%
      \begin{tikzpicture}[overlay, remember picture]%
        \node[anchor=center] at (page cs:0,0) (commanduml-cat_surprised) {\includegraphics[width=.6\linewidth]{img/grumpy_cat}};
      \end{tikzpicture}%
    \end{uncoverenv}%
        \note[item]<.>{
          Zu weiteren UML Diagrammen.
        }
        \note[item]<.>{
          Für meinen Geschmack helfen die Diagramme nicht genug.
        }
        \note[item]<.>{
          Sie sind aber die beste Möglichkeit, die ich kenne, anderen Menschen mein Wissen, über die Datenstrukturen, zu mitzuteilen.
        }

    \begin{actionenv}<+->
      \begin{tikzpicture}[remember picture,overlay,every node/.style={anchor=center}]%
        \node at(current page.center) (ASTuml) {%
          \scalebox{.9}{%
            \myInput{img/ASTuml.tikz}%
          }
        };
      \end{tikzpicture}%
          \note[item]<.>{
            Die AST Klassenhierarchie.
          }
          \note[item]<.>{
            Alle abstrakten Syntax Klassen haben die \textbf{AST} Klasse als Elternklasse. Diese hat ein \textbf{Token}, welches das Stück des Makros enthält, welches es repräsentieren soll.
          }
    \end{actionenv}
  \end{frame}

  \begin{frame}{AST Scope}
    \begin{tikzpicture}[remember picture,overlay,every node/.style={anchor=center}]%
      \node at(current page.center) (Scopeuml) {%
        \scalebox{.7}{%
          \myInput{img/Scopeuml.tikz}%
        }
      };
    \end{tikzpicture}%
        \note[item]{
          Das \textbf{Scope} kann Instanzen von allen AST Klassen aufnehmen.
        }
        \note[item]{
          Durch die Aufnahme von anderen AST Instanzen wird hier ein Teil des Baumes erstellt.
        }
  \end{frame}

  \begin{frame}{AST Klassen}
    \begin{tikzpicture}[remember picture,overlay,every node/.style={anchor=center}]%
      \node at(current page.center) (Conditionuml) {%
        \scalebox{.7}{%
          \myInput{img/Conditionuml.tikz}%
        }
      };
    \end{tikzpicture}%
        \note[item]{
          Dieses UML Diagramm zeigt die restlichen Abhängigkeiten der AST Klassen -- die meisten Verbindungen sollten Selbstverständlich sein.
        }
        \note[item]{
          Ein Bestandteil einer \textbf{Funktion} ist ein \textbf{Scope}. Ein \textbf{Loop} besteht aus einem \textbf{Scope} und einer \textbf{Condition}. Eine \textbf{Condition} kann aus \textbf{Variablen}, Funktionsaufrufen (\textbf{Callable}) usw. bestehen.
        }
  \end{frame}

  \begin{frame}{Parser Klassen}
    \begin{tikzpicture}[remember picture,overlay,every node/.style={anchor=center}]%
      \node at(current page.center) (parserpackuml) {%
        \scalebox{.7}{%
          \myInput{img/parserpackuml.tikz}%
        }
      };
    \end{tikzpicture}%
        \note[item]{
          Das vorletzte Diagramm zeigt die Parser Klassen.
        }
        \note[item]{
          Der \textbf{Parser} nutzt den \textbf{Tokenizer} um eine \textbf{TokenList} von dem Makrostring zu erstellen.
        }
        \note[item]{
          Diese TokenListe wandelt er dann in einen \textbf{AST} um.
        }
        \note[item]{
          Der produzierte AST wird dann von dem \textbf{Analyser} überprüft.
        }
  \end{frame}

  \begin{frame}{Interpreter Klassen}
    \begin{uncoverenv}<+-+(1)>%
      \begin{tikzpicture}[remember picture,overlay,every node/.style={anchor=center}]%
        \node at(current page.center) (interpreterpackuml) {%
            \myInput{img/interpreterpackuml.tikz}%
        };
      \end{tikzpicture}%
          \note[item]<.>{
            Letztlich die Interpreter Klassen.
          }
          \note[item]<.>{
            Der \textbf{Interpreter} nutzt den \textbf{Parser} um einen AST zu erzeugen, den er dann interpretieren kann.
          }
          \note[item]<.>{
            Um dies zu tun, muss der Interpreter auch Daten verwalten. Das wird von dem \textbf{Stack} übernommen.
          }
          \note[item]<.>{
            Der Stack bildet einen Stack mit Instanzen von sich selber \ldots
          }
      \begin{uncoverenv}<+>%
        \begin{tikzpicture}[overlay, remember picture]%
          \node[anchor=center] at (page cs:-.5,-.4) (commanduml-no_you_didnt_cat) {\includegraphics[width=.5\linewidth]{img/no_you_didnt_cat}};
        \end{tikzpicture}%
      \end{uncoverenv}%
          \note[item]<.>{
             Diese Art und Weise einen Stack aufzubauen ist normal in C oder C++, da man dort Pointer zur Verfügung hat.
          }
    \end{uncoverenv}
    \begin{uncoverenv}<+-+>%
      \begin{tikzpicture}[remember picture,overlay,every node/.style={anchor=center}]%
        \node at(current page.center) (stackex) {%
            \myInput{img/stackex.tikz}%
        };
      \end{tikzpicture}%
          \note[item]<.>{
            In diesem Beispiel wird der Stack durch die drei Stack Instanzen (\textbf{0, 1 und 2}) gebildet.
          }
          \note[item]<.>{
            Ein späteres Beispiel wird wahrscheinlich mehr Aufschluss über die Funktionsweise und Vorteile bringen.
          }
    \end{uncoverenv}
    \begin{uncoverenv}<+-+>%
      \begin{tikzpicture}[remember picture,overlay,every node/.style={anchor=center}]%
        \node at(current page.center) (interpreterpackuml) {%
            \myInput{img/interpreterpackuml.tikz}%
        };
      \end{tikzpicture}%
          \note[item]<.>{
            Der \textbf{OperatorProvider} wird von dem Interpreter genutzt um die \textbf{Operator}en -- wie $+$ und $-$ -- auf Variablen anzuwenden.
          }
          \note[item]<.>{
            Die Nutzung eines OperatorProviders sorgt dafür, dass Operatoren für beliebige Datentypen angeboten werden können, ohne den Interpreter anzupassen.
          }
          \note[item]<.>{
            Der Code, des OperatorProviders ist sehr Interessant -- leider haben wir nicht genug Zeit um diesen durchzugehen. Weshalb ich euch wieder mit dem any Typ abspeisen muss, der auch hier ein wichtiger Eckpunkt ist.
          }
          \note[item]<.>{
            Um Funktionsaufrufe auszuführen -- die nicht zu selber definierten Funktionen aus dem Makro führen -- nutzt der Interpreter den \textbf{CommandProvider}.
          }
    \end{uncoverenv}
  \end{frame}

%---------------------------------
% Realisierung
%---------------------------------
\section{Realisierung}
    \note[enumerate]{
      \item Das war die trockene Theorie.
      \item In den Folgenden Folien werde ich an dem Vorherigen Beispiel die einzelnen Schritte erklären, die beim Interpretieren durchlaufen werden. Also das, was in der Demo im Hintergrund passieren wird.
    }

  %---------------------------------
  % Tokenizer
  %---------------------------------
  \begin{frame}{Tokenizer}
  \end{frame}
  %---------------------------------
  % Parser
  %---------------------------------
  \begin{frame}{Parser} % TODO mention Analyser
    \note{Analyser}
  \end{frame}
  %---------------------------------
  % Interpreter
  %---------------------------------
  \begin{frame}{Interpreter}
  \end{frame}


  %---------------------------------
  % Probleme
  %---------------------------------
  \begin{frame}{Probleme} % TODO Compiler Fehler, any
  \end{frame}

% A Parser for Things
% is a Function from Strings
% to Lists of Pairs
% of Things and Strings

% – Fritz Ruehr

  %---------------------------------
  % Ähnliche Werke
  %---------------------------------
  \begin{frame}{Ähnliche Werke} % TODO Compiler Fehler, any
  ChaiScript ... % TODO
  \end{frame}

%---------------------------------
% Fragen
%---------------------------------
  \begin{frame}[standout]
    Fragen?
  \end{frame}
      \note[itemize]{
        \item \textbf{Katzen:} Ich habe genug theoretische und zum teil langweilige Präsentationen in meinem Studium gesehen. Dem Trend wollte ich nicht folgen -- und auch wenn meine Präsentation nicht so viel Wissen vermittelt hat, hatte sie zumindest Katzen. Wer reine Theorie will, ist mit meiner THesis besser beraten als mit mir.
      }

%---------------------------------
% Demo
%---------------------------------
  \section{Demo}

  \appendix
%---------------------------------
% Referenzen
%---------------------------------
  \begin{frame}[allowframebreaks]{Referenzen}
    % \bibliography{demo} FIXME
    % \bibliographystyle{abbrv} FIXME
  \end{frame}
\end{document}

